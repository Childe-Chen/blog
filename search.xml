<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Iterator]]></title>
      <url>%2F2018%2F01%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BIterator%2F</url>
      <content type="text"><![CDATA[意图Iterator是行为模式的一种，允许在不暴露底层结构的情况下顺序访问聚合对象中的元素。 问题集合是编程中最常用的数据结构。它把一组对象放到一个单独的容器中。 大多集合看起来都像元素的列表。然而，一些集合以树、图或者其他复杂数据结构组织数据。并且每个集合都必须提供一个方法让用户可以按照顺序处理集合中的元素。 但是，要怎么顺序遍历一个复杂结构呢？必须有几个方法来做到这一点。比如，今天想要深度优先来遍历树。但是，明天又想宽度优先来遍历。下周，又可能需要随机访问集合元素。添加越来越多的遍历算法使其丧失了它主要的职责，即高效存储数据。另一方面，一些特定的算法只只在指定的应用场景中适用。 解决Iterator模式建议抽出集合遍历方法到一个叫做“Iterator”的独立对象中。 迭代器封装遍历细节，像当前位置及还有多少元素需要遍历。允许几个迭代器去独立遍历相同的集合。集合本身甚至不知道有人在访问它的元素。 甚至，如果你需要一个特别的方式来遍历一个集合，你只需要创建一个新的迭代器类而不需要改动集合代码。 真实世界的类比旅游向导你计划去罗马一周来参观它所有的景点。但是到那后，你花了很长的时间来找斗兽场。 另一方面，你还有些备用预算可以请当地的导游。这个导游可以带你去看每个景点并且能给你讲许多有趣的故事。 如果预算不够，你可以在手机上使用虚拟导游。它虽然没有真正的导游那么有趣，但是便宜。你可以只去你感兴趣的地方。 真正的导游和虚拟导游都是罗马提供的遍历景点的迭代器。 结构 Iterator定义了遍历集合的接口。通常有获取下/上一个元素方法和用来跟踪是否迭代完毕的方法。 具体的Iterator实现遍历集合的特定算法。迭代器对象应当自己追踪遍历进度。它允许几个迭代器独立遍历相同的集合。 Collection接口声明了可以被迭代的集合。正如我们之前提到的，不是每一个集合都被表示成一个列表。集合可能把元素存储在一个数据库中，需要通过远程API获取他们；或者存储在一个Composite树中。因此，集合本身可能会创建迭代器，因为有一定数量的迭代器能够处理给定的集合类型。 具体的Collection在每次客户端请求时都会返回一个新的特定的迭代器实例。注意，这个方法的参数都要返回抽象迭代器类型。这将使得客户端和具体的迭代器独立。 客户端通过集合和迭代器的通用接口工作。这种方式让客户端与具体的类解耦。它允许添加新的迭代器并且不要修改现有代码。 通常，客户端自己不创建迭代器，而是从集合对象获取。但是客户端总是可以直接创建迭代器如果它需要特定的迭代器。 伪代码在这个例子中，迭代器模式被用来遍历封装了访问Facebook社交关系的集合。这个集合提供了几种可以以不同方式遍历配置文件的迭代器。 friend迭代器遍历给定配置集合中所有的朋友。colleague迭代器遍历同样遍历给定配置文件集合中的朋友但跳过了那些不是同事的朋友。所有的迭代器遵循相同的接口，这些接口允许客户端在不深入社交网络细节的情况下获取配置（比如，认证，发送REST请求等）。 因为客户端代码通过通用接口同集合、迭代器协作，所以，需要支持新的社交网络时仅需要添加新的集合类，而不用改变现有代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// The collection interface must declare a factory method for producing// iterators. You can declare several methods if there are different kinds// of iteration available in your program.interface SocialNetwork is method createFriendsIterator(profileId): ProfileIterator method createCoworkersIterator(profileId): ProfileIterator// Each concrete collection will be coupled to a set of concrete iterator// classes it returns. But the client will not be, since the signature of these// methods returns iterator interfaces.class Facebook implements SocialNetwork is // ... The bulk of the collection's code should go here ... // Iterator creation code. method createFriendsIterator(profileId) is return new FacebookIterator(this, profileId, "friends") method createCoworkersIterator(profileId) is return new FacebookIterator(this, profileId, "coworkers")// The common interface for all iterators.interface ProfileIterator is method getNext(): Profile method hasMore(): bool// The concrete iterator class.class FacebookIterator implements ProfileIterator is // The iterator needs a reference to the collection that it traverses. private field facebook: Facebook private field profileId, type: string // An iterator object traverses collection independently from other // iterators. Therefore it has to store the iteration state. private field currentPosition private field cache: array of Profile constructor FacebookIterator(facebook, profileId, type) is this.facebook = network this.profileId = profileId this.type = type private method lazyInit() is if (cache == null) cache = facebook.sendSophisticatedSocialGraphRequest(profileId, type) // Each concrete iterator class has its own implementation of the common // iterator interface. method getNext() is if (hasMore()) currentPosition++ return cache[currentPosition] method hasMore() is lazyInit() return cache.length &lt; currentPosition// Here is another useful trick: you can pass an iterator to a client class,// instead of giving it access to a whole collection. This way, you do not// expose the collection to the client.//// But there is another benefit: you can change the way the client works with// the collection at run time by passing it a different iterator. This is// possible because the client code is not coupled to concrete iterator classes.class SocialSpammer is method send(iterator: ProfileIterator, message: string) is while (iterator.hasNext()) profile = iterator.getNext() System.sendEmail(profile.getEmail(), message)// The application class configures collections and iterators and then passes// them to the client code.class Application is field network: SocialNetwork field spammer: SocialSpammer method config() is if working with Facebook this.network = new Facebook() if working with LinkedIn this.network = new LinkedIn() this.spammer = new SocialSpammer() method sendSpamToFriends(profile) is iterator = network.createFriendsIterator(profile.getId()) spammer.send(iterator, "Very important message") method sendSpamToCoworkers(profile) is iterator = network.createCoworkersIterator(profile.getId()) spammer.send(iterator, "Very important message") 适用性 当你有一个复杂的数据结构，并且你想对客户端隐藏它的复杂性（为了安全或者方便）。 迭代器封装与复杂数据结构的交互并保护它免受粗心和恶意行为。迭代器模式允许客户端和集合元素协作而不必暴露集合对象。 当你需要几种不同的遍历数据结构的方式，但是你不能把它加到集合中或者这个代码和业务逻辑关联。 遍历数据结构的算法可能很大。把它放在集合或者主业务逻辑代码中，导致原有代码责任不明确且难以维护。把这些代码放在迭代器中让应用代码简洁和清晰。 当你想要一个单独接口来遍历不同的数据结构。 迭代器为所有实现者提供了通用的接口，允许在客户端代码中更换不同的迭代器。 如何实现 定义Iterator接口。它至少包含用来获取容器中下一个元素的方法。方便起见，它还可以包含获取上一个元素，追踪当前位置，检查是否到达迭代器尾部等方法。 创建Collection接口，它要提供获取一个新迭代器的方法。注意，它应当返回抽象迭代器类型。 为一个可迭代的集合实现一个具体的迭代器类。一个迭代器只能关联一个集合实例。通常通过迭代器的构造方法产生关联。 在相应的集合类中实现Collection接口。他们应当创建并返回一个适当的迭代器实例。集合通过迭代器的构造方法和迭代器建立关联。 在使用了这个模式后，在集合和客户端代码中应该不会再有遍历的代码。客户端每次需要迭代集合元素时都要通过集合获取新的迭代器。 优点 简化集合代码。 提供不同的方式遍历相同的数据结构。 允许并行遍历相同的集合。 缺点 对于使用简单集合的程序来说，有些导致矫枉过正。 和其他模式的关系 Iterator可以用来遍历Composite树。 Factory Method可以和Iterator一起使用，让集合的子类返回合适的迭代器。 Memento可以和Iterator一起使用来捕捉迭代器的当前状态，后面如果需要可以进行回滚。 Visitor可以和Iterator一起使用来遍历一个复杂的数据结构，并在这些元素上执行一些操作，即使他们类型不同。 小结Iterator可以在不暴露复杂数据结构的前提下让客户端顺序访问其元素。 Iterator模式在Java代码中很常见。很多框架和库都提供一种标准的方式来遍历他们的集合。 Java核心库中的java.util.Iterator和java.util.Enumeration是很好的例子。 参考翻译整理自：https://refactoring.guru/design-patterns/iterator]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Memento]]></title>
      <url>%2F2018%2F01%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BMemento%2F</url>
      <content type="text"><![CDATA[意图Memento是行为模式的一种，他允许你在不暴露对象内部结构的情况下捕获其内部状态，以便稍后对象可以返回到这个状态。 问题假设你在写一个文本编辑器。核心逻辑放在Editor主类中。另外一些特性，像文本格式化，内联图像等，放在不同的命令类中。 你决定让用户的操作变得可逆。换句话讲，要增加“撤销”功能。为了实现它，你需要在执行任何操作前保存Editor的状态。之后，如果用户决定还原他的一些操作，程序要从历史中拿出快照并恢复Editor到过去状态。为了拷贝一个对象的状态，你必须遍历它的字段并拷贝字段的值。但是，一个对象必须要有宽松的访问它内容的方式，可以让其他对象窥视其内部并拷贝他的内容。 虽然这种方式可以简单完成这个任务并且允许每个类都能够生产编辑器的备份，但是这种方式与我们的想法相去甚远。如果你决定重构或者修改Editor类的字段，你就必须同时修改那些和Editor耦合的类。 更近一步。我们考虑下真实的Editor备份。即使最原始的编辑器也必须有一些字段来存储数据，比如真实的文本，游标坐标，当前滚动的位置等。为了创建一个备份，你必须记录所有的值并把它们放到一些容器中。 这个容器中最终放置了一些类的对象。这些类可能有许多编辑器状态的镜像字段并且没有什么方法。为了允许其他对象能够读写数据到备份对象，你肯能需要把字段声明为public。但是，这将导致与无限制的Editor类相同的问题。Editor的变化将会影响其他的类。 看起来这个问题无解了。你要么暴露一个类的内部，使得所有关联的类变得脆弱，要么限制对状态的访问，使得撤销操作难以实现。难道没有其他方法了吗？ 解决上面问题的本质是破坏了封装。当一些对象试图做比他们想象的更多的事情时，往往会发生这种情况。这些对象不是请求其他对象为他们做一些事情，而是入侵了其他对象的私有空间来搜集执行动作需要的数据。 Memento模式把创建状态快照的工作委托给状态拥有者本身，也即是Originator对象。因此，也就不需要其他对象从外部拷贝Editor的状态，Editor本身就可以创建快照，因为它自己可以访问自己的所有状态。 模式提供了一种特殊对象来存储对象状态的快照，叫做Memento。memento的内容除了创建者自己外其他的对象都无法访问。其他对象可以通过限制性接口和menento交流，该接口只允许获取快照的元数据，比如创建时间，标签等。 这些数据保护允许把memento存储在叫做Caretakers的对象中。因为他们只能通过限制性接口访问menento，caretakers无法修改存储在里面的状态。 在编辑器例子中，我们创建一个单独的History类来扮演caretakers。它把memento组织成一个栈，每个操作被执行前它会被压入新的memento。当用户触发撤销操作，History弹出栈顶memento并把它传给Editor，请求回滚。因为Editor可以完全访问memento，它将用memento的状态值覆盖当前变量值。 结构嵌套类实现经典的实现方式依赖编程对嵌套类的支持，许多流行的编程语言（C++，C#和Java）都支持该方式。 Originator包含复杂的状态并且你不想把它们暴露出去。它能够自己创建快照，也能够在需要的时候从快照恢复。 Memento是一个值对象，用来扮演Originator状态的快照。最佳实践是将Memento做成不可变的，并且Memento只通过其构造方法接收一次数据。 Caretaker不仅知道何时及为什么要捕捉Originator的状态，也知道什么时候应该恢复状态。 caretaker能够把originator的状态存储成一个栈。当originator要回到历史时，caretaker拿到栈顶数据并把它传给originator的恢复方法。 这种实现的下，Memento是Originator的嵌套类，Memento可以访问Originator的变量和方法，即使他们被声明为private。另一方面，Caretaker被限制性访问Memento的字段和方法，这对存储memento很好但是对修改他们的状态不是很好。 中间接口实现不支持嵌套类语言（PHP）的替代方式。 在没有嵌套类的情况下，通过让caretaker使用有限接口和memento协作来限制其对memento的访问。 另一方面，originator可以直接和memento类协作并访问他的public方法，而caretaker不行。 更严格的封装实现当你不想给远程的其他类通过Memento来访问Originator状态时，这种方式很有用。 这种实现允许有多个类型的originator和memento。每个originator和其对应的memento协作。originator和memento不把他们的状态暴露给任何人。 Caretaker不能间接修改memento存储的状态。甚至，它独立与originator。和originator的关联及恢复方法都移动到memento中。 每个memento都关联指定的originator。originator把它自己和状态值一起传入到memento的构造方法中。由于具体的memento和originator之间的密切关系，memento可以恢复其originator的状态。 伪代码在这个例子中，采用Memento和Command模式来存储复杂的文本编辑器对象并在需要时恢复它。 command对象扮演caretaker，在它执行前请求editor创建一个memento。当用户需要回滚操作时，之前command关联的memento就可以反转编辑器的状态。 memento不需要有任何public的字段，set或者get方法。因此没有对象可以修改它的内容。memento和创建它的editor关联在一起，能够随意恢复它的状态。这就允许应用支持多个独立的编辑器窗口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Originator class should have a special method, which captures originator's// state inside a new memento object.class Editor is private field text, cursorX, cursorY, selectionWidth method setText(text) is this.text = text method setCursor(x, y) is this.cursorX = cursorX this.cursorY = cursorY method setSelectionWidth(width) is this.selectionWidth = width method createSnapshot(): EditorState is // Memento is immutable object; that is why originator passes its state // to memento's constructor parameters. return new Snapshot(this, text, cursorX, cursorY, selectionWidth)// Memento stores past state of the editor.class Snapshot is private field editor: Editor private field text, cursorX, cursorY, selectionWidth constructor Snapshot(editor, text, cursorX, cursorY, selectionWidth) is this.editor = editor this.text = text this.cursorX = cursorX this.cursorY = cursorY this.selectionWidth = selectionWidth // At some point, old editor state can be restored using a memento object. method restore() is editor.setText(text) editor.setCursor(cursorX, cursorY) editor.setSelectionWidth(selectionWidth)// Command object can act as a caretaker. In such case, command gets a memento// just before it changes the originator's state. When undo is requested, it// restores originator's state with a memento.class Command is private field backup: Snapshot method makeBackup() is backup = editor.saveState() method undo() is if (backup != null) backup.restore() // ... 适用性 当你需要制作一些对象的快照以便稍后恢复其状态时。 Memento模式允许生成对象状态的完整副本，并将其与对象分开存储。虽然这种模式的“撤销”应用已经相当普遍，但在处理交易时也是不可或缺的（如果你需要在出错时会滚一个操作）。 当直接访问对象的字段/setter/getter违反了其封装时。 Memento让对象自己有能力创建自己状态的快照。其他对象不能读取这个快照，使得这个对象的状态变得安全可靠。 如何实现 确定那个类扮演Originator角色。知道程序使用这种类型的一个还是多个中心对象是很重要的（？）。 创建memento类。挨个声明Originator类需要镜像的字段。 让Memento对象不可变。他们应该通过构造方法一次性初始化字段的值。Memento类不应该有setter方法。 如果你的编程语言支持嵌套类，把Memento当作Originator的内部类。 如果不支持，抽象出一个memento类的一个接口，并让其他要和Memento关联的对象使用这个接口。你应该在接口中添加一些操作元数据的方法，但不要暴露originator的状态。 为Originator类添加创建memento的方法。Originator应该通过传递向memento构造方法传递它属性值的方式来创建一个新的memento实例。 这个方法的返回类型应当是之前抽象出来的接口类型（如果你提取了的话）。但是在这个方法内部，你要和具体的memento类型协作。 为Originator类增加恢复状态的方法。这个方法把memento对象当作参数之一。按照与上一步相同的逻辑分配参数类型。 对caretaker而言，不管是操作历史，命令对象，或者其他不同的实体，它都应当知道何时向originator请求一个新的memento，如何存储它以及恢复它。 caretaker和originator的关联关系可以移动到memento中。在这种情况下，每个memento都有与之对应的originator。它将有责任恢复originator的状态。但这仅当memento是originator的内部类或者originator提供了相应的复写其状态的setter方法时。 优点 没有破坏originator的封装。 通过允许caretaker来维护originator历史状态的方式，简化了originator的代码。 缺点 如果客户端频繁创建memento会浪费许多RAM。 caretaker需要追踪originator的生命周期以便清理过时的memento。 大多数动态编程语言，像PHP，Python或者JavaScript，不能保证memento中的状态是不变的。 和其他模式的关系 Command和Memento可以一起使用。他们可以充当魔法token，在稍后时间被传递和调用。在Command中，token代表一个请求；在Memento中，token代表一个对象在特定时间的内部状态。多态对Command很重要，但对Memento不重要，因为它的接口很狭隘所以只能被当作值传递。 Memento可以和Iterator一起只用来捕捉当前迭代的状态，在有必要的时候进行回滚。 如果一个对象想在历史中保存状态相对简单（没有外部资源的链接，或者这些链接很容易重新建立），Prototype可以作为Memento更简单的替代方案。 参考翻译整理自：https://refactoring.guru/design-patterns/memento]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-行为模式之Command]]></title>
      <url>%2F2017%2F12%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8Bcommand%2F</url>
      <content type="text"><![CDATA[意图Command（命令）是一种行为模式，让你可以把请求转换到单独的对象，可以用来把不同的请求参数化，排队或者记录请求，并且支持撤销操作。 问题假设你在做一个新的文本编辑器。你创建了一个Button类，可以被用做工具栏的按钮，也可以用作对话框的通用按钮。 这些按钮看起来很像，但是它们做不同的事情。此时我们要把针对不同按钮点击的处理代码放在哪里呢？简单的解决方法是为每个按钮创建一个Button的子类，然后把处理点击事件的代码放到子类中。 但是这么做的缺点很明显。首先，你创建了许多子类。其次，GUI代码依赖了易变的业务逻辑代码。还有更加讨厌的部分。一些操作，比如拷贝文本，可以在几个不同地方调用。比如，工具栏的按钮，上下文菜单的按钮或者使用Ctrl+C。当应用只有按钮时，拷贝逻辑的代码只会出现在CopyButton子类中。但是，现在你需要拷贝相同的代码到其他两个地方。 解决Command模式建议封装请求到它们各自的命令（command）对象中。如果这个操作有参数，把它们变成command类的字段。 大多数command作为客户端之间的链接，它们触发请求和接收对象，接收对象通过执行一些操作来处理它们。 现在command只有一个无参方法，让各个command遵循通用接口很容易。通常，一个command接口只有一个类似execute()的方法。一旦通用接口创建，你可以用command替换掉客户端代码之前耦合的特定操作。 在编辑器例子中使用了Command模式之后，你讲不再需要Button子类。基础类将需要增加一个字段来保存command对象的引用。一个按钮对象将把用户发起的点击请求委托给关联的command对象，而不是自己去完成处理。command要么他自己执行一些操作要么把它委托给一个业务逻辑对象。 你可以对上下文按钮和热键代码做类似处理。这些类将把工作委托给在它们之间共享的单个command对象。 因此，command类将使得GUI和业务逻辑类的衔接变得很方便。这只是Command众多优点中的一部分。 真实世界的类比在餐厅下单你到一个餐厅中并找了个靠窗的位置坐下。服务员拿走了你写在纸上的订单，把它贴在厨房的墙上，它之前还有其他订单。 正如你猜的那样，这个纸条就是一个command。它排在队列中知道一个厨师准备去做。这个订单包含了做这道菜的所有信息。他允许厨师立马开始做菜而不是跑来跑去来搞清楚订单的细节。 结构 Invoker保存Command对象的引用，并且当一个操作需要被执行的时候使用它。Invoker通过通用接口和command协作，这个接口通常只有一个execute()方法。Invoker不负责创建command对象。他们通常通过构造函数从客户端获取预创建的command。 为具体的Command声明接口。接口最少需要一个方法来执行实际操作。 具体的Command实现实际操作。一些command是自足的，不可变的。它们通过构造方法一次性接收所有必要的数据。其他的需要一个Receiver，作为外部的上下文对象。 Receiver包含特定命令所必需的业务逻辑或数据。命令可以查询这些对象的其他信息或整个操作委托给他们。在某些情况下，为了简单起见，可以将接收者的代码合并到命令类中。 Client创建并配置具体的Command对象。然后把他们传给适当的Invoker。 伪代码在这个例子中，Command模式用来记录操作历史，还可以还原它。不想之前的例子，这个应用每次用户操作都创建一个新的command。之后在帮助列表中会展示这些个性的命令。 在执行操作前，command会创建编辑器当前状态的备份。执行后，command把自己放到历史栈中。 客户端的代码，比如UI元素，command历史和其他类将不会和具体的command类耦合，因为他们通过command接口来协作。这就允许在不改变已存在代码的情况下新增command。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// Abstract command defines the common interface for all concrete commands.abstract class Command is protected field app: Application protected field editor: Editor protected field backup: text constructor Command(app: Application, editor: Editor) is this.app = app this.editor = editor // Make a backup of the editor's state. method saveBackup() is backup = editor.text // Restore the editor's state. method undo() is editor.text = backup // The execution method is declared abstract in order to force all concrete // commands to provide their own implementations. The method must return // true or false depending on whether or not the command changes the // editor's state. abstract method execute()// Concrete commands.class CopyCommand extends EditorCommand is // The copy command is not saved to the history since it does not change // editor's state. method execute() is app.clipboard = editor.getSelection() return falseclass CutCommand extends EditorCommand is // The cut command does change the editor's state, therefore it must be // saved to the history. And it will be as long as the method returns true. method execute() is saveBackup() app.clipboard = editor.getSelection() editor.deleteSelection() return trueclass PasteCommand implements Command is method execute() is saveBackup() editor.replaceSelection(app.clipboard) return true// The undo operation is also a command.class UndoCommand implements Command is method execute() is app.undo() return false// The global command history is just a stack.class CommandHistory is private field history: array of Command // Last in... method push(c: Command) is Push command to the end of history array. // ...first out method pop():Command is Get the most recent command from history.// The editor class has an actual text editing operations. It plays the role of// a receiver: all commands end up delegating execution to the editor's methods.class Editor is field text: string method getSelection() is Return selected text. method deleteSelection() is Delete selected text. method replaceSelection(text) is Insert clipboard contents at current position.// The application class sets up object relations. It acts as a sender: when// something needs to be done, it creates a command object and executes it.class Application is field clipboard: string field editors: array of Editors field activeEditor: Editor field history: CommandHistory // The code which assigns commands to UI objects may look like this. method createUI() is // ... copy = function() &#123; executeCommand(new CopyCommand(this, activeEditor)) &#125; copyButton.setCommand(copy) shortcuts.onKeyPress("Ctrl+C", copy) cut = function() &#123; executeCommand(new CutCommand(this, activeEditor)) &#125; cutButton.setCommand(cut) shortcuts.onKeyPress("Ctrl+X", cut) paste = function() &#123; executeCommand(new PasteCommand(this, activeEditor)) &#125; pasteButton.setCommand(paste) shortcuts.onKeyPress("Ctrl+V", paste) undo = function() &#123; executeCommand(new UndoCommand(this, activeEditor)) &#125; undoButton.setCommand(undo) shortcuts.onKeyPress("Ctrl+Z", undo) // Execute a command and check whether it has to be added to the history. method executeCommand(command) is if (command.execute) history.push(command) // Take the last command from the history and run its undo method. Note that // we do not know the class of that command. But we don't have to, since the // command knows how to undo its own action. method undo() is command = history.pop() if (command != null) command.undo() 适用性 当你想要把行为参数化成对象。举个例子，你在开发一个用户接口组件，比如一个菜单，你想你的用户可以配置菜单元素被点击之后的行为。 Command模式将操作转换为可以从各种UI元素链接的对象。每个元素把工作委托给command对象而不是自己去做。command可以自己执行操作或者调用时昂的业务逻辑对象。 当你需要排队，规划，或者执行远程操作。 和其他任何对象以牙膏，command是可以序列化的，意味着它可以转换成一个字符串。这个字符串可以背保存到一个文件或者数据库并且稍后可以再把它转换成一个commadn对象。甚至，你可以通过网络发送一个序列化的command，然后在远程服务上恢复并执行它。 当你需要撤销操作。 想要支持撤销操作的第一件事就是保存历史。尽管有很多实现方式，Command模式或许是最流行的。 command历史栈由已执行的command对象组成。每个command在执行操作前线创建当前应用状态的快照。在操作完成后，command把自己压入历史栈中。注意，它始终保持应用程序状态的备份。当需要撤销时，程序从历史栈中拿到栈顶command并且恢复它存储的快照。 这个方法有两个缺点。首先，保存应用的状态不容易，因为一些是私有的。这个问题可以使用Memento模式缓解。 其次，状态的保存需要消耗大量RAM。因此，有时候你可以修改实现，不是恢复过去的状态，而是执行命令的逆操作。这个选择是昂贵的。反转操作通常很难以实现甚至不能实现。 如何实现 声明只有一个execute方法的Command接口。 在遵循通用Command接口情况下抽离操作到具体的Command实现中。把操作的参数转换成具体command类的字段。他们应当通过command的构造方法来初始化。 确保command中有字段来持有需要和它协作Receiver对象的引用。这个字段也应该通过构造方法来初始化。 识别Invoker类并为其提供用于存储command对象的字段。Invoker应当只通过Command的接口和command对象交互。他们通常不是自己创建command对象，而是从客户端获取。 应用的主要代码，看作Client，应该创建并配置具体的command并且传递给适当的Invoker对象。有时，多个Invoker可以使用相同的command对象。 优点 解耦操作调用和处理类。 允许撤销操作。 允许延迟操作。 允许简单命令组装成更大的命令。 符合开闭原则。 缺点 创建了多个额外类导致代码复杂度上升。 和其他模式的关系 Chain Of Responsibility，Command，Mediator和Observer处理连接请求的发送者和接收者的各种方式： 责任链沿着潜在接收者的动态链顺序传递一个请求，直到其中一个处理这个请求。 命令模式建立从发送者到接收者的单向连接。 调解模式持有发送者和接收者间接引用。 观察者会在同一时间把一个请求发送给所有关心的接受者，但是允许它们动态的确定是否继续订阅和取消订阅后面的请求。 责任链中的处理者可以表示为命令（Command）。在这种情况下，许多不同的操作可以在由请求表示的相同上下文中执行。 但还有另外一种方式，请求本身就是一个Command对象，沿着对象链传递。这种情况下，相同的操作可以在由链条对象表示的不同上下文中执行。 Command和Memento可以一起使用。他们可以充当魔法token，被延迟传递和调用。在Command中，token代表一个请求；在Memento中，它代表了某个特定时间的物体的内部状态。多态性对Command而言是重要的，但对于Memento来说却是非常重要的，因为它的接口太狭隘所以Memento只能作为一个值来传递。 Command和Strategy很像，因为他们都用于参数化一些行为的上下文。Command被用来转化任意操作到一个对象。操作的参数变成对象的字段。转换允许延迟或远程执行命令，存储命令历史等。 另一方面，Strategy模式通常来描述做相同事情的不同方式。它可以帮助在单个上下文类中交换这些算法。 在我们需要保存Command拷贝到历史中时Prototype可以提供帮助。 Visitor模式就像增强版的Command模式，可以对任何类型的对象执行操作。 小结Command是行为模式的一种，可以将请求或者简单的操作转换到对象中。这种转换允许延迟或者远程执行命令，存储命令历史等。 在Java中这种模式很常见。大多数情况下，它被用作参数化UI元素的动作回调。也被用来任务排队，追踪操作历史等。 Java核心库中的一些例子： java.lang.Runnable接口的所有实现 javax.swing.Action接口的所有实现 参考翻译整理自：https://refactoring.guru/design-patterns/command]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Chain-Of-Responsibility]]></title>
      <url>%2F2017%2F12%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8Bchain-of-responsibility%2F</url>
      <content type="text"><![CDATA[意图责任链（Chain Of Responsibility）是一种行为模式，通过给多个对象一个机会去处理请求的的方式来避免请求发送者和接受者的耦合。责任链接收对象并且沿着链条传递它，直到一个对象来处理它。 问题假设你在做一个订单系统。你第一个任务就是限制用户对系统的访问，只有已经授权的用户可以创建订单。另外，一些用户拥有管理员权限，可以访问全部的订单。 你意识到这些检查必须顺序处理。程序能够在任何时候对用户进行尝试认证，只要用户的证书被请求传递。但是，如果未能对用户进行身份验证，则无法检查用户的权限。几个月后，你已经实现了这些顺序检查。 你的同时建议，将原始数据直接交给代码处理不安全。所以你添加了一个额外校验步骤来验证请求数据。 之后，其他人建议协同无法应对暴力的密码破解。为了解决这个问题，你添加了另一个检查来过滤重复使用相同用户名但是失败的请求。 你甚至添加了缓存来提升订单在高负载下的性能。 不幸的是，随着新特性的增加，代码变得越来越臃肿。甚至，你为了保护其他页面，把这些检查代码的一部分做了拷贝，导致出现重复代码片段。 这个系统变得难以维护。但是，一天你收到了重构系统的任务… 解决和其他行为模式很像，责任链依赖于将行为转化为独立的对象。在我们的例子中，每个检查都将被移动到不同的类中，这些类只有一个方法来执行这些检查。这个方法通过参数来接收请求数据。 现在，到了有趣的部分。模式建议连接这些对象到一个链条中。 每个处理者都有一个字段来存储这个链条中下一个处理者的引用。不管什么时候，一个处理者接收到一个请求，它可以把请求传递给链条中在其之后的处理者。这个请求沿着链条旅行知道所有的处理者都有机会来处理它。 最后，一个处理者不需要在继续传递这个请求。有两种流行的方式来处理这个想法。 在我们访问过滤的例子中，处理者排队并挨个处理他们的检查。流的终点只可能是某个检查失败或者到达链条尾部。 但还有一个略微不同的方式，处理者只会传递那些它们自己无法处理的请求。否则，它们执行自己的业务并且终止链条的执行。这个选项在处理GUI组件事件时很常见。 比如，当用户点击一个按钮，这个事件便沿着由按钮开始的组件链传播，传到他们的父组件，像form和panel，直到应用的窗口停止。这个事件被链条中第一个可以处理它的组件处理。这个例子值得一提，因为它告诉我们一个链条可以从一个树结构中抽离出来。 所有的处理者类都需要遵循一样的接口。这将让你可以在运行时使用各个处理者组合一个链条，而代码不会和处理者的具体实现类耦合。每个具体的处理者应该只关心自己的execute方法。 现实世界的类比技术支持你为你的PC买了一个新的显卡。Windows可以自动检测并启用他。但你钟爱的Linux却无法使用新硬件。抱着微小的希望，你打电话给技术支持。 首先，你听到了自动应答的机器人声音。它提出了九种解决各种问题的流行解决方案，但没有一个与你的问题有关。过了一会，机器把你转给在线客服。 客服也没有给出有用的解决方法，于是你请求联系一个正确的工程师。 客服把你转给了工程师。最后，这个工程师告诉你到哪下载显卡驱动及如何在Linux中怎么安装。于是，你愉快的结束了这通电话。 结构 Handler为所有具体的处理者声明一个通用接口。通常，它只有一个处理请求的方法，但有时候也会有设置链条下一个处理者的方法。 Base Handler是可选的类，它可以包含负责构建维护对象责任链的模版代码。 这个类可以包含一个字段来存储链条中下一个处理者。使用这个字段，客户端可以将多个处理者链接到一个链中。这个字段可以通过构造方法或者一个set方法来控制。这个类也可能有一个基本处理方法的实现，这个方法检查下一个处理者是否存在然后把执行传递给它。 Concrete Handlers包含处理请求的实际代码。接收到请求后，处理者必须决定是否处理该请求，另外还要决定是否在链条中继续传递它。 处理者通常是独立的和不可变的，通过构造函数参数一次性接收所有必要的数据。 Client可以只组装一次链条或者依赖于程序逻辑动态组装。注意，一个请求可以被发送到链中的任何处理者，它并不总必须是第一个。 伪代码在这个例子中，责任链负责显示活动UI元素关联的一个上下文帮助。 这些GUI元素是树状结构。Dialog类渲染树根的主窗口。中间层由Panel组成。叶子结点有：Component、Button、TextEdit等。 一个Component能够显示上下文提示，只要它有帮助文本。一些复杂的组件有他们自己的方式来显示上下文帮助。 当用户将鼠标光标指向组件并按下F1时，应用抓取这个组件并发送帮助请求。这个请求向上传递给所有父容器知道这个组件可以显示帮助。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Handler interface.interface ComponentWithContextualHelp is method showHelp() is// Base class for simple components.abstract class Component implements ContextualHelp is field tooltipText: string // Container, which contains component, severs as a following object // in chain. protected field container: Container // Component shows tooltip if there is a help text assigned to it. Otherwise // it forwards the call to the container if it exists. method showHelp() is if (tooltipText != null) Show tooltip. else container.showHelp()// Containers can contain both simple components and other container as// children. The chain relations are established here. The class inherits// showHelp behavior from its parent.abstract class Container extends Component is protected field children: array of Component method add(child) is children.add(child) child.container = this// Primitive components may be fine with default help implementation...class Button extends Component is // ...// But complex components may override the default implementation. If a help can// not be provided in a new way, the component can always call the base// implementation (see Component class).class Panel extends Container is field modalHelpText: string method showHelp() is if (modalHelpText != null) Show modal window with a help text. else parent::showHelp()// ...same as above...class Dialog extends Container is field wikiPage: string method showHelp() is if (wikiPage != null) Open a wiki help page. else parent::showHelp()// Client code.class Application is // Each application configures the chain differently. method createUI() is dialog = new Dialog("Budget Reports") dialog.wikiPage = "http://..." panel = new Panel(0, 0, 400, 800) panel.modalHelpText = "This panel does..." ok = new Button(250, 760, 50, 20, "OK") ok.tooltipText = "This is a OK button that..." cancel = new Button(320, 760, 50, 20, "Cancel") // ... panel.add(ok) panel.add(cancel) dialog.add(panel) // Imagine what happens here. method onF1KeyPress() is component = this.getComponentAtMouseCoords() component.showHelp() 适用性 当一个程序有几个处理不同请求的处理者，但事先并不知道过来的是什么类型的请求。 你要把几个处理者放到一个链条中。请求沿着链条传递直到有个处理者能够处理它。 当要以特定顺序执行处理程序。 责任链允许按照给定的顺序依次执行处理者。 当有很多对象来处理请求，并且它们的顺序动态改变。 责任链允许对一个存在的链条中的处理者进行新增、移除或者排序操作。 如何实现 声明Handler接口，包含一个处理请求的方法。决定如何传递请求的信息到方法中。最灵活的方法是将请求数据转换为对象并传递给处理方法。 为了减少重复的样板代码，从Handler接口派生出一个抽象BaseHandler类是很值得的。 添加一个字段来保存下一个处理者的引用。这个字段可以从构造参数中获得初始化数据。你也可以定义一个set方法来修改这个字段。但仅当你想要在运行时想要修改链条才需要这么做。 实现处理方法，以便将请求转发给链中的下一个对象（如果有的话）。具体的处理者能够通过调用父类方法来转发请求。因此，它们不需要访问引用字段，你就可以把它声明为private了。 创建ConcreteHandler子类并且实现它们的处理方法。每个处理者在收到请求时应做出两个决定： 是否要处理这个请求。 是否要继续传递这个请求。 Client可以自己组装链条也可以从其他对象接收已经构造好的链条。在后一种情况下，可以采用工厂对象通过应用配置护着环境变量来构建链条。 Client可能触发链条中任意一个处理者，不仅仅只是第一个。这个调用将会沿着链条传递直到链条结尾或者一些处理者拒绝进一步传递它。 由于链条的动态特性，Client应该准备好处理以下情况： 有时一个链可能包含一个单一的链接。 一些请求可能无法到达链条的尾部。 一些请求到达链条尾部还未被处理。 优点 减少请求发送者和接受者的耦合。 遵循单一职责原则。 遵循开闭原则。 缺点 一些请求肯能到链条尾部仍未被处理。 和其他模式的关系 Chain Of Responsibility，Command，Mediator和Observer处理连接请求的发送者和接收者的各种方式： 责任链沿着潜在接收者的动态链顺序传递一个请求，直到其中一个处理这个请求。 命令模式建立从发送者到接收者的单向连接。 调解模式持有发送者和接收者间接引用。 观察者会在同一时间把一个请求发送给所有关心的接受者，但是允许它们动态的确定是否继续订阅和取消订阅后面的请求。 责任链通常和组合（Composite）结合使用。在这种情况下，一个组件的父类可以看作是他的后继者。 责任链中的处理者可以表示为命令（Command）。在这种情况下，许多不同的操作可以在由请求表示的相同上下文中执行。 但还有另外一种方式，请求本身就是一个Command对象，沿着对象链传递。这种情况下，相同的操作可以在由链条对象表示的不同上下文中执行。 责任链和装饰者（Decorator）的类结构很相似。它们都依赖于递归组合来在一系列对象中传递执行。但是它们也有几个关键区别。 责任链的处理者能够随意执行动作，之间相互独立。它们也能够随意终止请求的进一步传递。另一方面，各个装饰者扩展一个特定行为并应该保持其接口一致。另外，装饰者不允许随意中断链条的执行。 小结责任链允许请求烟盒潜在的处理链传递直到某个处理者处理这个请求。这种模式允许多个对象处理这个请求而不发送者类不需要和具体接受者类耦合。这个链可以在运行时动态组合遵循标准处理者接口的任何处理者。 在Java中比较流行的使用样例：在GUI类中向父组件传递事件；过滤访问请求。 在Java的核心类库中有些例子： javax.servlet.Filter#doFilter() java.util.logging.Logger#log() 当我们发现组织结构类似以下描述时，可能就采用了责任链模式：一个对象的行为方法间接调用其他对象中的相同方法，而所有对象都遵循共同的接口。 参考翻译整理自：https://refactoring.guru/design-patterns/chain-of-responsibility]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Singleton]]></title>
      <url>%2F2017%2F11%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BSingleton%2F</url>
      <content type="text"><![CDATA[意图Singleton是创建模式的一种，让你可以确保一个类只有一个实例，并为此实例提供一个全局访问点。 问题Singleton同时解决了两个问题（违反了单一职责原则）： 确保一个类只有一个实例。最常见原因是控制一些共享资源，比如，数据库。 假设你已经创建了一个新对象，不久，又尝试创建一个新的。在这种秦光下，你想要老的那个对象而不是新创建一个实例。 它不能通过正常的构造方法完成，因为在设计上每个构造方法总是返回一个新对象。 为实例提供一个全局的访问点。听起来像一个全局变量，不是吗？但是你无法做一个只读的全局变量。任何可以访问这个变量的人都可以替换他的值。 还有另外一个问题：你不希望解决以前的问题的代码分散在你的程序中。它们最好放在一个类中，特别当你的代码已经依赖那个类时。 注意，Sigleton同时解决了上面两个问题。但是现在模式很流行，即使他只解决了其中一个问题人们也会把它称为Sigleton。 解决单例所有实现的都有以下两个步骤： 创建私有的构造方法。 创建静态的创建方法扮演构造方法的角色。这个方法使用私有的构造方法创建一个对象并把它保存在静态变量或者字段中。对这个方法的所有调用都将返回缓存的对象。 Singleton保持把单实例的生产代码放在一个地方–Singlton类的创建方法中。任何可以访问Singleton类的客户端也都可以访问他的创建方法。因此，他提供给我们Singleton实例的一个全局访问点。 真实世界的类比政府政府是Singleton模式的一个很好的例子。一个国家只能有一个官方政府。不管组件政府的个人身份如何，“X的政府”这个称号是全球的一个访问点，他可以识别这个组织的负责人。 结构 Singleton声明静态的方法getInstance()，这个方法返回相同的Singleton类实例。 Singleton的构造方法对客户端代码应当不可见。getInstance()应该是唯一的可以创建并获得Singleton对象的途径。 伪代码在这个例子中，数据库连接类扮演Singleton角色。这个类没有公开的构造方法，所以只有调用getInstance方法可以获取这个对象。这个方法混存第一次创建的对象，在随后所有的调用中都返回它。 单例模式保证他的类只有一个实例被创建。并且，他提供了实例全局访问点：这个静态方法getInstance。 123456789101112131415161718192021222324252627282930class Database is private field instance: Database static method getInstance() is if (this.instance == null) then acquireThreadLock() and then // Ensure that instance has not yet been initialized by other // thread while this one has been waiting for the lock release. if (this.instance == null) then this.instance = new Database() return this.instance private constructor Database() is // Some initialization code, such as the actual connection to a // database server. // ... public method query(sql) is // All database queries of an app will go through this methods. // Therefore, you can place a throttling or caching logic here. // ...class Application is method main() is Database foo = Database.getInstance() foo.query("SELECT ...") // ... Database bar = Database.getInstance() bar.query("SELECT ...") // The variable `bar` will contain the same object as the variable `foo`. 适用性 当程序需要提供给所有客户端一个类的一个可以实例。比如，一个单独的数据库对象，在程序的不同模块贡献。 除了特别的的创建方法，Singleton对客户端隐藏了所有创建类的新对象的方法。这个方法创建一个新对象或者返回之前已经创建过的已经存在的对象。 当你需要严格控制全局变量。 不想全局变量，Singleton保证只有一个类实例。除了Singleton本身，没有任何类可以替换缓存的实例。 Sigleton让你可以轻松改变这个限制。比如，允许任何数量的实例，你只需要在一个地方修改代码–getInstance()方法体内。 如何实现 在类中添加一个静态字段用来持有单实例。 声明静态的公开创建方法，它将用来检索单实例。 在创建方法中实现“懒初始化”。它应该在第一次调用时创建一个新实例，并把它放到静态变量中。在随后的调用中这个方法都返回这个实例。 把类的构造方法声明为私有。 把客户端代码中所有直接对构造方法的调用替换为对创建方法的调用。 优点 保证类只有一个实例。 提供实例的全局访问点。 允许懒实例。 缺点 违背单一职责原则。 面具坏设计（Masks bad design？）。 在多线程的环境下需要特别处理。 在单元测试中要无尽mock。 和其他模式的关系 Facade可以改造成Singleton，因为大多情况下，一个门面对象就足够了。 在一些情况下Flyweight和Sigleton很像，Flyweight把什么事情都减少到一个享元对象。但是记住，它们之间有两个基本的不同： 1.Singleton对象时易变的。Flyweight对象时不变的。 单例类只有一个类实例，而享元类有多个不同状态的实例。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 小结Singleton在优缺点方面几乎和全局变量一样。尽管它们很好用，但却破坏了你代码的模块化。 在其他的上下文中，你可以使用一个依赖于Singleton的类。你将不得不携带Singleton类。大多数时候，在创建单元测试时会出现这个限制。 尽管许多开发着认为Singleton是反模式，但是在Java的核心类中也有许多例子： java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() Singleton可以通过一个返回相同缓存对象的静态创建方法来识别。 参考翻译整理自：https://refactoring.guru/design-patterns/singleton]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Prototype(Clone)]]></title>
      <url>%2F2017%2F11%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BPrototype%2F</url>
      <content type="text"><![CDATA[目的Prototype（也叫做Clone）是创建型模式的一种，允许你通过复制现有的对象来生成新的对象，而不会影响现有对象的内部。 问题你有一个对象并且想要创建一个副本。你该怎么做？首先，你需要创建同样class的一个新对象。然后，你必须遍历源对象的所有字段并把值拷贝到新对象中。 但是这么做有一个问题。不是所有对象都可以通过这种方式被拷贝。一些对象拥有无法从外部访问的私有字段。 这么做还有另外的问题。因为你必须知道对象类能够被遍历的所有字段，你的代码需要依赖你要拷贝对象的类。在你仅知道拷贝对象的接口时无法拷贝对象。 解决Prototype模式把克隆操作委托给对象自己。 他为所有需要克隆的对象声明通用的接口。他允许在不紧密耦合具体类的情况下克隆对象。通常，prototype接口只包含一个clone方法。 所有类对clone方法的实现都很像。这个方法创建一个当前类的对象，然后把他的字段值拷贝到新对象中。大多数编程语言都允许访问同一个类对象中的私有字段，所以这种拷贝过程比较直接。 可以被克隆的对象叫做prototype（原型）。有时，特别是当你的对象有很多字段并且一些字段可配置，原型可以作为子类的一种替代。在这种情况下，程序提前创建一些原型，然后克隆它们而不是从头开始重建对象。 真实世界的类比工业和细胞分裂在真实生活中，原型在产品量产之前用来做各种测试。然而，在这种情况下，原型并没有参与真正的生产，是一个被动的角色。 因为工业原型自己不会拷贝，对这个模式更相近的类比是有丝细胞分裂（生物学，还记得吗？）。在这种分裂后，两个完全一样的细胞就形成了。源细胞就是原型，在创建拷贝中是一个主动的角色。 结构基本实现 原型注册实现 Prototype声明克隆接口。大多情况下，只要一个clone方法就够了。 Concrete（具体的）Prototype来实现克隆方法。除了直接告杯字段值到新对象外，这个方法也可以解决一些应当对客户端隐藏的警告。比如，克隆引用对象，解开递归依赖等。 客户端使用Prototype接口来检索一个对象的克隆。 Prototype registry提供了对常用原型的简单访问，存储预先创建的一组对象，随时可以复制。通常，它可以用简单的（name-&gt;prototype）哈希映射实现。但是为了方便，任何其他搜索条件都可以添加到注册表中。 伪代码在这个例子中，原型被用来克隆代表几何形状的对象，而不耦合到它们的类。 所有的形状类都实现了只有克隆方法的通用克隆接口。子类先调用父类的克隆方法，然后把他们自己的字段拷贝到结果对象中。 因此，原型模式允许客户端代码克隆对象，即使不知道和独立于其特定的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Base prototype.abstract class Shape is field X: int field Y: int field color: string // A fresh object is initialized with values from the old object in // the constructor. method Shape(source: Shape) is if (source != null) then this.X = source.X this.Y = source.Y this.color = source.color // Clone operation always returns one of the Shape subclasses. abstract method clone(): Shape// Concrete prototype. Cloning method creates a new object and passes itself to// the constructor. Until constructor is finished, has a reference to a fresh// clone. Therefore, nobody has access to a partly built clone. This helps to// make the cloning result consistent.class Rectangle extends Shape is field width: int field height: int method Rectangle(source: Rectangle) is // Parent constructor call is mandatory in order to copy private fields // defined in parent class. super(source) if (source != null) then this.width = source.width this.height = source.height method clone(): Shape is return new Rectangle(this)class Circle extends Shape is field radius: int method Circle(source: Circle) is super(source) if (source != null) then this.radius = source.radius method clone(): Shape is return new Circle(this)// Somewhere in client code.class Application is field shapes: array of Shape method constructor() is Circle circle = new Circle() circle.X = 10 circle.Y = 20 circle.radius = 15 shapes.add(circle) Circle anotherCircle = circle.clone() shapes.add(anotherCircle) // anotherCircle is the exact copy of circle. Rectangle rectangle = new Rectangle() rectangle.width = 10 rectangle.height = 20 shapes.add(rectangle) method businessLogic() is // Prototype rocks because it allows producing a copy of an object // without knowing anything about its type. Array shapesCopy = new Array of Shapes. // For instance, we do not know exact types of elements in shapes array. // All we know is that all of them are Shapes. But thanks to the // polymorphism, when we call the `clone` method on a shape, the program // checks its real class and runs the appropriate clone method, defined // in that class. That is why we get proper clones instead of a set of // simple Shape objects. foreach shapes as shape do shapesCopy.add(shape.clone()) // The variable `shapesCopy` will contain exact copies of the `shape` // array's children. 适用性 当你的代码不应该依赖你要拷贝对象的具体类时。比如，对象的类是未知的，因为你通过接口和他们协作。 原型模式提供给客户端一个和所有原型协作的接口。这个接口对所有支持克隆的对象是通用的。这使得客户端对要克隆产品的具体类保持独立。 当你想要减少由不同方式配置相似对象（换句话说，每个类由唯一的字段值）组成的类层级结构的大小时。 原型模式允许创建一个原型对象集合，这些对象代表了一个对象所有可能的配置。 然后，客户端代码不是初始一个匹配一些配置的子类，而是寻找适当的原型并且克隆他。 如何实现 创建原型接口并在接口中声明clone方法。你可以简单的把这个方法添加到现有类层级中的所有类，如果你有类的话。 为所有原型类添加一个可选的构造方法，这个构造方法接收当前类的一个对象。这个构造函数必须从传递的对象中将类中定义的所有字段的值拷贝到当前实例。然后，它应该调用父类构造方法去拷贝父类中的字段。 如果你的编程语言不支持方法重载，你需要定义一个特别的方法来拷贝数据。构造方法仅仅是最便利的一个，因为他在new操作后就开始拷贝。 clone方法通常是有一行：运行一个使用原型构造方法的new操作符。注意，每个支持克隆的类必须明确重写clone方法，克隆方法要new一个他自己的类。否则，克隆将会生产出一个父类的对象。 此步骤可选。创建一个原型注册中心来存储常用的原型。甚至是相同类的对象，只是配置方式不同。 你可以在原型的基类中用工厂类或者工厂方法实现注册中心。这个工厂方法可以根据客户端代码传递的参数查找适当的原型。搜索条件可以仅仅是一个字符串标签或者复杂的搜索条件。在找到原型后，它应该克隆它并且把拷贝返回给客户端。 最后，我们应该把直接调用对象构造方法的clone方法改成调用原型注册中心的工厂方法。 优点 允许克隆对象而不耦合到具体的类。 减少重复的实例代码。 更快的创建复杂对象。 当你需要处理有许多可选配置的复杂对象时，可以把它当作替代子类的方案。 缺点 引用了许多其他对象的复杂对象很难被克隆。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Abstract Factory类通常使用工厂方法实现，但也可以使用Prototype实现。 当您需要将Command的副本保存到历史记录中时，Prototype可以提供帮助。 大量使用Composite和Decorator模式的设计通常也可以从Prototype中受益。他允许克隆复杂结构，而不是从头构建他们。 Prototype不需要子类，但是需要初始操作。Factory Method需要子类，但是不需要初始化这个步骤。 Prototype是更简单的Memento替代，如果您想要把对象的某种状态保存在历史中，相当简单，没有外部资源的链接，或者链接很容易重新建立（Memento还不了解，此处很模糊）。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 总结Prototype是创建型模式的一种，允许你克隆对象，即使被克隆对象很复杂，它不需要耦合特定的被拷贝对象的类。 用例： java.lang.Object#clone() (class 应当实现java.lang.Cloneable 接口) 鉴定：通过clone()或者copy()等方法轻松识别原型模式。 参考整理翻译自：https://refactoring.guru/design-patterns/prototype]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Builder]]></title>
      <url>%2F2017%2F11%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%2F</url>
      <content type="text"><![CDATA[意图Builder是创建模式的一种，让你可以使用相同的构建过程生成不同类型和对象的表示形式。BUilder允许一步一步构建复杂对象。 问题假设有一个复杂对象需要一步一步的初始化许多字段和嵌套对象。这些代码通常放在一个有很多参数的构造方法中，或者更糟糕，分散在客户端代码中。 比如，让我们考虑下如何创建一个House对象。创建一个简单的房子，你需要盖四面墙，安装一个门和两个窗户，构建房顶。但是，如果你想要一个更大，更亮堂，并且有后院和其他好吃的东西的房子呢？想到的最简单的解决方式是从Hose类扩展，通过创建子类来覆盖所有参数的组合。这种处理方式明显会导致创建许多子类。任何新的参数，比如阳台风格，都需要扩张这个层级甚至扩张很多。 这些参数大多时候是无用的，导致构造方法看起来很丑陋。比如，很多房子没有游泳池。因此，和游泳池相关的所有参数99%情况下都是无用的。 解决Builder模式建议抽离出类自身的构造代码到不同的对象中，这种对象叫做builder。 模式把对象的构造组织称一系列步骤（比如：buildWalls，BuildDoor等）。创建这个对象，你需要调用一个构造类中的几个构造步骤。最重要的一点是你不需要调用所有的步骤。你只能使用生成对象的特定配置所需的步骤。 通常，对于你正在尝试构建的各种产品，相同的构建步骤将会有所不同（一样步骤，但是每个步骤完成的方式不同）。比如，一个机舱可以用木日志建造，但是一座城堡必须用石头。 在这种情况下，你可以在不同的方式下，创建几个不同的实现了相同构建步骤的builder类。然后，你就可以使用这些builder在相同的构建处理中生产不同类型的对象。 比如，有一个StoneBuilder类来处理所有和石头相关的事情，一个WoodBuilder类来处理木头的。你可以使用它们中的一个通过一系列构造步骤来生产一个石头或者木头房子。这种方式仅在客户端代码通过通用接口来和builder交互时可用。 你可以进一步抽离出整个构建过程到一个特别的类：Director。在这种情况下，Director（Director关联了一个Builder对象）可以定义构建步骤的顺序并执行他们。这种结构下将会向客户端隐藏所有构建细节。 结构 Builder声明构建一个产品需要的步骤。 Concrete Builder提供构造步骤的不同实现。Builder也可以提供获取构造结果的方法。这个方法不需要声明在builder接口中，因为builder可能生产没有遵循通用接口的产品。但是如果你处理的产品是单一层次的，你可以安全的把这个方法描述在基本接口中。 Product是创建结果的一个对象。Builder可以生产不属于同一个类层级或者接口的产品。这是Builder和其他创建模式的不同之处。 Director使用Builder对象构建产品。通常，客户端通过构造方法参数传给director一个builder实例。Director使用这个单一的builder对象完成所有的进一步构建。但是也有替代的方式，把builder传递给director的主要生产方法。 注意，Builder不需要创建一了director类。当你有几个需要不同构建流程的产品变种时，用不同的director类是很方便的。Director把代码都封装在一个单独的类中。 伪代码这个例子展示了Builder是如何一步一步的构造出汽车。Director类使用不同的构建步骤生产不同类型的汽车。Director使用给他们的build对象工作。这种方式允许你重用已经存在的代码来生产不同种类汽车的用户手册。为了达到这个目的，你只需要一个新的builder类。 因此，Builder模式允许你只通过简单的改变构造步骤的数量和顺序就可以创建产品的不同变种。另外，通过提交构建器对象的替代版本，您可以使用相同的构造代码生成完全不同类型的产品。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// Builder can create different products using the same building process.class Car is Can have GPS, trip computer and various numbers of seats. Can be a city car, a sports car, or a cabriolet.class Manual is Textual representation of a car.// Builder interface defines all possible ways to configure a product.interface Builder is method reset() method setSeats(number) method setEngine(engine: Engine) method setTripComputer() method setGPS()// Concrete builders implement that interface differently.class CarBuilder implements Builder is private field car:Car method reset() Put a new Car instance into the "car" field. method setSeats(number) is Set the number of seats in car. method setEngine(engine: Engine) is Install a given engine. method setTripComputer() is Install a trip computer. method setGPS() is Install a global positioning system. method getResult(): Car is Return the current car object.// Unlike other creational patterns, Builder can construct unrelated products,// which don't have the common interface.class CarManualBuilder implements Builder is private field manual:Manual method reset() Put a new Manual instance into the "manual" field. method setSeats(number) is Document car seats features. method setEngine(engine: Engine) is Add an engine instruction. method setTripComputer() is Add a trip computer instruction. method setGPS() is Add GPS instruction. method getResult(): Manual is Return the current manual object.// Director defines the order of building steps. It works with a builder object// through common Builder interface. Therefore it may not know what product is// being built.class Director is method constructSportsCar(builder: Builder) is builder.reset(); builder.setSeats(2); builder.setEngine(new SportEngine()); builder.setTripComputer(); builder.setGPS();// Director gets the concrete builder object from the client (application code).// That's because application knows better which builder to use to get a// specific product.class Application is method makeCar is director = new Director(); CarBuilder builder = new CarBuilder(); director.constructSportsCar(builder); Car car = builder.getResult(); CarManualBuilder builder = new CarManualBuilder(); director.constructSportsCar(builder); // The final product is often retrieved from a builder object, since // Director is not aware and not dependent on concrete builders // and products. Manual manual = builder.getResult(); 适用性 当你有一个“伸缩”的构造方法。 调用一个有许多可选参数的构造方法很不方便。你必须指定所有的参数，即使你不需要。 解决这个痛点，可以重载一个长的构造方法，创建几个参数较少的构造方法。它们仍然调用主构造方法，只是把省略的参数传入了默认值。 Builder模式允许一步一步构建对象。在构建一个简单对象时，你可以只使用必要的步骤，跳过可选步骤。 当你的代码必须要创建一个产品的不同表示时（比如，石头和木头房子）。产品的构造步骤一样，但细节不同。另外，尽管这个产品是相似的，它们没有必要必须遵循一个通用基类或者接口。 Builder可以用相同的过程构建不同的产品。 不同的产品被不同的builder类表示。控制构建顺序的代码应该放在一个单独的director类中。 当你必须构建一个Composite树或者其他复杂对象时。 Builder一步一步的构建产品。他循序延时甚至递归构建，这在使用树结构时很有用。Builder在运行构建步骤时不能导出位完成的产品。这样可以阻止客户端代码拿到损坏的结果。 如何实现 确保你有构建产品的共同步骤和导致创建各种产品代表的步骤的变化（？）。 创建Builder接口并声明生产步骤。 为每一个产品表示创建Concrete Builder类。并实现它们的创建步骤。 考虑创建一个Director类。他的方法用相同的builder实例，不同的步骤来创建不同的产品配置。 客户端代码创建Builder和Director对象。它首先床架你个builder实例，然后把它传给director的构造方法或者他的生产方法。 客户端应该调用Director对象的生产方法开始构建过程。 是有在所有产品遵循一个通用接口时可以从Director对象中获取构建结果。相反，每个Builder必须有他自己检索结果的方法。 优点 允许一步一步构建产品。 允许使用相同的代码构建不同产品。 把产品的核心业务逻辑与复杂的构建代码隔离。 缺点 创建多个额外类增加了代码的复杂度。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Builder关注点在一步一步的构造出一个复杂对象。Abstract Factory创建产品对象的系列（不管是简单的还是复杂的）。Builder在最后一步返回产品，但是Abstrct Factory立刻返回结果。 Builder可以一步一步的构建一个复杂的Composite树。 Builder可已才有Bridge结构模式：Director当作接口，Builder当作实现。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 总结Builder是创建型模式的一种，允许你一步一步构造出来复杂的对象。 不想其他的创建型模式，Builder不需要产品遵循一个通用的接口。他可以使用相同的构造过程生成不同的产品。 用例：Builder模式在你需要创建一个有很多可选配置的对象相当有用。 Builder在Java核心库中也有广泛应用： java.lang.StringBuilder#append() (unsynchronized) java.lang.StringBuffer#append() (synchronized) java.nio.ByteBuffer#put() (also in CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer and DoubleBuffer) 所有java.lang.Appendable接口的实现 鉴定：Builder模式可以在类中识别，它有一个创建方法和几个方法来配置结果对象。Builder方法通常是支持链式调用（比如，someBuilder-&gt;setValueA(1)-&gt;setValueB(2)-&gt;create()）。 参考翻译整理自：https://refactoring.guru/design-patterns/builder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Abstract Factory]]></title>
      <url>%2F2017%2F11%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BAbstractFactory%2F</url>
      <content type="text"><![CDATA[目的Abstract Factory是创建模式的一种，让你在没有指定具体类的情况下生产相关对象的系列。 问题假设你在写一个家具店的模拟器。你的代码由以下构成： 相关产品的系列，像：Chair + Sofa + CoffeeTable。 系列的几个变种。比如，产品Chair + Sofa + Coffee + CoffeeTable可以有这些变种：IKEA，VictorianStyle,ArtDeco。 你需要有种方式创建个性化的家具对象，以便它们能够匹配相同系列中的其他对象。在没有匹配到家具时，客户会感到失望。 另外，你不想在添加新产品或者产品系列时改变已经存在的代码。家具供应商常常会更新他们的目录，并且你不想每次在供货商改目录时修改你的核心代码。 解决第一，Abstract Factory模式建议遍历所有不同的产品并且强制这些变种遵循通用的接口。比如，所有的椅子变种必须遵循Chair接口；所有的咖啡桌必须遵循CoffeeTable接口。 第二步，创建AbstractFactory，一个基础接口，声明了创建产品系列的所有产品的方法（比如：createChair，createSofa和createCoffeeTable）。这步最重要的一件事就是让这些方法返回代表抽象产品类型的接口：Chair，Sofa，CoffeeTable。 第三步，实现具体的工厂。工厂是返回某种特定产品的类。比如，IKEAFactory，将只会返回IKEAChair，IKEASofa和IKEACoffeeTable对象。所有的工厂在创建同一个变种的产品时必须遵循AbstractFactory接口。 客户端代码只能通过抽象接口同工厂和产品协作。这样你就可以通过传递不同的工厂对象修改要用的产品类型。 所以，当客户端像工厂请求创建一把椅子时，它不必关心工厂的具体类。也不必关心它将得到椅子的具体类。不管它将得到一把时尚的IKEA模型还是一把Victorian风格的椅子，它都用使用抽象的Chair接口和椅子协作。客户端代码只需要知道椅子实现了在接口中声明的sit方法。它还知道不管返回哪种椅子，它的类型是和沙发还有咖啡桌匹配的，因为它们是同一个工厂创建的。 好了，但是谁创建实际的工厂对象呢？通常，程序在初始化阶段创建一个具体的工厂，并且工厂的类型依赖配置或者环境。 结构 Abstract products为创建产品系列的所有不同产品声明接口。通常，有几个不同的产品接口。 Concrete products实现不同Abstract product接口。实现相同接口的具体产品集合代表一个系列的不同变种。 Abstract factory声明了创建系列中所有产品的接口。 Concrete factory实现了abstract factory的创建方法。每个具体工厂代表一个系列产品的特定变种。 虽然具体的工厂实例化具体的产品，但是创建方法的签名必须声明为相应抽象产品类型。通过这种歌方式，客户端代码在使用工厂时就不会和具体的产品变种耦合。它就能通过使用抽象接口和任何工厂/产品协作。 伪代码这个例子用来说明Abstract Factory模式可一用来创建跨平台的UI而不需要客户端代码和具体UI类耦合。 客户端代码从工厂中请求各个UI元素。返回元素的具体类型取决于客户端代码传递的工厂类型。客户端代码通过抽象接口和元素协作。只要它使用相同的工厂对象，它所有的产品都是兼容的。 Abstract Factory模式使得客户端代码和具体UI元素类独立。另外，当添加一个新的UI变种时，你不需要修改已经存在的代码（比如，实现Linux的UI元素）。你只需要创建一个工厂的新子类，让他返回新类型的UI元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// This pattern assumes that you have several families of products, structured// into separate class hierarchies (Button/Checkbox). All products of the same// family have the common interface.interface Button is method paint()// All products families have the same varieties (macOS/Windows).class WinButton implementing Button is method paint() is Render a button in a Windows styleclass MacButton implementing Button is method paint() is Render a button in a Mac OS X styleinterface Checkbox is method paint()class WinCheckbox implementing Checkbox is method paint() is Render a checkbox in a Windows styleclass MacCheckbox implementing Checkbox is method paint() is Render a checkbox in a Mac OS X style// Abstract factory knows about all (abstract) product types.interface GUIFactory is method createButton():Button method createCheckbox():Checkbox// Each concrete factory extends basic factory and responsible for creating// products of a single variety.class WinFactory implementing GUIFactory is method createButton():Button is return new WinButton method createCheckbox():Checkbox is return new WinCheckbox// Although concrete factories create the concrete products, they still return// them with the abstract type. This fact makes factories interchangeable.class MacFactory implementing GUIFactory is method createButton():Button is return new MacButton method createCheckbox():Checkbox is return new MacCheckbox// Factory users don't care which concrete factory they use since they work with// factories and products through abstract interfaces.class Application is private field button: Button; constructor Application(factory: GUIFactory) is this.factory = factory method createUI(); this.button = factory.createButton() method paint(); button.paint()// Application picks the factory type and creates it in run time (usually at// initialization stage), depending on the configuration or// environment variables.class ApplicationConfigurator is method main() is Read the configuration file If the OS specified in the configuration file is Windows, then Construct a WinFactory Construct an Application with WinFactory else Construct an MacFactory Construct an Application with MacFactory 适用性 当业务逻辑必须要和同一个产品系列的不同变种协作，并且你不想依赖具体产品类时（或者它们无法预先知道）。 Abstract Factory对客户端代码隐藏了创建产品类的信息。客户端代码可以和任何工厂创建出来的任何产品协作，只要客户端通过抽象接口和它们交互。 当一个类拥有多个Factory Method使得它的主要责任不明确时。 每个类专注做一件事是很好的程序设计。当一个类需要处理多个产品类型，它就应该使用一个独立的抽象工厂来替代多个工厂方法。 如何实现 画出不同产品和相同产品不同变种的矩阵。 为所有不同产品类型创建抽象接口并且让所有具体产品遵循这些接口。 声明抽象工厂接口。这个接口应该列出所有不同类型产品的创建方法。 为产品系列的每个变种实现不同的工厂类。 创建一个空场的初始化代码写在客户端中。客户端依赖配置或者当前环境中来决定需要的工厂的类型并创建出来。 在客户端代码中，把所有调用产品构造方法的地方替换成调用工厂的创建方法。 优点 符合开闭原则。 允许构建系列产品对象并担保兼容性。 避免具体产品和使用它们的代码的耦合。 在多个类间隔离责任。 缺点 创建多个额外类，增加代码整体复杂度。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Builder关注点在一步一步的构造出一个复杂对象。Abstract Factory创建产品对象的系列（不管是简单的还是复杂的）。Builder在最后一步返回产品，但是Abstrct Factory立刻返回结果。 Abstract Factory类通常用Factory Method来实现，单丝它们也可以用Prototype来实现。 Abstract Factory可以用来代替Facade隐藏特定平台的类。 Abstract Factory可以和Bridge模式单独使用。当Bridge的“接口”部分只能与特定的“实现”一起工作时非常有用。这种情况下，工厂能够封装这些关系并且对客户端隐藏复杂性。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 小结Abstract Factory是创建型模式的一种，用来解决创建没有制定具体类的产品系列。 Abstract Factory定义了一个创建所有不同产品的接口，但是把创建真正产品的实现放在具体工厂类中。美国工厂类型都代表一个某些产品的变种。 客户端代码不是直接调用构造方法（new操作）而是调用一个工厂对象的创建方法来创建对象。因为一个工厂代表了一个产品的变种，它的产品都是兼容的。 客户端只通过抽象接口和工厂还有产品协作。它允许相同的客户端代码和不同的产品协作。你只需要创建一新的具体工厂类，并把它传递给客户端代码就行。如果你分不清楚Factories，Factory Method和Abstract Factory，可以阅读工厂比较指南（待译）。 Java的模式的使用用例：许多框架和类库采用抽象工厂模式来提供扩展和定制它们的标准组件。 Java的核心包中应用如下： javax.xml.parsers.DocumentBuilderFactory#newInstance() javax.xml.transform.TransformerFactory#newInstance() javax.xml.xpath.XPathFactory#newInstance() 鉴定：该模式很容易通过返回工厂对象的方法来识别。然后，工厂用于创建特定的子组件。 参考翻译整理自：https://refactoring.guru/design-patterns/abstract-factory]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Factory Method]]></title>
      <url>%2F2017%2F11%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BFactoryMethod%2F</url>
      <content type="text"><![CDATA[目的Factory Method是创建模式的一种，他在父类中提供一个用来创建对象的接口，但是允许子类修改创建对象的类型。 问题假设你有一个后勤管理应用。应用的第一个版本只需要处理卡车这种运输方式，所以，你有一个Truck类。 不久，你的应用很受欢迎，你收到了许多需求，包括水运。 好消息，不是吗？但是你的代码怎么样呢？看起来，你的代码有许多地方要和Truck类耦合。添加Ship类需要改变整个代码库。此外，如果你决定添加另外一个类型的配送方式，你可能需要再次修改整个代码库。 解决Factory Method模式建议通过调用一个特别的“工厂”方法来代替直接创建对象（使用new操作）。构造方法应该移到那个方法中调用。工厂方法返回的对象被称为“产品”。 乍一看，这么做似乎没有意义。但是，现在你可以在字类中重写工厂方法，并且改变要创建对象的类。我们来看它是怎么工作的： 当然，这种方式有个限制：所有的产品必须遵循一个通用接口（Transport）。基类中的工厂方法需要返回这个通用接口。 字类返回不同的具体产品，它们都有一样的基类或者接口（比如：Truck和Ship都实现了Transport接口）。 工厂方法的客户端不需要关心它得到产品的类型。它们通过产品接口和所有产品协作。 结构 Product为creator和他的字类能够生产的对象定义接口。 Concrete Product是Product的不同实现。Concrete Creator将会创建并返回这饿类的实例。 Creator声明了一个返回Product类型的工厂方法。在第一个例子中，所有的Concrete Creator必须实现它们的工厂方法。 尽管这个名字在现实世界中，生产产品并不是Concrete Creator的主要责任。通常，他有一些处理产品的核心逻辑。 打个比方：大的软件开发公司有对开发者进行培训的部门。但是公司的主要功能还是写代码。 Concrete Creator实现或者重写基本的工厂方法，创建并返回一个Concrete Product。 注意：工厂方法并不总是创建一个新实例。它也可以从缓存中返回一个已经存在的对象。 伪代码这个例子用来展示工厂方法可以被用来创建跨平台的UI元素。工厂放被声明在对话框UI的基类中。它返回抽象的按钮。对话框的积累重写工厂方法并返回特定的按钮。 结果是使用基本对话框的代码组合了一个UI窗口。对话框通过通用接口和那妞协作。所以，不管工厂方法返回什么类型的按钮，对话框保留基本的功能。 因此，Factory Method使得类的主要代码独立于所使用的具体产品类。Factory Method让字类担负起选择生产产品所需要的具体类的责任。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// The Factory Method pattern is applicable only when there is a// products hierarchy.interface Button is method render() method onClick(f)class WindowsButton implements Button is method render(a, b) is Create and render a Windows looking button. method onClick(f) is Bind a native OS click event.class HTMLButton implements Button is method render(a, b) is Return an HTML representation of a button. method onClick(f) is Bind a web browser click event.// Base factory class. Note that the "factory" is merely a role for the class.// It should have some core business logic which needs different products to// be created.class Dialog is method renderWindow() is Render other window controls. Button okButton = createButton(); okButton.onClick(closeDialog); okButton.render(); // Therefore we extract all product creation code to a special // factory method. abstract method createButton()// Concrete factories extend that method to produce different kinds of products.class WindowsDialog extends Dialog is method createButton() is return new WindowsButton()class WebDialog extends Dialog is method createButton() is return new HTMLButton()class ClientApplication is field dialog: Dialog // Application picks a factory type depending on configuration // or environment. method configure() is if (we are in windows environment) then dialog = new WindowsDialog() if (we are in web environment) then dialog = new WebDialog() // The client code should work with factories and products through their // abstract interfaces. This way it will remain functional even if you add // new product types to the program. method main() is dialog.initialize() dialog.render() 适用性 当你的代码需要和不知道具体类型及一来对象协作时。 比如，从多数据源读写数据：文件系统，数据库或者网络。这些资源有着不同的类型，依赖和初始化代码。 工厂方法对其他代码隐藏了产品的实现细节。支持一个新的产品类型，你只需要创建一个新的字类并且重写工厂方法。 当你想要让用户扩展你的类库或者框架的内部组件时。 用户可以轻松的创建特定组件的字类。但是如何让框架识别这个字类并且替换标准的组件？用户必须重写每一个创建标准组件的方法，把它们改成创建自定义子类的对象。这样相当尴尬，不是吗？ 最好的方法不仅仅是给用户提供扩展某个类，而是将生成组件的代码减少到单个创建方法中。换句话说，提供出一个工厂方法。 让我们看看它如何工作。假设你在用一个开源的UI框架写app，你的app必须使用圆边按钮，但是框架只提供了一个方形的。 你做的第一件事就是实现一个RoundButton类。但是现在你需要告诉UIFramework类用一个新的按钮类代替默认的那个。 为了实现这个，你创建了基础框架的一个子类UIWithRoundButtons，并且重写了createButton方法。这个方法会返回一个Button对象，除了你创建的新子类RoundButton对象。现在，在你的app中，你必须使用UIWithRoundButtons类替代UIFramework来初始化框架。 当你想要保存系统资源并且重用存在的对象，而不是重新建立一个时。 比如，当你需要处理像数据库连接这类大的或者资源紧张对象。 想象下要重用存在的对象需要做什么： 首先，你需要创建一个池子来保存存在的对象。 当有人请求一个对象时，你需要在池子中找到一个闲置的对象。 然后把它返回给客户端代码。 仅仅在池子中没有闲置对象时，你才需要创建一个新的（并且把它放到池子中）。 这些代码必须放在某个地方。最便利的地方是构造方法。这样子就可以在请求创建对象时去做那些检查。但是，从定义上讲构造方法必须返回新对象，所以它们不能返回存在的实例。 另外，那些使用你对象的客户端代码也不能包含它。否则，客户端就知道太多你的类中的实现细节。因此，你需要一个独立的方法封装这个逻辑。那就是工厂方法。 如何实现 为所有产品抽离出通用的接口。这个接口应该声明对每个产品都有意义的方法。 在创建类中添加一个空的工厂方法。他的签名应当返回产品的接口类型。 查看创建者的代码并且找到所有用到产品构造方法的引用。将它们逐一替换为对工厂方法的调用，并将产品创建代码提取到工厂方法。 你可能需要为工厂方法添加临时变量来控制要创建的产品。此时，工厂方法的代码看起来很挫。 它有一个巨大的switch操作来获取要实例化产品的类。不过不用担心，我们马上修复他。 现在，在子类中重写工厂方法，并且把父类中对应的case语句挪到子类中。 基础创建类中的控制参数也可以用在子类中。 比如，你可能有一个Mail作为基类的层级结构，里面有Air和Ground，还有产品类：Plane，Truck和Train。Air正好和Plane匹配，但是Ground可以同时和Truck还有Train匹配。你可以创建一个新的子类来处理这两种情况，但是还有一种处理方式。客户端代码向Ground的工厂方法传递一个参数来控制它想要的产品。 如果基本工厂方法在移动后变成空的了，你可以把它标志成抽象方法。 优点 遵循开闭原则。 避免产品和使用它们代码的耦合。 把创建代码都移动到一个地方，简化了代码。 简化添加新产品的编程。 缺点 需要额外的子类。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Abstract Factory类通常使用工厂方法实现，但也可以使用Prototype实现。 Factory Method可以和Iterator单独使用，让集合子类返回正确的迭代器。 Prototype不需要子类，但是需要一个“初始”操作。Factory Method需要子类，但是不需要初始化这个步骤。 Factory Method是一个专业化的Template Method。另一方面，Factory Method常常作为一个大Template Method的一个步骤。 小结工厂方法是一个用来解决创建产品对象时没有指定具体类的问题的设计模式。 工厂方法定义了一个方法，用来替代直接调用构造方法（new操作）。子类可以重写这个方法来改变要创建对象的类。 If you can’t figure out the difference between Factories, Factory Method &amp; Abstract Factory patterns, then read our Factory Comparison guide.如果你分不清楚Factories，Factory Method和Abstract Factory，可以阅读工厂比较指南（待译）。 在Java中的使用 用例 java.util.Calendar#getInstance() java.util.ResourceBundle#getBundle() java.text.NumberFormat#getInstance() java.nio.charset.Charset#forName() java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (Returns different singleton objects, depending on a protocol) java.util.EnumSet#of() javax.xml.bind.JAXBContext#createMarshaller() and other similar methods. 鉴定 工厂方法可以通过创建方法来识别，这些方法从具体类创建对象，但将它们作为抽象类型或接口的对象返回。 参考翻译整理自： https://refactoring.guru/design-patterns/factory-method]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-结构模式之小结]]></title>
      <url>%2F2017%2F11%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[目的结构设计模式使的我们简单快速的建立类的层级及不同类之间的关系，明确不同层级间的责任和边界，让各个模块、系统间相互独立并很好的协作。 概览Adapter模式适配器的目的是使不兼容接口间的可正常进行协作，它允许我们新增接口。主要用来解决下面两个问题： 接口间输入输出不匹配的问题，适配器在无法相互直接使用的接口间加入中间转换层，对数据格式进行转换，使接口间可以顺利协作。 当你需要复用几个已经存在的类，但是它们缺少一些常用的功能。并且你无法在父类中添加这些功能，因为他是闭源或者被其他代码使用的。可以把这些缺少的功能放到新建的适配器中。 比如像OutputStreamWriter，它在构造方法中接收一个OutputStream作为内部变量。OutputStream并没有提供对String或者char类型的支持，于是OutputStreamWriter就出现了，OutputStreamWriter的基类定义了该接口要实现的功能，然后适配传入的字符串，但是最终还是把输出工作交给了OutputStream。 Adapter反对完全重新定义一个接口，原文没有对完全重新定义接口作出解释，但是它改变了原有接口，不过也不必太过于纠结于此。只要我们根据设计模式提供的思维方式把问题很好的解决就好。 Facade模式门面让你为一个复杂的系统，类库或者框架提供一个简单的接口。可用在以下场景： 需要一个简单但是功能有限的复杂子系统接口时 把一个子系统构建成层级结构 上面两个场景在实际场景中很多，比如我们要使用第三方的类库，但是它并没有提供我们想要的接口，于是我们自己创建一个类来对它进行包装，并在这个类中管理三方库中一些对象的生命周期。 Decorator模式装饰器让你在封装包涵对象原有行为的基础上增加新的行为。可用在以下场景： 动态赋予某个对象行为并且不需要修改这个对象的代码 不可能或者不合适通过继承来扩展对象的行为 装饰器是对已有接口的增强，它没有改变原有的接口，对使用者完全透明。比如我们会用Collections的synchronizedMap(Map m)来让一个HashMap变成线程安全的，但经过增强的HashMap我们使用起来和之前并无不同。Decorator也被称为Wrapper，它们支持递归组合，我们可以根据需要叠加或者移除。它和Composite模式十分相似，但是从模式定义上讲，Composite并不会对接口做增强，只是对下级执行相同的操作并合并结果。 Proxy模式代理模式为另外一个对象提供一个替身或者占位符来控制对它的访问。作用如下： 懒初始化（虚拟代理）。当你有一个需要从文件系统，网络或者数据库加载数据的重量级对象时。 访问控制（保护代理）。当一个程序有不同类型的用户并且你想阻止未授权用户对保护对象的访问。 本地执行一个远程服务（远程代理）。当一个真实服务对象在远程服务器上时。 缓存对象（智能引用）。当你需要混存客户端的请求并且管理它们的生命周期时（当结果比较重时）时。 请求日志（日志代理）。当你需要保留一个服务对象的请求历史。 代理还分为静态和动态两种，动态代理常用在框架层面。上面列出的几个适用场景在Dubbo中有很好的体现，Dubbo代理了远程的服务，并对其做了缓存和访问控制等相关指标数据。了解Proxy模式去看下Dubbo源码是个不错的选择。 还是要从主要目的或者说意图上区分模式，Proxy并不像Decorator那样对接口做增强，也不像Adapter定义新的接口，但并不是Proxy做不了这些事情，它可以很轻松的对接口做增强，但那不是他的主要目的。PS：Proxy往往需要管理被代理对象的生命周期。 Composite模式Composite模式让我们可以像树一样组合对象，并且允许客户端像操作单个对象一样和这些结构协作。使用该模式前一定要正确梳理清楚现有实体间抽象关系。 当有以下场景时，考量使用该模式： 需要实现一个像树一样有着简单元素和容器的结构。 客户端要统一处理简单和复杂的元素时。 之前接触一个店铺装修系统，用户使用定义好的基本组件组合出不同的网页效果。像系统中的输入框、图片、按钮等是基本的组件（像树的叶子），用户可以使用基本组件组成更复杂的组件放到自定义组件中（像一个树枝），自定义组件和基本组件遵循相同的接口，有着相同的属性和操作。这样，渲染引擎在渲染在将一个画面渲染的时候只需要关注当前画面用了那些组件，不必关心组件式什么类型的，只需要通过接口设置/获取自己需要的属性值即可。 组合模式和装饰模式很像，都依赖递归组合，但不同的是，装饰器用来增强接口而组合模式只是对接口结果做了合并。不必纠结于如此一点差别。就像黑猫VS白猫，捉到老鼠就是好猫。 Bridge模式桥接模式分离一个巨大的类或者将一组关系相近的类分离成为两个独立的层次结构，抽象和实现，让各自可以独立开发。 这个模式提示我们，接口和实现必须分开。不过，现在企业级项目好像没有不这样做的。使用场景如下： 有一个包含一些功能变种的大类（工作在几个不同的数据库服务上） 需要在正交（独立）的维度扩展一个类（例子详见Bridge模式） 需要在运行时改变实现（一个接口多种实现，比如：临时切换系统的支付通道） Flyweight模式享元来自于拳击界，表示轻量级选手（选手小于111磅）。这个舶来词形象表明这个模式的意图。通过在多个对象见共享对象状态的通用部分而不是让各个对象独自持有的方式来节约内存。我们在系统中常会定义一些常量供不通的对象使用，这也体现了享元模式的思想。在Java的核心类库中，像Integer、Boolean、Long和BigDecimal等都缓存了常用的（最大/小／0等）数值。 小结翻译的文章对模式的解释比较浅显简单，可以让我们对模式有一个初步的认知，想要更深入理解和体会设计模式一方面离不开平时做项目时对业务和代码关于模式思考，尝试在编码时采用一些合适的模式，将理论运用到实践中，直观上体验模式带来的好处和问题；另一方面还是要深入读下《设计模式》这本书，来加深对模式的理解。个人认为模式的具体实现结构不必拘泥文中说的某种实现形式，它更重要的是要解决什么问题，以及我们可能会碰到什么问题，和优雅解决或者避免这些问题的方法。具体怎样去应用一个模式在单一介绍模式的文章中都有给出。 本次小结的这几种设计模式属设计模式中的结构部分，它告诉我们怎样比较合理的抽象数据结构间的层次和关系，也讲明了采用给出解决方法的会带来的一些问题。当然，一些场景的处理可能会有几种模式都可以适用，这时候就需要根据自己的主要意图、复杂性等方面来考量了，毕竟，复杂的代码让人讨厌。 TODO 目前对结构模式还是入门理解，会在看完《设计模式》中对结构模式的讲解后再来更新自己的这篇博文（2017年11月3日）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-结构模式之Flyweight]]></title>
      <url>%2F2017%2F10%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BFlyweight%2F</url>
      <content type="text"><![CDATA[目的Flyweight是结构模式的一种，通过在多个对象见共享对象状态的通用部分而不是让各个对象独自持有的方式来让你在可用的RAM中装入更多的对象。 问题在长时间工作后想要找些乐趣，你决定写一个简单的视频游戏。玩家能够在地图上移动并且可以相互射击。你决定实现一个真实的粒子系统并让它称为这个游戏的特性。子弹，导弹和爆炸产生的碎片应该到处飞舞并且能够给玩家分配经验。 过了一会，你最后一次提交代码并且把游戏发给了你的朋友，希望他能够立马玩起来。尽管游戏在你电脑上完美运行，但是你的朋友却不能玩起来。这个游戏总是在他的电脑上运行一会儿就崩溃。 在你看了日之后，发现是因为RAM不足导致了游戏崩溃。这个看起来和你的粒子系统有关。 每一个例子由一个包含和丰富数据的对象表示。在某一刻，当团战达到高潮，可用的RAM无法装入新创建的粒子，此时程序就崩溃了。 解决仔细检查Particle类，你会发现color和sprite数据是对象中最耗内存的字段。更糟糕的是，这些字段存储的是所有粒子都相同的数据。比如，所有的子弹都是相同的颜色和质地。 粒子的其他数据，像坐标，移动向量和速度是所有粒子唯一的。另外，这些字段的数据是实时变化的。对color和sprite这类保留常量而言，它们看起来就像粒子的可变上下文。 这些context-specific对象的变量数据通常被叫做“外在状态”，因为他们早对象外部变化。对象余下的状态，就是这些不可变的数据，被叫做“内在状态”。 Flyweight模式建议你不要再对象内部存储外部状态，而是通过调用方法时当作参数传递进来。通过这种方式你就可以把不可变状态留在对象内，这样你就可以在不同的上下文环境中重用它。更重要的，你将会需要很少这种对象，因为仅仅出现在固有状态不同时，而这种状态并不多。 就我们的游戏而言，只需要三个粒子对象就能满足（子弹，导弹和碎片）。现在你应该猜到了，这种分离对象的方式就叫做“flyweight”（享元，这个术语来自拳击，表示选手小于111磅）。 外部状态存储但是我们在那里做外部状态的移动？用一些类来持有他，对吗？大多情况下，把这些数据移动到容器中是很便利的，该容器用于在应用模式之前聚合对象。 在我们的例子中，它是主要游戏对象。你可以创建额外的数组字段来存储坐标，向量和速度。另外，你也需要其他的数组来存储表示一个粒子的指定享元对象的引用。 等一下！难道我们不需要在一开始就需要有相同数量的上下问对象？从技术上讲，需要。但事实是，这些对象要比之前小太多了。最耗内存的字段现在仅存活在几个享元对象中。上千个上下文对象可以连接并且重用单个享元对象，而不是复制状态到内部各自存储。 不可变性因为相同的享元对象可以被用在不同的上下文中，你必须确保它们的状态不能被改变。享元应该智能通过构造参数来接收内部状态。它们不应该暴露set方法或者称为公开字段。 享元工厂你可以创建一个工厂方法来管理已经存在享元对象的池子。这个方法接收客户端期望的内部状态，并能够在已经存在的享元对象中匹配这个状态，如果找到就返回它。如果没有找到，它将创建一个新享元并且把它加入池子。 有几个地方可以放置该方法。通常的做法是放在享元容器中。另外，一个新工厂类应该被创建。你甚至可以把工厂方法做成静态的，并将其放在主要的Flyweight类中。 结构【structure.png】 不要忘记，Flyweight模式是一种优化，只有在使用大量相似对象的程序中才有意义。模式把对象的状态分成两个部分：享元和上下文。 Flyweight保存能够在多个对象之间共享的原始对象状态的一部分。相同的享元对象可以被用在许多不同的上下文中。被保存在享元中的状态叫做“内部状态”。原始对象状态的另一部分通过参数传递给flyweight的称为“外在状态”。 Context包含外部状态，就是对所有原对象都唯一的那些。当一个上下文和一个享元对象结合起来，它就表示来一个原对象的所有状态。 大多情况下，原对象的行为保留在Flyweight类中。在这种情况下，不管是谁调用一个享元方法，必须把外部状态通过方法参数传递进来。另一方面，这个行为也可以放在Context类中，把连接的享元仅当作数据对象。 Client计算或者存储享元的外部状态。从一个客户端角度看，一个享元就是一个模版，可以在运行时通过调用带有上下文数据参数的方法进行配置。 Flyweight Factory管理已经存在享元的池子。客户端不直接创建享元。它们调用享元工厂的方法并且告诉这个创建方法它们期望得到享元的内部状态。工厂先去享元池中查找，如果这种享元已经存在就直返回，否则，就创建一个新的。 伪代码在这个例子中，享元模式帮助在画布上渲染一百万棵树。模式从一个主Tree类中抽离出重复的内部状态并把它放到一个享元类TreeType中。 现在不是将相同数据存储在多个对象中，而是把它们保留在几个享元对象中并且被响应的Tree对象连接（译者注：引用）。客户端代码通过享元工厂和不同的书协作，这个工厂封装了在新树对象中重用现有树类型的逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// The Flyweight class contains only a portion of state that describes a tree.// These field store values that hardly unique for each particular tree. You// won't find here tree coordinates, however textures and colors shared between// multiple are here. And since this data is usually BIG, you'd waste a lot of// memory by keeping it in each tree object. That's why we extract texture,// colors and other data to a separate flyweight class that can be referenced// from all those similar trees.class TreeType is field name field color field texture constructor Tree(name, color, texture) &#123; ... &#125; method draw(canvas, x, y) is Create a bitmap from type, color and texture. Draw bitmap on canvas at X and Y.// Flyweight factory decides whether to re-use existing flyweight or create a// new object.class TreeFactory is static field treeTypes: collection of tree types static method getTreeType(name, color, texture) is type = treeTypes.find(name, color, texture) if (type == null) type = new TreeType(name, color, texture) treeTypes.add(type) return type// Context object contains extrinsic part of tree state. Application can create// billions of these since they are pretty thin: just two integer coordinates// and one reference.class Tree is field x,y field type: TreeType constructor Tree(x, y, type) &#123; ... &#125; method draw(canvas) is type.draw(canvas, this.x, this.y)// Tree and Forest classes are Flyweight's clients. You might merge them// together if you don't plan to develop a Tree class any further.class Forest is field trees: collection of Trees method plantTree(x, y, name, color, texture) is type = TreeFactory.getTreeType(name, color, texture) tree = new Tree(x, y, type); trees.add(tree) method draw(canvas) is foreach tree in trees tree.draw(canvas) 适用性 当你在给定的RAM中难以装下必须要支持数量级的对象时。 应用Flyweight模式的好处在很大程度上取决于使用方式和位置。它常用在： 一个需要大量对象的应用； 这些对象占用系统全部RAM； 对象包含重复对象，并且它们可以被抽离并且共享。 如何实现 将一个类的字段划分享元，从以下两方面入手： 内部状态：字段包含不变的数据，许多对象的该字段值重复； 外部状态：字段包含上下文数据，所有对象的这个字段值都不一样。 把那些代表内部状态的字段保留在这个类中，并确保它们的不便性。它们应仅仅能通构造方法接收数据。 将外在状态的字段转化为引用它们的方法的参数。 创建一个享元工厂类。它应该在创建新享元之间检查该享元是否已经存在。客户端必须从享元工厂中请求享元。客户端需要在获取享元时需要像工厂方法描述它们期望的享元。 客户端必须存储或计算外部状态（上下文）的值以便能够调用flyweight对象的方法。 优点 节省RAM，因此允许一个程序支持更多对象。 缺点 在查找或者计算上下文时浪费CPU。 创建类更多的额外类增加代码复杂度。 和其他模式的关系 Flyweight常常和Composite结合使用来实现叶子结点共享和节约RAM。 Flyweight展示如何让创造更多小对象，而Facade告诉我们如何让用一个单独对象来代表一个完整子系统。 当每件事情都减少成一个享元对象时，Flyweight就和Singleton很像了。但是请记住，它们两者之间有两个根本区别： 单例对象是可变的。享元对象是不可变的。 Singleton的实力职能有一个，而Flyweight类可以有多个不同内部状态的实例。 Java中模式的应用用例：Flyweight目的单一：最小化内存占用。如果您的程序不会遇到RAM不足，那么你可以暂时忽略此模式。 Java核心库中Flyweight的例子： java.lang.Integer#valueOf(int) (also Boolean, Byte, Character, Short, Long and BigDecimal) 鉴定：Flyweight可以通过创建方法来识别，该方法返回缓存的对象，而不是创建新的对象。 参考翻译整理自：https://refactoring.guru/design-patterns/flyweight]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-结构模式之Proxy]]></title>
      <url>%2F2017%2F10%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BProxy%2F</url>
      <content type="text"><![CDATA[意图Proxy是结构模式的一种，它能够让你为另外一个对象提供一个替身或者占位符来控制对它的访问。 问题为什么要控制对对象的访问？比如：你有一个需要消耗大量系统资源的对象。你时不时会用到它，但不是一直使用。 因此，这个对象不用再程序启动时创建，而是当真正需要它的时候再创建。每个用到这个对象的客户端可能都有一些延迟实例化代码。显而易见，它导致了大量重复代码。 理想状态下，我们可以直接在对象类中加入代码，但不总是这样。比如，这是第三方库中的类。 解决Proxy模式建议创建一个和原服务对象遵循相同接口的替代类。当接收到客户端的请求时，代理对象创建一个服务对象的实例并把真正工作委托给他。 但是有什么好处呢？你可以在调用真正服务对象方法之前（或之后）在代理类中加入一些代码。因为代理和服务对象遵循相同的接口，它可以传递服务对象可以接受的任何代码。 现实世界类比支票支票是一种文件，可以命令银行从个人账户支付特定金额给持有支票的人。支票和现金都有一个通用的接口：可以用作付款。因此，支票是一大堆现金的代理。 站在消费者角度看，支票很棒，因为没有必要携带大量的现金。对于店主来说，他们也很好，因为可以在最近的银行兑换现金。 结构 Service interface为Service和Proxy生命了通用接口。 Service是一个提供有用业务逻辑的类。 Proxy有一个持有Service对象的字段。Proxy的方法做一些中间工作，并且大部分时间将请求传递给服务对象的相同方法。 大多情况下，Proxy管理它们的Service对象的声明周期。 Client应该同Service和Proxy通用接口协作。这样就可以把Proxy对象传递给任何期望一个Service对象的代码。 伪代码在这个例子中，Proxy模式帮助实现懒实例化并且为一个低效的第三方Youtube集成库做缓存。 原视频下载类在之前已经下载过的情况下也会再去下载这个视频。代理类仅会使用原下载器下载一次相同的视频，然后把它缓存下来，随后相同的请求会直接返回缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// The interface of a remote service.interface ThirdPartyYoutubeLib is method listVideos() method getVideoInfo(id) method downloadVideo(id)// Concrete implementation of a service connector. Methods of this class can// request various info from youtube. Request speed depends on a user's internet// connection as wells as Youtube's. Application will slow down if a lot of// requests will be fired at the same time, even if they are requesting the// same info.class ThirdPartyYoutubeClass is method listVideos() is Send API request to Youtube. method getVideoInfo(id) is Get a meta information about some video. method downloadVideo(id) is Download video file from Youtube.// On the other hand, to save some bandwidth, we can cache request results and// keep them for some time. But it might be impossible to put such code directly// to the service class: it could be provided by third party library or/and// defined as final. That is why we put the caching code to a new proxy class// which implements the same interface as a service class. It is going to// delegate to the service object only when the real requests have to be sent.class CachedYoutubeClass implements ThirdPartyYoutubeLib is private field service: ThirdPartyYoutubeClass private field listCache, videoCache field needReset constructor CachedYoutubeClass(service: ThirdPartyYoutubeLib) is this.service = service method listVideos() is if (listCache == null || needReset) listCache = service.listVideos() return listCache method getVideoInfo(id) is if (videoCache == null || needReset) videoCache = service.getVideoInfo(id) return videoCache method downloadVideo(id) is if (!downloadExists(id) || needReset) service.downloadVideo(id)// The GUI class, which used to work with a service object stays unchanged. But// only as long as it works with the service object through an interface. We can// safely pass here a proxy object instead of a real service object since both// of them implement the same interface.class YoutubeManager is protected field service: ThirdPartyYoutubeLib constructor YoutubeManager(service: ThirdPartyYoutubeLib) is this.service = service method renderVideoPage() is info = service.getVideoInfo() Render the video page. method renderListPanel() is list = service.listVideos() Render the list of video thumbnails. method reactOnUserInput() is renderVideoPage() renderListPanel()// Application can configure proxies on the fly.class Application is method init() is youtubeService = new ThirdPartyYoutubeClass() youtubeProxy = new CachedYoutubeClass(youtubeService) manager = new YoutubeManager(youtubeProxy) manager.reactOnUserInput() 适用性 懒初始化（虚拟代理）。当你有一个需要从文件系统，网络或者数据库加载数据的重量级对象时。 不是在应用启动时加载数据，而是将对象的初始化延迟到需要它的时间。 访问控制（保护代理）。当一个程序有不同类型的用户并且你想阻止未授权用户对保护对象的访问。比如，当对象是操作系统的关键部分，并且程序（包括恶意的）是他们的客户端。 代理会在每次请求时检查客户端的证书，只会让拥有正确访问权限请求通过。 本地执行一个远程服务（远程代理）。当一个真实服务对象在远程服务器上时。 在这种情况下，代理会把客户端的请求通过网络传递到远程服务，处理所有网络传输细节（译者注：Dubbo等RPC框架）。 缓存对象（智能引用）。当你需要混存客户端的请求并且管理它们的生命周期时（当结果比较重时）时。 Proxy能够统计引用服务对象或者缓存结果的数量。当所有的引用被释放，代理就可以销毁它追踪的对象（比如，终止数据库链接）。 Proxy还可以追踪客户端是否改变了服务对象。它可以重用未改变的对象并且保存系统资源。 请求日志（日志代理）。当你需要保留一个服务对象的请求历史。 Proxy可以在传递给服务对象之前记录下每次请求。 如何实现 从一个服务类抽象出代理和服务对象的通用接口。你可能需要创建一个服务类的子类作为被代理类，因为服务类可能是闭合的。 创建一个代理类。你应该用一个字段来持有服务对象的强引用。大多情况下，代理类自己创建它自己需要的服务对象。少数情况下，客户端通过构造代理类的构造方法把服务传递给代理。 根据目的来实现代理方法。大多情况下，在做一些事情后，代理类应该把工作委托给服务对象。 想想可以引入工厂对象来决定客户端需要什么样的对象，代理或真正的服务。另一方面，这个逻辑也可以在一个代理类中的一个创建方法中。 考虑添加懒初始化服务对象。这对比较重的对象很有用处。 优点 客户端无感知情况下控制对对象的访问。 可以在服务对象没有准备好时开始工作。 管理服务对象的生命周期，即使客户端并不关心。 缺点 延迟响应。 和其他模式的关系 Adapter提供不同的接口达到目的，而Proxy提供相同的接口。Decorator提供增强的接口。 Facade和Proxy很像，它们给复杂的实体提供缓冲并且初始化它。不像Facade，Proxy模式和服务对象遵循一样的接口，他们是通用的。 Decorator和Proxy结构相似，但目的不同。两者均采用组合的方式来把工作委托给其他对象。然而，Proxy自己管理服务对象的生命周期，而Decorator由客户端管理。 在Java中的使用用例：虽然代理模式在大多数Java程序中不是常客，但在某些特殊情况下，它是非常方便的。当你想在一些现有的类的对象中添加一些额外的行为而不改变客户端代码时，它是不可取代的。 在标准Java库中有一些例子： java.lang.reflect.Proxy java.rmi.* javax.ejb.EJB (注释) javax.inject.Inject (注释) javax.persistence.PersistenceContext 鉴定：代理将真正的工作全部委托给其他对象。每个代理方法应该最终引用一个服务对象，除非代理是服务的一个子类。 参考翻译整理自：https://refactoring.guru/design-patterns/proxy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-结构模式之Facade]]></title>
      <url>%2F2017%2F10%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BFacade%2F</url>
      <content type="text"><![CDATA[目的Facade是结构模式的一种，它让你可以为一个复杂的系统，类库或者框架提供一个简单的接口。 问题想象一下，代码必须和一大堆复杂的框架或者类库协作。你必须手动实力话这些对象，跟踪依赖，正确的顺序关系等等。 最后，你的业务逻辑类会和第三方类库的实现紧密耦合。这些代码难以理解和维护。 解决门面是一个类，它为一个包含很多类的复杂子系统提供一个简单的接口。相对直接调用子系统而言，门面提供有限的功能。它仅提供客户端关心的那些特性。 当你在使用一个拥有很多模块的的复杂类库，但是你只用到其中一部分功能时，使用门面模式就显得很便利。 比如，一个上传短视频到Youtube伤的app使用了一个专业的视频转换类库。但是它真正需要的只是一个拥有encode(filename,format)方法的类。创建这种类之后，你变有了第一个门面。 现实世界的类比电话下单当你用电话向一个商店下单时，话务员就是所有服务和部门的门面。他或者她提供了下单，支付，配送的简单接口。 结构 Facade（门面）为访问子系统的特定功能提供方便。它知道怎样引导客户的请求和怎样为所有moving parts做准备。 Additional facades用来隔离功能和阻止源门面变成另外一个复杂结构。Additional facades也可以被客户端或者其他门面使用。 Complex subsystem（复杂的子系统）包含很多类。为了让他们做一些有意义的事情，你必须知道它的实现细节，初始化顺序等很多事情。 注意：子系统并不关心门面的存在，它直接和其他模块协作。 Client使用门面代替直接调用子系统对象。 伪代码在这个例子中，门面简化了和一个复杂视频转换框架的协作。 门面是一个单独的类，它提供一个公开的方法来处理框架复杂的配置并返回一个正确的格式。 通过这种方式，门面模式保证客户端代码简单、干净、可靠。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Some classes of a complex 3rd-party video conversion framework. We don't// control that code, therefore can't simplify it.class VideoFile// ...class OggCompressionCodec// ...class MPEG4CompressionCodec// ...class CodecFactory// ...class BitrateReader// ...class AudioMixer// ...// To defeat the complexity, we create a Facade class, which hides all of the// framework's complexity behind a simple interface. It is a trade-off between// functionality and simplicity.class VideoConvertor is method convertVideo(filename, format):File is file = new VideoFile(filename) sourceCodec = new CodecFactory.extract(file) if (format == "mp4") distinationCodec = new MPEG4CompressionCodec() else distinationCodec = new OggCompressionCodec() buffer = BitrateReader.read(filename, sourceCodec); result = BitrateReader.convert(buffer, distinationCodec); result = (new AudioMixer()).fix(result); return new File(result)// Application classes don't depend on a billion classes provided by the complex// framework. Also, if you happen to decide to switch framework, you will only// need to rewrite the facade class.class Application is method main() is convertor = new VideoConvertor(); mp4video = convertor.convertVideo("youtubevideo.ogg", "mp4"); mp4video.save(); 适用性 当你需要一个简单但是功能有限的复杂子系统接口时 通常，子系统随着时间的推移变得越来越复杂。即使使用了设计模式也难避免创建更多的类。子系统可能变的更加灵活并且在不同的环境中复用性更高，但是它的样板代码数量也会随之增长。门面模式尝试通过提供访问子系统的一部分来适应更多客户端的需要。 当你想把一个子系统构建成层 创建门面来定义每个层子系统的连接点。如果多子系统之间相互依赖，你可以通过要求子系统只能通过门面交互来限制耦合。 如何实现 检查是否可以使用简化的接口和一个复杂的子系统交互。 如果接口使客户端没有子系统的依赖，你就在正确的轨道上。 创建一个门面类并在接口中描述它。它必须能够引导客户端调用适当的子系统对象。门面应该关心子系统正确的初始化。通常，这些代码在门面的构造方法中，懒实例化往往比较有用。 如果客户端仅和门面协作，你将得到巨大的收益。在这种情况下，客户端不需要关心子系统代码的变化。比如，当一个库的代码更新世，你只需要修改门面。 如果这个门面变的太大，请考虑抽离出一个新的门面。 优点 分离客户端和子系统组件。 客户端代码和子系统最小耦合。 缺点 门面可能造成god object，它和所有应用类耦合。 和其他模式的关系 Facade重新定义了一个接口，而Adapter重用了一个老接口。记住，Adapter使两个已存在接口协作，反对完全重新定义一个接口。 Abstract Factory可以用来替代Facade来隐藏平台特定的类。 Flyweight展示如何制造更多小对象，而Facade展示如何使用一个对象代表整个子系统。 Meditor在抽象已存在类的功能上和Facade很像。Mediator抽象/集中两个随意交互的协作对象。它常规的做法是“add values”，并且协作对象间相互知道被引用。相比之下，Facade为子系统定义了一个简单的接口，它并不添加新功能，并且子系统类不知道它的存在。 Facade可以被改造成Singleton，因为大多情况下单例门面对象就够了。 Facade在缓冲一个复杂实体和初始化这点上和Proxy很像。不像Facade，Proxy模式和他服务的对象拥有相同的接口，使得它们是通用的。 Java中模式的使用用例：在用Java写的app中，门面模式很常见。它特别用来处理和复杂类库和API协作的情景。 鉴定：Facade可以在具有简单接口的类中被识别，但是它将大部分工作委托给其他类。通常，门面管理它们使用对象的生命周期。 参考翻译整理自：https://refactoring.guru/design-patterns/facade]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-结构模式之Composite]]></title>
      <url>%2F2017%2F10%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BComposite%2F</url>
      <content type="text"><![CDATA[目的Composite是结构设计模式的一种，允许你像树一样组合对象，并且允许客户端像单个对象一样和这些结构协作。 问题Composite模式只有在你的业务模型可以被表示为一个树结构时才有意义。 比如，你有两个对象：Product和Box。这个Box可以包含几个Product和一些更小的Box。这些更小的Box也可以包含一些Product或者更小的Box等等。 现在，想象你的Product和Box是订单的一部分。计算订单的总价会非常困难。你拿到了一个大的Box，打开后看到它里面还有：ProductA，ProductB或者其他的Box，让我们再看看它里面有什么…不久，你将会停在一堆胶带和纸盒上，但仍在尝试计算总价。 那么，有更好的方法吗？ 解决Composite模式建议通过让Product和Box都遵循一个拥有getPrice()方法的通用接口来解决这个问题。 对Product来讲，它仅需要返货这个产品的价格。但是Box需要有更多的有趣行为。一个Box需要遍历它的内容并且寻味每一个商品（item）的价格。所以，如果一个商品是产品，它会立即返回价格。如果是一个更小的Box，它也需要遍历它自己商品的价格直到返回一个总价。一旦小计计算出来，Box甚至可以对总价做一些额外操作，像包装价之类。 现在，通过这个途径我们不必太过关心树的具体对象。不管是单个Product还是复杂的Box，你通过一个通用接口来操作它。并且，这个结构可以自己传递请求。 现实世界的类比军事结构大多数国家的军队看起来就像组合树。最底层，是一些士兵。它们组合成班。班组合成排。排组合成师。最后，几个师组成军队。 命令下达给层级的最高层，然后层层向下传递直到每个士兵都知道他们要做什么。 结构 Component为这个树结构的所有简单的和复杂的元素声明一个通用的接口。 Leaf是一个树的一个基本元素，它没有子节点。 因此它们没有任何委托对象，叶子节点通畅要做大多真正的工作。 Container（也叫做Composite）是一个有子节点的元素：叶子（Leaves）或其他容器（Container 或 Composite组合）。容器不需要知道子节点的类型，因为它们都实现了Component接口。 收到请求后，容器把它们委托给子节点，然后在返回给客户端之前运行并合计结果。 Client通过Component接口来使用树上的所有元素。 因此，客户端不需要关心它到底是在用简单的叶子还时复杂的容器。 伪代码在这个例子中，Composite模式帮助我们实现堆叠几何形状。 CompoundGraphic是一个容器，由任意数量的子形状，包括其他组合形状。组合形状和简单形状拥有相同的方法。但是，组合形状自己并不做实际的工作，它把请求传递给子形状，递归遍历自己的叶子节点和组合形状下的子节点。最后容器合并结果返回给客户端。 客户端通过接口和所有形状协作，这些形状都遵循这个接口。这样，客户端代码可以与非常复杂的结构一起工作，而不需要耦合具体的树形元素类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Common interface for all components.interface Graphic is method move(x, y) method draw()// Simple component.class Dot implements Graphic is field x, y constructor Circle(x, y) &#123; ... &#125; method move(x, y) is this.x += x, this.y += y method draw() is Draw a dot at X and Y.// Components could extend other components.class Circle extends Dot is field radius constructor Circle(x, y, radius) &#123; ... &#125; method move(x, y) is this.x = x, this.y = y method draw() is Draw a circle at X and Y and radius R.// The composite component includes methods to add/remove child components. It// tries to delegates to its children all operations defined in the// component interface.class CompoundGraphic implements Graphic is field children: array of Graphic method add(child: Graphic) is Add child to children array. method remove(child: Graphic) is Remove child to children array. method move(x, y) is For each child: child.move(x, y) method draw() is Go over all children and calculate bounding rectangle. Draw a dotted box using calculated values. Draw each child.// Application can operate with specific components or whole groups.class ImageEditor is method load() is all = new CompoundGraphic() all.add(new Dot(1, 2)) all.add(new Circle(5, 3, 10)) // ... method groupSelected(components: array of Graphic) is group = new CompoundGraphic() group.add(components) all.remove(components) all.add(group) // All components will be drawn. all.draw() 适用性 当你需要实现一个像树一样有着简单元素和容器的结构 Composite模式提供两种基本元素：简单叶子和可以存储其他叶子或者其他容器等的复杂容器。模式强制容器和它的子元素遵循通用的接口，这样就允许递归整个树结构操作。 当客户端应该统一处理简单和复杂的元素时。 感谢通用叶子和容器均遵循了通用接口，客户端代码不需要关心协作对象的类型。 如何实现 确保你的业务逻辑可能够被当作树结构。尝试把它们分离成简单元素和容器。切记，容器能够包含基本元素和其他容器。 定义Components（组件）的通用接口。它应该包含对简单和复杂组件来讲都合理的操作。 创建代表基本组件的Leaf（叶子）类。顺便说下，一个程序中可以有多个叶子类。 创建拥有可以存储子组件（数组）的Container类。这个字段可以存储叶子和容器，所以它要被声明为Component类型。 在实现Component接口的方法时，记住，Container应该把它的多数工作委托给子组件。 最后，为Container实现add/remove子元素的方法。 记住，这些操作应该被放在Component接口中。它喂饭了接口分离原则，因为这些方法在Leaf类中是空的。但是另一方面，树中所有的组件变得与客户端的立场相当。 优点 简化必须与复杂树结构交互的客户端代码。 添加新组件类型变的简单。 缺点 创建了一个太过通用的类设计。 和其他模式的关系 Builder可以用来一步一步的构建一个复杂的Composite。 Chain of Resopnsibility通常和Composite结合使用。在这种情况下，组件的父级可以作为其后继。 Iterator可以用来遍历Composite树。 Visitor用来操作Composite树的实体。 Flyweight场合Composite结合使用来实现叶子结点共享和保存RAM。 Composite和Decorator结构图很相似，因为它们都依赖递归组合来组织开放数量的对象。 Decorator可以看作只有一个组件的弱化Composite。然而，Decorator给对象赋予了额外责任，而Composite仅是对所有拥有相同行为的子元素做了“合并”。 但是它们也可以合作：Composite能够用Decorator改变树组件的行为。 使用Composite和Decorator模式使得设计笨重，可以使用Prototype来简化。它允许克隆复杂结构，而不是重新构造它们。 Java中模式的使用用例：Composite模式在Java代码中很常见。它常用来表示用户接口组件的层级或者和图像一起使用的代码。 这有一些在标准Java苦衷使用组合的例子： java.awt.Container#add(Component) (几乎遍及Swing组件) javax.faces.component.UIComponent#getChildren() (几乎遍及JSF UI 组件) 鉴别：组合模式很容易识别，它们的行为方法都有一个在树结构中具有相同抽象/接口类型的实例。 参考翻译整理自：https://refactoring.guru/design-patterns/composite]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-结构模式之Bridge]]></title>
      <url>%2F2017%2F10%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BBridge%2F</url>
      <content type="text"><![CDATA[目的Bridge是结构模式的一种，它可以帮你分离一个巨大的类或者将一组关系相近的类分离成为两个独立的层次结构，抽象和实现，可以各自独立开发。 问题抽象？实现？听起来害怕？我们首先来看个简单的例子。 你有一个几何Shap类，他有一对子类：Square和Triangle。你希望扩展这个层次结构来融入颜色以便创建红色和蓝色的形状。但是因为你已经有子类，你需要创建4个类来组合，比如BlueSquare和RedTriangle。 添加更多的形状类型和颜色将会导致层级结构变的更大。比如，添加一个Circles，你必须创建两个子类，每个对应一种颜色。之后，再添加新的颜色就需要为每个形状添加一个子类。再往后发展，将会变的更糟。 解决我们每次在扩展类层次到几个独立纬度时都会碰到这个问题。 Bridge模式尝试通过用委托替换继承来解决这个问题。你必须将其中一个维度抽离到不同的层次结构中。原类将通过持有新层次结构中的一个对象的引用的方式来替换在一个类中保留它所有的状态和行为的方式。 通过这种方式我们抽离出Color和它的两个子类，Red和Blue。Shape类将持有一个颜色类的引用域。当我们需要时通过这个引用把工作委托给color对象。这个引用在Shapps和Color之间像桥一样提供服务。从现在开始，添加color将不再需要改变shape类，反之亦然。 抽象（Abstraction）和实现（Implementation）在GoF的书中把“抽象和实现”一词作为Bridge模式定义的一部分。在我看来，那样太过学术并且使得这个模式变的更加难以理解。通过上面那个简单的例子，让我们看下GoF的真正意思。 抽象（Abstraction），也叫做接口（Interface），是一些实体的控制层。它们自己并不做任何真正事情，而是把大多工作委托给实现（Implementation）层，有时叫做平台（Platform）。不要把接口和抽象类和你的编程语言混淆，他们不是一回事。 比如，当我们谈到真正的应用是，抽象可以表示用户图形界面（GUI），实现可以表示响应用户交互的GUI层调用系统底层操作的API。 有两个方向来将应用扩展： 有一些不同的GUI（用户GUI和管理GUI） 支持一些不同的API（可以工作在Windows，Linux和MacOS下） 这个程序的代码看起来像“巨大的意大利面条碗”，有着成吨的连接不同GUI和API行为的操作条件。 可以通过对所有接口-平台的变体进行子类化来改进代码。但实际上，这个将导致我们已经在形状例子中看到的同样的问题。类层次将爆发时增长，每个新GUI或者API类型将需要增加一些组合类。 Bridge模式建议把这些类分成两个层次： 抽象层（Abstraction）：应用的GUI层。 实现层（Implementation）：操作系统API。 抽象对象持有一个具体实现对象的引用。只要遵循通用的接口，使同一个GUI能够在Windows和Linux下工作，不同的实现将是可互换的。 更重要的是，你可以在不触碰操作系统代码的情况下开始在GUI类中工作，反之亦然。比如，添加一个对新操作系统的支持，将仅需要在实现层中创建一个子类。 结构 抽象（Abstraction）主要包含一个像用户接口一样的控制逻辑。抽象代码依赖具体实现对象来完成任务。 实现（Implementation）为所有具体的实现声明了通用的接口。抽象层可以和任何一个符合这个接口的具体实现工作。 抽象和实现接口在一些程序中是相等的。但是大多情况下，实现包含基本的原语操作，抽象层用它们来处理一些复杂的行为。 具体实现包含具体平台的代码。 精制抽象（Refined Abstractions）可以用来创建一些控制逻辑的变种。这些类和它们的父类一样，应该用实现接口（Implementation inteface）来和不同的实现协作。 客户端（Client）只和抽象类有一个地方不同。在构建抽象对象时，客户端会传递一个具体实现对象。然而，如果需要，具体实现可以动态替换。 伪代码在这个例子中，Bridge将设备（Devices）和遥控器（Remotes）的代码分成几部分： 设备（看作实现） 遥控器（看作抽象） 遥控器的基类有一个域来持有一个要控制设备的对象引用。遥控器通过设备提供的通用接口工作。它允许一个遥控器可以和几个不同的设备协作（译者注：控制几个不同类型的设备）。 你可以独立的改变控制类。例如，你可以创建一个仅有两个按钮的遥控器或者带有触摸屏的复杂遥控器。 因此，Bridge模式允许你将一个实体分成几个不同的实体，它们可以独立发展。客户端代码总是保持简单。它只需要选择一个抽象并且配置给它一个具体实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// All remote classes contain reference to the device they controls. Remote's// methods delegate most of the work to the device methods.class Remote is protected field device: Device constructor BasicRemote(device: Device) is this.device = device method togglePower() is if device.isEnabled() then device.disable() else device.enable() method volumeDown() is device.setVolume(device.getVolume() - 10) method volumeUp() is device.setVolume(device.getVolume() + 10) method channelDown() is device.setChannel(device.getChannel() - 1) method channelUp() is device.setChannel(device.getChannel() + 1)// You can extend remote hierarchy independently from device classes.class AdvancedRemote extends BasicRemote is method mute() is device.setVolume(0)// All devices have the common interface. This makes them compatible with// all remotes.interface Device is method isEnabled() method enable() method disable() method getVolume() method setVolume(percent) method getChannel() method setChannel(channel)// But each concrete device may have its own implementation.class Tv implements Device is // ...class Radio implements Device is // ...// Somewhere in client code.tv = new Tv();remote = new Remote(tv)remote.pover()radio = new Radio();remote = new AdvancedRemote(radio) 适用性 当你有一个包含一些功能变种的大类（比如，工作在几个不同的数据库服务上） 这个类会变的很难维护，因为任何一个人触碰她的人都需要花费大量的时间去完全理解它。更改功能的某个变种会导致编辑整个类，这可能会引起讨厌的被忽视的错误。 Bridge模式将单体类分成几个层次，一个包含另外一个的引用。这些层次中的类可以独立的编辑。它简化了支持，并最大限度地减少了修改现有代码的风险。 当你需要在正交（独立）的维度扩展一个类 取代单层次的增长，Bridge模式建议为每个维度创建一个分离的类层次，并且通过引用域来关联这些层次。 当你需要在运行时改变实现 尽管它是可选的，Bridge模式允许改变抽象中的实现对象。这就像为一个字段分配一个新值一样简单。 顺便说下，这也是为什么许多人对Bridge模式和Strategy模式分不清楚。记住，模式不仅仅是类结构，而是意图（译者注：或者目的）。Bridge模式的目的就是结构化代码。 如何实现 确定你的类是正交维度。这些独立的概念可以是：abstraction/platform, or domain/infrastructure, or front-end/back-end, or interface/implementation. 考虑客户端想要干什么，然后把他们描述在基本抽象类中。 确定所有平台的能力和抽象需要什么。然后把它们描述在实现接口中。 在你的领域中为所有平台创建具体实现类，确定它们都遵循了实现接口。 在抽象类中增加一个实现类型的域。然后实现所有抽象方法，同时将大部分工作委托给该域中引用的实现对象。 客户端代码应将实现对象传递给抽象的构造函数。它可以根据需要使用抽象对象。 优点 允许建立平台独立代码。 符合开闭原则。 对客户端隐藏实现细节。 缺点 创建多个附加类导致总体代码复杂性增加。 和其他模式的关系 Bridge是前置设计，让抽象和实现相互独立。Adapter是通过改装使得没有关系的类协作。Adapter通常是在设计完成后使用；Bridge通常是设计时采用。 State, Strategy, Bridge (和某种程度上的Adapter) 具有相似的解决结构。它们都是采用分享“句柄/身体”的方式。它们的意图不同，因此它们解决不同的问题。 Abstract Factory可与Bridge模式一起使用。当Bridge“接口”的一部分只能与特定的“实现”工作时，这很有用。在这种情况下，工厂可以封装这些关系，对客户端隐藏复杂性。 Builder可以构造为Bridge模式：Director将作为接口，Builders将扮演实现角色。 Java中模式的使用用例：Bridge模式对这些情况特别适用：跨平台应用，支持多类型的数据库服务，和一些特定类型的API提供者（例如，云平台，社交网络等）合作。 坚定：可以通过区分控制实体和它所依赖的几个不同的平台来识别Bridge模式。 参考翻译整理自：https://refactoring.guru/design-patterns/bridge]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-结构模式之Decorator]]></title>
      <url>%2F2017%2F09%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BDecorator%2F</url>
      <content type="text"><![CDATA[目的Decorator（装饰器）是一个结构设计模式，可以让你在封装包涵对象原有行为的基础上增加新的行为。 问题你需要动态的添加或者移除一个对象的责任，但是你要做到和应用中其他代码的兼容。 当你需要扩展一个类的行为时继承时第一个想到的处理方式。然而，继承是静态的。你不能够增加一个新的类到程序中当它已经编译或者执行完成。 解决办法装饰器模式依赖一个叫做装饰者（或者包装者）的特别类。他们和被封装的类拥有一样的接口，所以客户端代码不会注意到你用封装者替换了源对象。 所有的封装者这都持有一个源对象实例的强引用。大多数包装器使用传入其构造函数的对象初始化该字段。 所以，该如何动态改变他的行为呢？正如我提到的，封装者何和目标对象拥有一样的接口。当你调用装饰者的方法时，他执行被封装对象中同样方法并且在返回的结果中添加一些东西。它也可以在原始方法之前调用，但这取决于业务逻辑。 这里是有趣的一部分：你可以使用装饰者封装一个对象，然后再使用另外一个装饰器封装这个包装结果，等等。最终的行为结果是所有装饰器和源对象组合得到的。 现实世界的类比穿衣服就是使用装饰者的例子。当你冷的时候，你用毛衣包裹自己。如果你还是冷，你可以在外边套一个夹克。如果下雨了，你还可以再传一件雨衣。 所有的服装“扩展”自你基本的行为，但不是你的一部分。因此，在你不需要他们的时候，可以轻松的移除它们。 结构 Component为被封装者声明了一个通用的接口。 Concrete Component是一个包涵基本行为并可以被装饰器修改的类。 Base Decorator包涵一个被封装对象的强引用域。这个域应该被声明为Component类型，以便支持Concrete Components 和 Decorators.Base Decorator将所有操作委托给被封装对象。 Concrete Decorators包涵可以被动态添加的额外行为。装饰器可以在调用被封装对象方法前后执行自己的行为。 伪代码在这个例子中，装饰器通过加密保护金融数据，对已经存在的代码来讲是透明的。应用对金融数据做了加密和压缩装饰，当我们从硬盘读取数据时返回的是普通的数据，但是当我们写会到磁盘时数据被加密和压缩。 装饰者和金融类都有一个相同的接口，使得它们对客户端来讲是通用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// Common interface for all components.interface DataSource is method writeData(data) method readData():data// One of the concrete components can act as a base layer.class FileDataSource implements DataSource is constructor FileDataSource(filename) &#123; ... &#125; method writeData(data) is Write data to file. method readData():data is Read data from file.// All other concrete components may act as wrappers.class DataSourceDecorator implements DataSource is protected field wrappee: DataSource constructor DataEncyptionDecorator(source: DataSource) is wrappee = source method writeData(data) is wrappee.writeData(data) method readData():data is return wrappee.readData()// Concrete Decorators extend the functionality of a component they wrap.class EncyptionDecorator extends DataSourceDecorator is method writeData(data) is Encrypt passed data. Pass the compressed data to wrappee's writeData() method. method readData():data is Get the data from wrappee's readData() method. Decrypt and return that data.// You can wrap objects in several layers of decorators.class CompressionDecorator extends DataSourceDecorator is method writeData(data) is Compress passed data Pass the compressed data to wrappee's writeData() method. method readData():data is Get the data from wrappee's readData() method. Uncompress and return that data.// Option 1. A simple example of decorator assembly.class Application is method dumbUsageExample() is source = new FileDataSource('somefile.dat') source.writeData(salaryRecords) // a file with plain data source = new CompressionDecorator(source) source.writeData(salaryRecords) // compressed file source = new EncyptionDecorator(source) source.writeData(salaryRecords) // compressed and encrypted file// Option 2. Client code, which uses an external data source. SalaryManager// neither knows not cares about data storage specifics. It receives already// configured data source.class SalaryManager is field source: DataSource constructor SalaryManager(source: DataSource) &#123; ... &#125; method load() is return source.readData() method save() is source.writeData(salaryRecords) // ...Other useful methods...// Application can assemble objects with a different set of functionality using// the same decorators at run time, depending on the configuration// or environment.class ApplicationConfigurator is method configurationExample() is source = new FileDataSource("salary.dat"); if (enabledEncryption) source = new EncyptionDecorator(source) if (enabledCompression) source = new CompressionDecorator(source) logger = new SalaryLogger(source) salary = logger.load(); // ...Rest of an application code. 适用性 当你需要动态赋予某个对象行为并且不需要破坏这个对象的代码。 装饰器模式允许给某个对象动态的赋予新的行为，而且对客户端代码是隐式的。对象可以同时封装多个wrapper（译者注：就像同时穿了背心、衬衣和西装），结果是所有封装的堆叠结果。 当不可能活着不合适通过继承来扩展对象的行为。 许多编程语言都有final关键字来阻止未来对一个类的扩展。当处理这些代码，进行扩展的唯一选项就是适用装饰器模式。 如何实现 确保您的任务可以表示为一个主要组件和几个可选扩展。 创建Component（组件）接口，它需要描述该组件所有可被扩展的方法。 创建Concrete Component（具体组件）类并且实现业务逻辑。 创建Base Decorator（基础装饰）类。创建一个域来保存被封装对象的强引用。该域应该是Component类型，这样强引用就可以持有组件类和装饰器的强引用（译者注：即变量声明为接口类型，这样可以持有所有Component的所有子类）。 确保所有子类实现了Component接口。 确保Base Decorator类的所有方法都将方法执行委托给了被包装对象。它将允许Concrete Decorators（具体装饰器）仅扩展一部分组件行为，并且不需要修改其他行为。 创建Concrete Decorators类，该类从Base Decorator扩展。 一个Concrete Decorator可以在调用被封装对象相同方法前后执行它自己的的行为（你可以仅仅只调用弗雷德方法，因为它将最终调用封装方法）。 Client代码必须负责配置包装层。Client应该通过Component的接口和其他类一起工作，使装饰器可以互换。 不必完全拘泥于以上步骤，一些情况下译者认为完全可以省略掉Base Decorator。 优缺点 优点 比继承灵活 允许在运行时添加和删除行为 通过使用多层封住，组合几个额外的行为。 可以组合多个单行为实现使其实现更加复杂的行为。 缺点 配置一个多封装对象是困难的。 导致很多小类。 和其他模式的关系 Adapter提供不同的接口来达到目的。Proxy提供相同的接口。Decorator提供增强的接口。 Adapter意味着改变一个存在对象的接口。Decorator在不改变原有接口的情况下增强另外一个对象。Decorator对应用来讲比Adapter更加透明。因此，Decorator支持递归组合，这对于纯Adapter是不可能的。 Chain of Responsibility（责任链）和Decorator具有非常普通的类机构。它们都依赖于一系列对象的递归组合来执行。但是它们也有几个关键的不同点。 Chain of Responsibility的处理者可以执行随意的行为操作，处理者之间相互独立。它们可以随意的终端下一步的调用。另一方面，各种Decorator扩展一个特别的行为并且假设保持接口一致。并且，Decorator不允许随意中断执行链。 Composite和Decorator拥有类似的结构图，因为它们都依赖递归组合来组织一个对象开闭的数量。 装饰器可以看作只有一个组件的退化组合。然而，Decorator向对象增加了额外的责任，而Composite只是对其子类执行相同的行为的“summs up”。 但是它们也可以协作：Composite可以使用Decorator来改变树组件的行为。 大量使用Composite和Decorator模式的设计通常可以从Prototype中受益。它允许克隆复杂的结构，而不是从头重新构建它们。 装饰器可以让您更改对象的皮肤。策略让你改变勇气。 Decorator和Proxy有相似的结构，但是目的不同。两种模式都建立在将工作委托给其他对象的组合原则上。然而，Proxy自己管理他持有服务对象的生命周期，而Decorator结构由客户端控制。 Java中模式的使用用例：Decorator在Java中是十分标准的，尤其是和流相关的代码。 这有几个Java核心库中使用Decorator的例子： java.io.InputStream，OutputStream，Reader和Writer的所有子类都有接受它们自己类型的构造方法。 java.util.Collections，方法checkedXXX()，synchronizedXXX()和unmodifiableXXX()。 javax.servlet.http.HttpServletRequestWrapper和HttpServletResponseWrapper。 鉴定：可以通过创建方法或构造函数来识别Decorator，它接受与当前类相同的类或接口的对象。 参考翻译整理自：https://refactoring.guru/design-patterns/decorator]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-结构模式之Adapter]]></title>
      <url>%2F2017%2F09%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BAdapter%2F</url>
      <content type="text"><![CDATA[目的适配器是一种结构设计模式，使得不兼容接口间的可正常进行协作。 问题想象你有一个使用XML作为数据处理格式的APP，但你用到了一个仅支持JSON数据格式的类库。 举个例子，你有一个做股票数据的APP。他从多个数据源获取XML来展示成图标。在一个新版本中，你决定使用一些三方的分析包。但是有一个问题：分析包仅支持JSON数据。 在这种情况下，可以重写你自己的代码以便支持JSON或者改变依赖的库使其支持XML。第一种选择要破坏已有的代码，第二种选择看上去是不可能的，因为我们常常无法修改三方库。 解决方法你可以创建一个适配器。它可以将调用方发送的数据按照格式转换成三方库可以解析的类型。适配器封装了对一个对象复杂的转换过程。 适配器可以不仅可以格式化数据，也可以适配接口。比如，适配器接收到一个对方法A的调用，他可以转交给被包装的方法B、C、D。 有时甚至可以创建一个双向适配，这样就可以双向转换。 综上讨论，股票超市APP需要一个特别的XML_To_JSON_Adapter类。在调用分析类库之前，将xml转换为json。采用这种方式你将不需要改变任何已有的APP代码，也不需要改变分析库的代码。 真实世界的类比不同国家的插头和插板当你第一次从美国到偶主，你会发现没办法给你的笔记本充电。两个国家插座和插头的标准根本不一样。这就是为什么美国的插头没办法适配德国的插座。 这个问题可以通过使用具有美式插座和欧式插头的电源插头适配器来解决。 结构对象适配实现采用组合原则：适配器实现其中一对象的接口，并且封装另一个对象。他可以在所有新生代语言中实现。 类适配实现采用集成。适配器同是继承两个接口。该方式只有像C++这种支持多继承的语言可以实现。 Existing interface （存在的接口或者类）已经被你的其余代码支持 Service （服务）是一些不能在应用类直接工作的有用类（通常是三方库或者遗留代码） Adapter 实现了 Existing interface 并且持有 Service 类引用。 adapter会接收到client通过 Existing interface 定义的方法调用。他在调用 Service 前可能会修正调用参数的类型或者格式化数据。 Client 使用 Adapter 调用 Existing interface 中定义的接口。 这里允许添加新的 Adapter 来编程而不需要改动已经存在的代码（Service 改变的的情况可能也会出现，比如，当你更新依赖的三方库）。 这个adapter类不需要封装任何对象。他同时实现了两个接口。因此，对所有的对象都是兼容的。 伪代码让我们看看Adapter如何从一个接口到另一个接口进行基本数据转换。这个例子给予圆孔和方形钉的冲突。圆孔可以和圆钉很好的工作；可以通过两者的半径来决定是否合适。但是方形钉不能测量半径。 这就是我们为什么需要创建一个Adapter类来封装方形钉对象并且伪装他有一个等于方形直径一半的半径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Classes with compatible interfaces: RoundHole and RoundPeg.class RoundHole is constructor RoundHole(radius) &#123; ... &#125; method getRadius method fits(peg: RoundPeg) is return this.getRadius() &gt;= peg.radius()class RoundPeg is constructor RoundPeg(radius) &#123; ... &#125; method getRadius() is Return the peg radius.// Obsolete incompatible class: SquarePeg.class SquarePeg is constructor SquarePeg(width) &#123; ... &#125; method getWidth() is Return the square peg width.// Adapter allows fitting square pegs into round holes.class SquarePegAdapter extends RoundPeg is private field peg: SquarePeg constructor SquarePegAdapter(peg: SquarePeg) is this.peg = peg method getRadius() is return Math.sqrt(Math.pow((peg.getWidth()/2), 2) * 2);// Somewhere in client code.hole = new RoundHole(5)rpeg = new RoundPeg(5)hole.fits(rpeg) // truesmall_sqpeg = new SquarePeg(2)large_sqpeg = new SquarePeg(5)hole.fits(small_sqpeg) // won't compile (incompatible types)small_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)large_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)hole.fits(small_sqpeg_adapter) // truehole.fits(large_sqpeg_adapter) // false 适用性当你想服用已经存在的类，但是接口和应用其他代码不兼容 采用适配器模式创建一个中间层来将调用转换成应用中已存在对象可以处理的数据。 你需要复用几个已经存在的类，但是她们缺少一些常用的功能。并且你无法在父类中添加这些功能，因为他是闭源或者被其他代码使用的。 你可以把这些缺少的功能放到新建的adapter中。他将连接你应用的代码和你感兴趣的类。这种解决方式看起来很像Visitor模式。 如何实现 确保你有两种元素： 有用的service对象 应用代码必须使用service对象。应用不能够直接调用service，因为接口或者数据格式不兼容。 声明后面需要adpater跟随的client接口。应用将使用这个接口和adapter交互。 创建一个adpater，实现client接口（空实现）。 adapter增加一个service变量。通常情况下，这个变量在构造方法中设置。简单的场景下，适配器可直接转发调用（直接调用service中对应的方法）。 实现client定义的接口。adapter方法直接调用service中适当的方法并传递格式化后的数据。 adapter类编写完成后，在应用中通过client接口来使用它。 优缺点 优点：隐藏了客户端代码不需要知道的接口实现细节和数据转换 缺点：引入新的类，使得整体复杂度增加 和其他模式的联系 Bridge（桥接）是先期设计把抽象和实现独立。Adapter是进行改装，使没有关系的类在一起工作。Adapter是在设计后期使一些功能工作；Bridge在前期做这些事情。 Adapter为了实现目标，提供不同的接口。Proxy（代理）提供相同的接口。Decorator（装饰）提供增强的接口。 Adapter意味着改变现有代码的接口。Decorator另一个对象的接口但是没有改变接口。因而Decorator比Adapter更透明。结果就是，Decorator支持递归组合，纯粹的适配器做不到这点。 Facade（门面）定义了一个新接口，而Adapter复用已有接口。记住，Adapter使两个存在的接口协作而不是完全定义一个新接口。 Sate（状态），Strategy（策略），Bridge（某种程度上的Adapter）有类似的解决结构。他们都是共享”handle/body”元素。他们的意图不同，所以，他们解决不同的问题。 Java中模式的使用用例：Adapter模式在Java代码中很常见。它经常用于基于一些遗留代码的系统中。在这种情况下，Adapter使得老代码变得符合现在的需要。 在Java核心库中有一些标准的Adapter： java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() java.io.InputStreamReader(InputStream) (returns a Reader object) java.io.OutputStreamWriter(OutputStream) (returns a Writer object) javax.xml.bind.annotation.adapters.XmlAdapter#marshal() and #unmarshal() 参考翻译整理自：https://refactoring.guru/design-patterns/adapter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-Spring-理解AOP代理]]></title>
      <url>%2F2017%2F06%2F29%2F%E8%AF%91-spring-%E7%90%86%E8%A7%A3AOP%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[引入之前写过一篇关于Spring代理流程的博客，当时没有深入思考，最近碰到一个有趣的事情，类内部调用带有spring注解，但注解不生效的问题，举例说明： 123456789101112public class SimplePojo implements Pojo &#123; public void foo() &#123; // this next method invocation is a direct call on the 'this' reference this.bar(); &#125; @Transaction public void bar() &#123; // some logic... &#125;&#125; 外部一个类直接调用SimplePojo.bar()事务是有效的，但如果调用SimplePojo.foo()，那么bar()方法上的事务不会生效。查了一下spring文档，其中特别对AOP代理做了讲解，现翻译记录。 对照译文原文链接:https://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-understanding-aop-proxies Spring AOP is proxy-based. It is vitally important that you grasp the semantics of what that last statement actually means before you write your own aspects or use any of the Spring AOP-based aspects supplied with the Spring Framework. Srping AOP基于proxy-based。在我们基于Spring框架自定义切面或者使用Spring基于AOP-based提供的切面之前，理解proxy-based的含义很重要。 Consider first the scenario where you have a plain-vanilla, un-proxied, nothing-special-about-it, straight object reference, as illustrated by the following code snippet. 看下面一个最简单的调用片段。 1234567891011public class SimplePojo implements Pojo &#123; public void foo() &#123; // this next method invocation is a direct call on the 'this' reference this.bar(); &#125; public void bar() &#123; // some logic... &#125;&#125; If you invoke a method on an object reference, the method is invoked directly on that object reference, as can be seen below. 如果你使用对象的引用调用其一个方法，这个方法是被直接调用的，看下图。 12345678910public class Main &#123; public static void main(String[] args) &#123; Pojo pojo = new SimplePojo(); // this is a direct method call on the 'pojo' reference pojo.foo(); &#125;&#125; Things change slightly when the reference that client code has is a proxy. Consider the following diagram and code snippet. 当客户端代码的引用是代理时，会略有改变。请看下图和代码片段。 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; ProxyFactory factory = new ProxyFactory(new SimplePojo()); factory.addInterface(Pojo.class); factory.addAdvice(new RetryAdvice()); Pojo pojo = (Pojo) factory.getProxy(); // this is a method call on the proxy! pojo.foo(); &#125;&#125; The key thing to understand here is that the client code inside the main(..) of the Main class has a reference to the proxy. This means that method calls on that object reference will be calls on the proxy, and as such the proxy will be able to delegate to all of the interceptors (advice) that are relevant to that particular method call. However, once the call has finally reached the target object, the SimplePojo reference in this case, any method calls that it may make on itself, such as this.bar() or this.foo(), are going to be invoked against the this reference, and not the proxy. This has important implications. It means that self-invocation is not going to result in the advice associated with a method invocation getting a chance to execute. 着重看下Main类中main方法中对代理的引用。这意味着对该对象引用的方法调用实际调用的是代理，因此代理能够将调用委托给与该方法调用相关的所有拦截器（advice）。然而，一旦调用最终到达目标对象，例子中的SimplePojo引用，那么其任何自我方法的调用，例如this.bar()或者this.foo(),都将是直接调用，而不是调用的代理。这点特别重要。这意味着自我调用不会被其相关联advice不会被执行。 Okay, so what is to be done about this? The best approach (the term best is used loosely here) is to refactor your code such that the self-invocation does not happen. For sure, this does entail some work on your part, but it is the best, least-invasive approach. The next approach is absolutely horrendous, and I am almost reticent to point it out precisely because it is so horrendous. You can (choke!) totally tie the logic within your class to Spring AOP by doing this: 那么我们要做些什么呢？最好的方式是重构你自己的代码使得不会发生自我调用。当然，这需要一些工作量，但这是最好并且低侵入的方式。另外一种方式绝对是可怕的。你可以将你的逻辑与Spring AOP完全耦合，比如： 1234567891011public class SimplePojo implements Pojo &#123; public void foo() &#123; // this works, but... gah! ((Pojo) AopContext.currentProxy()).bar(); &#125; public void bar() &#123; // some logic... &#125;&#125; This totally couples your code to Spring AOP, and it makes the class itself aware of the fact that it is being used in an AOP context, which flies in the face of AOP. It also requires some additional configuration when the proxy is being created: 这完全将你的代码与Spring AOP结合在一起，它使得这个类本身就意识到它被用在一个面向AOP的AOP上下文中。它也使用时也需要加入一些配置： 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; ProxyFactory factory = new ProxyFactory(new SimplePojo()); factory.adddInterface(Pojo.class); factory.addAdvice(new RetryAdvice()); factory.setExposeProxy(true); Pojo pojo = (Pojo) factory.getProxy(); // this is a method call on the proxy! pojo.foo(); &#125;&#125; Finally, it must be noted that AspectJ does not have this self-invocation issue because it is not a proxy-based AOP framework. 最后，必须注意的是，AspectJ没有这种自我调用问题，因为它不是基于proxy-based的AOP框架。 总结回顾了下上一篇关于AOP源码阅读的博客，其实代码中已经给出答案。只是当时并没想这么多。代理类实际上是对目标类做了聚合封装。这也就解释了为什么自我调用时advisor不会被执行。 123456789101112131415161718192021222324//AbstractAutoProxyCreatorprotected Object createProxy( Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123; ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); ... Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); for (Advisor advisor : advisors) &#123; proxyFactory.addAdvisor(advisor); &#125; proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) &#123; proxyFactory.setPreFiltered(true); &#125; return proxyFactory.getProxy(getProxyClassLoader());&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解ClassLoader]]></title>
      <url>%2F2017%2F06%2F28%2F%E4%BA%86%E8%A7%A3ClassLoader%2F</url>
      <content type="text"><![CDATA[初识ClassLoader 在开发中有时会碰到ClassNotFoundException。这个异常和ClassLoader有着密切的关系。 我们常使用instanceof关键字判断某个对象是否属于指定Class创建的对象实例。如果对象和Class不属同一个加载器加载，那么instanceof返回的结果一定是false。 GC Root有一种叫做System Class，官方解释“Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util. .”，大意是：被bootstrap/system加载器加载的类，比如，像java.util.这些来自rt.jar的类。 GC时对Class的卸载，需要满足的条件如下： 类需要满足以下3个条件才能算是“无用的类” 该类所有的实例已经被回收 加载该类的ClassLoder已经被回收 该类对应的java.lang.Class对象没有任何对方被引用 ClassLoader简介 我们的Java应用程序都是由一系列编译为class文件组成，JVM在运行的时候会根据需要（比如：我们需要创建一个新对象，但是该对象的Class定义并未在Perm区找到）将应用需要的class文件找到并加载到内存的指定区域供应用使用，完成class文件加载的任务就是由ClassLoader完成。 ClassLoader类的基本职责就是根据一个指定的类的名称，找到（class可能来源自本地或者网络）或者生成其对应的字节代码，然后从这些字节代码中定义出一个java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。 在JVM中每个ClassLoader有各自的命名空间，不同的ClassLoader加载的相同class文件创建的Class实例被认为是不相等的，由不相等的Class创建的对象实例无法相互强制转型，如开头所提，当我们使用instanceof关键字判断时需要注意。 双亲委派模型双亲委派模型很好理解，直接上代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 使用指定的二进制名称来加载类。默认的查找类的顺序如下： * 调用findLoadedClass(String) 检查这个类是否被加载过；* 调用父加载器的loadClass(String)，如果父加载器为null，使用虚拟机内置的加载器代替； * 如果父类未找到，调用findClass(String)方法查找类。*/protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 从源码中我们看到有三种类加载器： 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码（C++）来实现的，并不继承自java.lang.ClassLoader。负责将${JAVA_HOME}/lib目录下和-Xbootclasspath参数所指定的路径中的，并且是Java虚拟机识别的（仅按照文件名识别，如rt.jar，不符合的类库即使放在lib下也不会被加载）类库加载到JVM内存中，引导类加载器无法被Java程序直接引用； 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库（${JAVA_HOME}/ext），或者被java.ext.dirs系统变量所指定的路径中的所有类库； 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载Java类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 1234567891011121314151617public class ClassLoaderTree &#123; /** * 输出： * sun.misc.Launcher$AppClassLoader@18b4aac2 * sun.misc.Launcher$ExtClassLoader@5305068a * null * @param args */ public static void main(String[] args) &#123; ClassLoader loader = ClassLoaderTree.class.getClassLoader(); while (loader!=null)&#123; System.out.println(loader.toString()); loader = loader.getParent(); &#125; System.out.println(loader); &#125;&#125; 每个Java类都维护着一个指向定义它的类加载器的引用，通过getClassLoader()方法就可以获取到此引用。通过调用getParent()方法可以得到加载器的父类，上述代码输出中，AppClassLoader对应系统类加载器（system class loader）；ExtClassLoader对应扩展类加载器（extensions class loader）；需要注意的是这里并没有输出引导类加载器，这是因为有些JDK的实现对于父类加载器是引导类加载器。这些加载器的父子关系通过组合实现。 为什么要双亲委派 避免重复加载。当父亲已经加载了该类，子类就没有必要再加载一次； 安全。如果不使用这种委托模式，那我们就可以使用自定义的String或者其他JDK中的类，存在非常大的安全隐患，而双亲委派使得自定义的ClassLoader永远也无法加载一个自己写的String。 创建自定义ClassLoader自定义的类加载器只需要重写findClass(String name)方法即可。java.lang.ClassLoader封装了委派的逻辑，为了保证类加载器正常的委派逻辑，尽量不要重写findClass()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir)&#123; this.rootDir = rootDir; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null)&#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; while ((bytesNumRead = ins.read(buffer)) != -1)&#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; &#125;&#125; 实验更多实验代码放在github上：https://github.com/Childe-Chen/goodGoodStudy/tree/master/src/main/java/com/cxd/classLoader 1234567891011121314151617181920212223242526public class TestClassIdentity &#123; public static void main(String[] args) &#123; FileSystemClassLoader fileSystemClassLoader = new FileSystemClassLoader("/Users/childe/Documents/workspace/goodGoodStudy/target/classes"); try &#123; Class&lt;?&gt; c = fileSystemClassLoader.findClass("com.cxd.classLoader.Sample"); //forName会执行类中的static块(初始化) Class&lt;?&gt; c1 = Class.forName("com.cxd.classLoader.Sample"); System.out.println(c1.isAssignableFrom(c)); //运行时抛出了 java.lang.ClassCastException异常。虽然两个对象 o1 o2的类的名字相同，但是这两个类是由不同的类加载器实例来加载的，因此不被 Java 虚拟机认为是相同的。 //不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。 // 不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。这种技术在许多框架中都被用到 Object o = c.newInstance(); Method method = c.getMethod("setSample", java.lang.Object.class); Object o1 = c1.newInstance(); method.invoke(o,o1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011public class Sample &#123; private Sample instance; static &#123; System.out.println("static"); &#125; public void setSample(Object instance) &#123; this.instance = (Sample) instance; &#125;&#125; 打破双亲委派模型没有完美的模型，双亲委派在面对SPI时，不得不做出了特例或者说改进。我们知道Java提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的有JDBC、JCE、JNDI、JAXP 和 JBI 等。SPI的接口由Java核心库定义，而其实现往往是作为Java应用所依赖的 jar包被包含到CLASSPATH里。而SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，由引导类加载器加载；SPI的实现类是由系统类加载器加载，引导类加载器无法找到SPI的实现类，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。 为了解决这个问题，Java引入了线程上下文类加载器，在Thread中聚合了contextClassLoader，通过Thread.currentThread().getContextClassLoader()获得。原始线程的上下文ClassLoader通常设定为用于加载应用程序的类加载器。也就是说父加载器可以通过县城上下文类加载器可以获得第三方对SPI的实现类。 以Java链接Mysql为例，看下Java如何来加载SPI实现。12345// 注册驱动，forName方法会初始化Driver，初始化块中向DriverManager注册驱动Class.forName("com.mysql.jdbc.Driver").getInstance(); String url = "jdbc:mysql://host:port/db"; // 通过java库获取数据库连接Connection conn = java.sql.DriverManager.getConnection(url, "name", "password"); com.mysql.jdbc.Driver是java.sql.Driver的一种实现。 1234567891011121314package com.mysql.jdbc;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;// // Register ourselves with the DriverManager // 向DriverManager注册驱动 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125; ...&#125; 接下来我们调用getConnection就进入了本小结的关键点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * 再次强调下：原始线程的上下文ClassLoader通常设定为用于加载应用程序的类加载器 * When callerCl is null, we should check the application's * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ //caller由Reflection.getCallerClass()得到，而调用方是java.sql.DriverManager，所以getClassLoader()是引导类加载器，也就是null //所以此处使用线程上下文加载器来加载实现类 ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException("The url cannot be null", "08001"); &#125; println("DriverManager.getConnection(\"" + url + "\")"); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. // isDriverAllowed中使用给定的加载器加载指定的驱动 if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(" trying " + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println("getConnection returning " + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(" skipping: " + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println("getConnection failed: " + reason); throw reason; &#125; println("getConnection: no suitable driver found for "+ url); throw new SQLException("No suitable driver found for "+ url, "08001");&#125; 总结&amp;扩展 双亲委派作为基本模型，隔离了不同的调用者，保证了程序的安全。 线程上线文加载器与其说破坏了双亲委派倒不如说是扩展了双亲委派的能力，使其有更好的通用性。 Tomcat、Jetty等Web容器都是基于双亲委派模型来做资源的隔离。 Spring在设计中也考虑到了类加载的问题，详细可见：org.springframework.web.context.ContextLoader.initWebApplicationContext(…)。 参考http://www.infocool.net/kb/Tomcat/201609/193323.htmlhttps://www.ibm.com/developerworks/cn/java/j-lo-classloader/http://github.thinkingbar.com/classloader/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[转-Servlet3-异步请求]]></title>
      <url>%2F2017%2F06%2F13%2F%E8%BD%AC-Servlet3-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[第22章 异步请求Servlet3.0规范新增了对异步请求的支持，Spring MVC也在此基础上对异步请求提供了方便。异步请求是在处理比较耗时的业务时先将request返回，然后另起线程处理耗时的业务，处理完后再返回给用户。 异步请求可以给我们带来很多方便，最直接的用法就是处理耗时的业务，比如，需要查询数据库、需要调用别的服务器来处理等情况下可以先将请求返回给客户端，然后启用新线程处理耗时业务，等处理完成后再将结果返回给用户。稍微扩展一下还可以实现订阅者模式的消息订阅功能，比如，当有异常情况发生时可以主动将相关信息发给运维人员，还有现在很多邮箱系统中收到新邮件的自动提示功能也是这种技术。甚至更进一步的使用方式是在浏览器上做即时通信的程序！HTTP协议是单向的，只能客户端自己拉不能服务器主动推，Servlet对异步请求的支持并没有修改HTTP协议，而是对Http的巧妙利用。异步请求的核心原理主要分为两大类，一类是轮询，另一类是长连接。轮询就是定时自动发起请求检查有没有需要返回的数据，这种方式对资源的浪费是比较大的；长连接的原理是在客户端发起请求，服务端处理并返回后并不结束连接，这样就可以在后面再次运回给客户端数据。Servlet对异步请求的支持其实采用的是长连接的方式，也就是说，异步请求中在原始的请求返回的时候并没有关闭连接，关闭的只是处理请求的那个线程（一般是回收的线程池里了），只有在异步请求全部处理完之后才会关闭连接。 22.1 Servlet3．O对异步请求的支持在Servlet3.0规范巾使用异步处理请求非常简单，只需要在请求处理过程中调用request的startAsync方法即可，其返回值是AsyncContext类型。 AsyncContext在异步请求中充当着非常重要的角色，可以称为异步请求上下文也可以称为异步请求容器，无论叫什么其实就是个名字，它的作用是保存与异步请求相关的所有信息，类似于Servlet中的ServletContext。异步请求主要是使用AsyncContext进行操作，它是在请求处理的过程中调用Request的startAsync方法返回的，需要注意的是多次调用startAsync方法返回的是同一个AsyncContext。AsyncContext接口定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142public interface AsyncContext &#123; static final String ASYNC_REQUEST_URI = "javax.servlet.async.request_uri"; static final String ASYNC_CONTEXT_PATH = "javax.servlet.async.context_path"; static final String ASYNC_PATH_INFO = "javax.servlet.async.path_info"; static final String ASYNC_SERVLET_PATH = "javax.servlet.async.servlet_path"; static final String ASYNC_QUERY_STRING = "javax.servlet.async.query_string"; public ServletRequest getRequest(); public ServletResponse getResponse(); public boolean hasOriginalRequestAndResponse(); public void dispatch(); public void dispatch(String path); public void complete(); public void start(Runnable run); public void addListener(AsyncListener listener); public void addListener(AsyncListener listener, ServletRequest servletRequest, ServletResponse servletResponse); public &lt;T extends AsyncListener&gt; T createListener(Class&lt;T&gt; clazz) throws ServletException; public void setTimeout(long timeout); public long getTimeout();&#125; 其中，getResponse方法用得非常多，它可以获取到response，然后就可以对response进行各种操作了；dispatch方法用于将请求发送到一个新地址，有三个重载实现方法，其中没有参数dispatch方法的会发送到request原来的地址（如果有forward则使用forward后的最后一个地址）．一个path参数的dispatch方法直接将path作为地址，两个参数的dispatch方法可以发送给别的应用指定的地址；complete方法用于通知容器请求已经处理完了；start方法用于启动实际处理线程．不过也可以自己创建线程在其中使用AsyncContext保存的信息(如response)进行处理；addListener用于添加监听器；setTimeout方法用于修改超时时间，因为异步请求一般耗时比较长，而正常的请求设置的有效时长一般比较短，所以在异步请求中很多时候都需要修改超时的时间。 22.1.1 Servlet 3.0处理异步请求实例使用Servlet 3.0处理异步请求需要三步：①配置Servlet时将async-supported设置为true；②在Servlet处理方法中调用Request的startAsync方法启动异步处理；③使用第2步中返同的AsyncContext处理异步请求。 要想使用Servlet 3.0异步请求的功能需要在配置Servlet时将async-supported设置为true，比如，配置一个叫WorkServlet的可以处理异步请求的Servlet。123456789&lt;servlet&gt; &lt;servlet-name&gt;WorkServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.excelib.servlet.WorkServlet&lt;/servlet-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;WorkServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/work&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 然后新建一个叫WorkServlet的Servlet，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.excelib.servlet;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.text.SimpleDateFormat;import java.util.*;public class WorkServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; // 设置contentType、关闭缓存 res.setContentType("text/plain;charset=UTF-8"); res.setHeader("Cache-Control", "private"); res.setHeader("Pragma", "no-cache"); // 原始请求可以做一些简单业务的处理 final PrintWriter writer = res.getWriter(); writer.println("老板检查当前需要做的工作"); writer.flush(); // jobs表示需要做的工作，使用循环模拟初始化 List&lt;String&gt; jobs = new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++)&#123; jobs.add("job"+i); &#125; // 使用request的startAsync方法开启异步处理 final AsyncContext ac = req.startAsync(); // 具体处理请求，内部处理启用了新线程，不会阻塞当前线程 doWork(ac, jobs); writer.println("老板布置完工作就走了"); writer.flush(); &#125; private void doWork(AsyncContext ac, List&lt;String&gt; jobs)&#123; // 设置超时时间1小时 ac.setTimeout(1*60*60*1000L); // 使用新线程具体处理请求 ac.start(new Runnable() &#123; @Override public void run() &#123; try &#123; // 从AsyncContext获取到Response进而获取到Writer PrintWriter w = ac.getResponse().getWriter(); for(String job:jobs)&#123; w.println("\""+job+"\"请求处理中。。。"); Thread.sleep(1 * 1000L); w.flush(); &#125; // 发出请求处理完成通知 ac.complete(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 这里的异步处理过程是在doWork方法中，它使用req．startAsync()返回的AsyncContext来处理的请求，处理完成后调用complete方法发出完成通知告诉容器请求已经处理完。doPost中除了startAsync和doWork外都是正常的操作，而且都有注释，就不解析了。当调用诸求时，返回页面结果如图22-1所示。 一个通过异步请求完成工作的示例程序就写完了。 22.1.2异步请求监听器AsyncListener上面的程序已经可以完成工作了，不过还不够完善。老板这个职业是需要思考宏观问题的，它需要宏观的数据，所以在干完活后最好给领导汇报一下什么时候干完的、干的怎么样、有没有出什么问题等综合性的数据，不过这些事情按照分工并不应该由实际干活的人来做，如果非让它们做就可能会影响效率，而且它们汇报的数据也有可能不真实，所以老板应该找专人来做这件事，这就有了二线人员。在Servlet异步请求中干这个活的二线人员就是AsyncListener监听器，AsyncListener定义如下：1234567891011public interface AsyncListener extends EventListener &#123; public void onComplete(AsyncEvent event) throws IOException; public void onTimeout(AsyncEvent event) throws IOException; public void onError(AsyncEvent event) throws IOException; public void onStartAsync(AsyncEvent event) throws IOException; &#125; onComplete方法在请求处理完成后调用，onTimeout方法在超时后调用，onError方法在出错时调用，onStartAsync方法在Request调用startAsync方法启动异步处理时调用。 这里需要注意的是只有在调用request.startAsync前将监听器添加到AsyncContext，监听器的onStartAsync方法才会起作用，而调用startAsync前AsyncContext还不存在，所以第一次调用startAsync是不会被监听器中的onStartAsync方法捕获的，只有在超时后又重新开始的情况下onStartAsync方法才会起作用。这一般也没有什么太大的问题，就像上面的例子中开始的时候是老板安排的任务，他自己当然知道，所以不汇报也没关系，不过如果到了时间节点任务没完成又重新开始了那还是要汇报的。 我们给前面的WorkServlet添加两个AsyncListener监听器BossListener和LeaderListener．一个用来给老板汇报，另一个用来给项目负责人汇报，它们都是定义在WorkServlet中的私有类，而且代码也都一样，其中BossListener的代码如下：1234567891011121314151617181920private class BossListener implements AsyncListener &#123; final SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); @Override public void onComplete(AsyncEvent event) throws IOException &#123; System.out.println("在" + formatter.format(new Date()) + "工作处理完成"); &#125; @Override public void onError(AsyncEvent event) throws IOException &#123; System.out.println("在" + formatter.format(new Date()) + "工作处理出错，详情如下：\t" +event.getThrowable().getMessage()); &#125; @Override public void onStartAsync(AsyncEvent event) throws IOException &#123; System.out.println("在" + formatter.format(new Date()) + "工作处理开始"); &#125; @Override public void onTimeout(AsyncEvent event) throws IOException &#123; System.out.println("在" + formatter.format(new Date()) + "工作处理超时"); &#125;&#125; 然后将监听器注册到WorkServlet中，注册方法是在获取到AsyncContext后将监听器添加进去，相关代码如下：123456789// 使用request的startAsync方法开启异步处理final AsyncContext ac = req.startAsync();// 添加两个监听器ac.addListener(new BossListener());ac.addListener(new LeaderListener(), req, res);// 具体处理请求，内部处理启用了新线程，不会阻塞当前线程doWork(ac, jobs);writer.println("老板布置完工作就走了");writer.flush(); 这样就将两个监听器注册完了。这里之所以添加了两个监听器，是要告诉大家一个AsyncContext可以添加多个监听器，而且有两个重载的添加方法。在监听器中可以使用AsyncEvent事件获取Request、Response以及在有异常的时候获取Throwable，代码如下：123event.getSuppliedRequest();event.getSuppliedReponse();event.getThrowable(); ##22.2 Spring MVC中的异步请求 Spring MVC为了方便使用异步请求专门提供了AsyncWebRequest类型的request，并且提供了处理异步请求的管理器WebAsyncManager和工具WebAsyncUtils。 Spring MVC将异步请求细分为了Callable、WebAsyncTask、DeferredResult和ListenableFuture四种类型。前两种是一类，它们的核心是Callable，这一类很容易理解，因为大家对Callable应该都比较熟悉；DeferredResult类可能不是很容易理解，因为它是Spring MVC自己定义的类型，我们平时可能没使用过，而且相关资料也不多，所以刚接触的时候会觉得不知道从哪里人手，不过弄明白后其实是非常简单的；ListenableFuture足Spring MVC4.0新增的，它在Java的Future基础上增加了设置回调方法的功能，主要用于需要在处理器中调用别的资源（如别的url）的情况，Spring MVC专门提供了AsyncRestTemplate方法调用别的资源，并返回ListenableFuture类型。 本章先分析Spring MVC中异步请求使用到的组件，然后分析Spring MVC是怎么使用这些组件处理异步请求的，最后再分别对每一类返回值进行介绍。 22.2.1 Spring MVC中异步请求相关组件这里主要分析AsyncWebRequest、WebAsyncManager和WebAsyncUtils组件。WebAsyncManager里面还包含了一些别的组件，在分析的过程中也一起分析。AsyncWebRequest首先来看AsyncWebRequest，它是专门用来处理异步请求的request，定义如下：1234567891011121314151617public interface AsyncWebRequest extends NativeWebRequest &#123; void setTimeout(Long timeout); void addTimeoutHandler(Runnable runnable); void addCompletionHandler(Runnable runnable); void startAsync(); boolean isAsyncStarted(); void dispatch(); boolean isAsyncComplete();&#125; 其中，addTimeoutHandler方法和addCompletionHandler方法分别用于添加请求超时和请求处理完成的处理器，其作用相当于AsyncListener监听器中的onTimeout和onComplete方法；isAsyncStarted方法用于判断是否启动了异步处理；isAsyncComplete方法用于判断异步处理是否已经处理完了。别的方法都与AsyncContext中的同名方法作用一样，就不一一解释了。它的实现类有两个，一个是NoSupportAsyncWebRequest，另一个是StandardServletAsyncWebRequest，前者不支持异步请求，所以在Spring MVC中实际用作异步请求的request是StandardServletAsync WebRequest. StandardServletAsyncWebRequest除了实现了AsyncWebRequest接口，还实现了AsyncListener接口，另外还继承了ServletWebRequest，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class StandardServletAsyncWebRequest extends ServletWebRequest implements AsyncWebRequest, AsyncListener &#123; private Long timeout; private AsyncContext asyncContext; private AtomicBoolean asyncCompleted = new AtomicBoolean(false); private final List&lt;Runnable&gt; timeoutHandlers = new ArrayList&lt;Runnable&gt;(); private final List&lt;Runnable&gt; completionHandlers = new ArrayList&lt;Runnable&gt;(); /** * Create a new instance for the given request/response pair. * @param request current HTTP request * @param response current HTTP response */ public StandardServletAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) &#123; super(request, response); &#125; /** * &#123;@inheritDoc&#125; * &lt;p&gt;In Servlet 3 async processing, the timeout period begins after the * container processing thread has exited. */ @Override public void setTimeout(Long timeout) &#123; Assert.state(!isAsyncStarted(), "Cannot change the timeout with concurrent handling in progress"); this.timeout = timeout; &#125; @Override public void addTimeoutHandler(Runnable timeoutHandler) &#123; this.timeoutHandlers.add(timeoutHandler); &#125; @Override public void addCompletionHandler(Runnable runnable) &#123; this.completionHandlers.add(runnable); &#125; @Override public boolean isAsyncStarted() &#123; return ((this.asyncContext != null) &amp;&amp; getRequest().isAsyncStarted()); &#125; /** * Whether async request processing has completed. * &lt;p&gt;It is important to avoid use of request and response objects after async * processing has completed. Servlet containers often re-use them. */ @Override public boolean isAsyncComplete() &#123; return this.asyncCompleted.get(); &#125; @Override public void startAsync() &#123; Assert.state(getRequest().isAsyncSupported(), "Async support must be enabled on a servlet and for all filters involved " + "in async request processing. This is done in Java code using the Servlet API " + "or by adding \"&lt;async-supported&gt;true&lt;/async-supported&gt;\" to servlet and " + "filter declarations in web.xml."); Assert.state(!isAsyncComplete(), "Async processing has already completed"); if (isAsyncStarted()) &#123; return; &#125; this.asyncContext = getRequest().startAsync(getRequest(), getResponse()); this.asyncContext.addListener(this); if (this.timeout != null) &#123; this.asyncContext.setTimeout(this.timeout); &#125; &#125; @Override public void dispatch() &#123; Assert.notNull(this.asyncContext, "Cannot dispatch without an AsyncContext"); this.asyncContext.dispatch(); &#125; // --------------------------------------------------------------------- // Implementation of AsyncListener methods // --------------------------------------------------------------------- @Override public void onStartAsync(AsyncEvent event) throws IOException &#123; &#125; @Override public void onError(AsyncEvent event) throws IOException &#123; &#125; @Override public void onTimeout(AsyncEvent event) throws IOException &#123; for (Runnable handler : this.timeoutHandlers) &#123; handler.run(); &#125; &#125; @Override public void onComplete(AsyncEvent event) throws IOException &#123; for (Runnable handler : this.completionHandlers) &#123; handler.run(); &#125; this.asyncContext = null; this.asyncCompleted.set(true); &#125;&#125; 这里的代码比较长，不过很容易理解，它里面封装了个AsyncContext类型的属性asyncContext，在startAsync方法中会将Request#startAsync返回的AsyncContext设置给它，然后在别的地方主要使用它来完成各种功能。 另外，南于StandardServletAsyncWebRequest实现了AsyncListener接口，所以它自己就是一个监听器，而且在startAsync方法中在创建出AsyncContext后会将自己作为监听器添加进去。监听器实现方法中onStartAsync方法和onError方法是空实现，onTimeout方法和onComplete方法分别调用了封装的两个List类型的属性timeoutHandlers和completionHandlers所保存的Runnable方法，这样在使用时只需要简单地将需要监听超时和处理完成的监听方法添加到这两个属性中就可以了。 WebAsyncManager WebAsyncManager是Spring MVC处理异步请求过程中最核心的类，它管理着整个异步处理的过程。 WebAsyncManager中最重要的两个方法是startCallableProcessing和startDeferredResultProcessing，这两个方法是启动异步处理的人口方法，它们一共做了三件事：①启动异步处理；②给Request设置相应属性（主要包括timeout、timeoutHandler和completionHandler）；③在相应位置调用相应的拦截器。这里的拦截器是Spring MVC自己定义的。 startCallableProcessing方法用于处理Callable和WebAsyncTask类型的异步请求，使用的拦截器类型是CallableProcessingInterceptor，拦截器封装在CallablelnterceptorChain粪型的拦截器链中统一调用。 startDeferredResultProcessing方法用于处理DeferredResult和ListenableFuture类型的异步请求，使用的拦截器是DeferredResultProcessinglnterceptor拦截器，拦截器封装在DeferredResultlnterceptorChain类型的拦截器链中统一调用。 这两个拦截器的定义如下：1234567891011121314151617public interface CallableProcessingInterceptor &#123; static final Object RESULT_NONE = new Object(); static final Object RESPONSE_HANDLED = new Object(); &lt;T&gt; void beforeConcurrentHandling(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception; &lt;T&gt; void preProcess(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception; &lt;T&gt; void postProcess(NativeWebRequest request, Callable&lt;T&gt; task, Object concurrentResult) throws Exception; &lt;T&gt; Object handleTimeout(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception; &lt;T&gt; void afterCompletion(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception;&#125; 拦截器的作用就是在不同的时间点通过执行相应的方法来做一些额外的事情，所以要学习一种拦截器主要就是要理解它里边的各个方法执行的时间点。这两拦截器都定义了5个方法，方法名也都一样，而且从名字就很容易理解它们执行的时间点，就不分别解释了。需要注意的是，beforeConcurrentHandling方法是在并发处理前执行的，也就是会在主线程中执行，其他方法都在具体处理请求的子线程中执行。 CallableInterceptorChain和DeferredResultlnterceptorC hain分别用于封装两个Interceptor，它们都是将多个相应的拦截器封装到一个List类型的属性，然后在相应的方法中调用所封装的Interceptor相应方法进行处理。大家是不是很熟悉？它跟前面多次便用的XXXComposite组件类似，也是责任链模式。不过和XXXComposite组件不同的是，这里的方法名与Interceptor中稍有区别，它们的对应关系如下： applyBe foreConcurrentHandling：对应Interceptor中的beforeConcurrentHandling方法。 applyPreProcess：对应Interceptor中的preProcess方法。 applyPostProcess：对应Interceptor中的postProcess方法。 triggerAfterTimeout:对应Interceptor中的afierTimeout方法。 triggerAfterCompletion：对应Interceptor中的afterCompletion方法。 理解了这些方法就知道Interceptor和InterceptorChain的作用了，它们都是在WebAsyncManager中相应位置调用的。 在正式分析WebAsyncManager前再看一下WebAsyncTask类，只有理解了这个类才能看明白WebAsyncManager中酌stariCallableProcessing方法。WebAsyncTask的作用主要是封装Callable方法，并且提供了一些异步调用相关的属性，理解了其中包含的属性就明白这个类了，其中属性定义如下：12345678910111213private final Callable&lt;V&gt; callable;private Long timeout;private AsyncTaskExecutor executor;private String executorName;private BeanFactory beanFactory;private Callable&lt;V&gt; timeoutCallback;private Runnable completionCallback; callable用来实际处理请求；timeout用来设置超时时间；executor用来调用callable；executorName用来用容器中注册的名字配置executor；beanFactory用于根据名字获取executor; timeoutCallback相completionCallback分别用于执行超时和请求处理完成的回调。 这里的executor可以直接设置到WebAsyncTask中，也可以使用注册在容器中的名字来设置executorName属性，如果是使用名字来设置的WebAsyncTask的getExecutor方法会从beanFactory中根据名字executorName获取AsyncTaskExecutor，代码如下：123456789101112public AsyncTaskExecutor getExecutor() &#123; if (this.executor != null) &#123; return this.executor; &#125; else if (this.executorName != null) &#123; Assert.state(this.beanFactory != null, "BeanFactory is required to look up an executor bean by name"); return this.beanFactory.getBean(this.executorName, AsyncTaskExecutor.class); &#125; else &#123; return null; &#125;&#125; 多知道点 如何在Java中使用并发处理 并发处理是通过多线程完成的，在Java中定义一个多线程的任务可以通过实现Runnable或者Callable接口完成，先来看一下Runnable接定义如下：123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; Runnable里只有一个run方法，我们只需要将需要执行的代码放到里面即可，行需要新建一个线程来调用，示例如下：12345678Runnable task = new Runnable()&#123; @Override public void run() System.out.println("do task"); &#125; Thread thread = new Thread(task); thread.start();&#125; 这里新建了task的Runnable类型任务，然后使用它创建了Thread并调用start方法执行了任务。需要说明的是，Thread本身也继承了Runnable接口，所以直接使用Thread来创建Runnable类型的任务然后执行，比如，上面的代码可以修改为：1234567new Thread()&#123; @Override public void run() &#123; System.out.println("do task"); &#125;&#125;.start(); 这样一句代码就可以完成了。 在JavaI.5中新增了Callable接口，定义如下：123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Callable里面是call方法，而且可以有返回值还可以处理异常。Callable的执行需要有一个Executor容器来调用，就像Runnable任务需要Thread来调用一样，而且Executor也可以调用Runnable类型的任务。ExecutoriB用后会返回一个Future类型的返回值，我们可以调用Future的get方法来获取Callable中call方法的返回值，不过这个方法是阻塞的，只有call方法执行完后才会返回，示例如下：1234567891011121314ExecutorsService = Executors.newCachedThreadPool();Callable callableTask = new Callable&lt;String&gt;() &#123; public String call() throws Exception&#123; Thread.sleep(1000); System.out.println("do task"); return "ok"; &#125;&#125;;Future&lt;String&gt; future = executor.submit(callableTask);System.out.println("after submit task");String result = future.get();System.out.println("after future.get()");System.out.println("result="+result);executor.shudown(); 这里定义了一个Callable类型的callableTask任务，在其call方法中会等待1秒然后输出dotask并返回ok。Executor调用submit方法提交任务后主程序输出aftersubmittask，这个应该在异步任务返回之前输出，因为方法需要等待1秒，输出aftersubmittask后调用future.get()，这时主线程会阻塞,直到call方法返回，然后输出”afterfuture.get()”，最后输出call返回的结果”ok”，程序运行后控制台打印如下： after submit taskdo taskafter future.get()result=ok 下面来看WebAsyncManager，首先介绍它里面的几个重要属性： timeoutCallablelnterceptor：CallableProcessinglnterceptor类型,专门用于Callable和WebAnsyncTask类型超时的拦截器 timeoutDeferredResultlnterceptor：DeferredResultProcessinglnterceptor类型，专门用于DeferredResult和ListenableFuture类型超时的拦截器。 callablelnterceptors: Map类型，用于所有Callable和WebAsyncTask类型的拦截器。 deferredResultlnterceptors：Map类型，用于所有DeferredResult和ListenableFuture类型的拦截器。 asyncWebRequest：为了支持异步处理而封装的request。 taskExecutor：用于执行Callable和WebAsyncTask类型处理，如果WebAsyncTask中没有定义executor则使用WebAsyncManager中的taskExecutor。 下面分析WebAsyncManager里最核心的两个方法startCallableProcessing和startDeferredResultProcessing，这两个方法的逻辑基本一样，选择其中的startCallableProcessing来分析，这个方法用于启动Callable和WebAsyncTask类型的处理，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Use the given &#123;@link WebAsyncTask&#125; to configure the task executor as well as * the timeout value of the &#123;@code AsyncWebRequest&#125; before delegating to * &#123;@link #startCallableProcessing(Callable, Object...)&#125;. * @param webAsyncTask a WebAsyncTask containing the target &#123;@code Callable&#125; * @param processingContext additional context to save that can be accessed * via &#123;@link #getConcurrentResultContext()&#125; * @throws Exception if concurrent processing failed to start */ public void startCallableProcessing(final WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext) throws Exception &#123; Assert.notNull(webAsyncTask, "WebAsyncTask must not be null"); Assert.state(this.asyncWebRequest != null, "AsyncWebRequest must not be null"); Long timeout = webAsyncTask.getTimeout(); if (timeout != null) &#123; this.asyncWebRequest.setTimeout(timeout); &#125; AsyncTaskExecutor executor = webAsyncTask.getExecutor(); if (executor != null) &#123; this.taskExecutor = executor; &#125; List&lt;CallableProcessingInterceptor&gt; interceptors = new ArrayList&lt;CallableProcessingInterceptor&gt;(); interceptors.add(webAsyncTask.getInterceptor()); interceptors.addAll(this.callableInterceptors.values()); interceptors.add(timeoutCallableInterceptor); final Callable&lt;?&gt; callable = webAsyncTask.getCallable(); final CallableInterceptorChain interceptorChain = new CallableInterceptorChain(interceptors); this.asyncWebRequest.addTimeoutHandler(new Runnable() &#123; @Override public void run() &#123; logger.debug("Processing timeout"); Object result = interceptorChain.triggerAfterTimeout(asyncWebRequest, callable); if (result != CallableProcessingInterceptor.RESULT_NONE) &#123; setConcurrentResultAndDispatch(result); &#125; &#125; &#125;); this.asyncWebRequest.addCompletionHandler(new Runnable() &#123; @Override public void run() &#123; interceptorChain.triggerAfterCompletion(asyncWebRequest, callable); &#125; &#125;); interceptorChain.applyBeforeConcurrentHandling(this.asyncWebRequest, callable); startAsyncProcessing(processingContext); this.taskExecutor.submit(new Runnable() &#123; @Override public void run() &#123; Object result = null; try &#123; interceptorChain.applyPreProcess(asyncWebRequest, callable); result = callable.call(); &#125; catch (Throwable ex) &#123; result = ex; &#125; finally &#123; result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result); &#125; setConcurrentResultAndDispatch(result); &#125; &#125;); &#125; 通过注释可以看到startCallableProcessing方法主要做了5件事：①将webAsyncTask中相关属性取出并设置到对应的地方；②初始化拦截器链；③给asyncWebRequest设置timeoutHandler和completionHandler；④执行处理器链中相应方法；⑤启动异步处理并使用taskExecutor提交任务。 对其中的启动处理和执行处理详细解释一下，启动处理是调用了startAsyncProcessing方法，其中做了三件事：①调用clearConcurrentResult方法清空之前并发处理的结果；②谰用asyncWebRequest的startAsync方法启动异步处理；③将processingContext设置给concurrentResultContext属性。startAsyncProcessing方法的代码如下：123456789101112131415161718192021private void startAsyncProcessing(Object[] processingContext) &#123; clearConcurrentResult(); this.concurrentResultContext = processingContext; this.asyncWebRequest.startAsync(); if (logger.isDebugEnabled()) &#123; HttpServletRequest request = this.asyncWebRequest.getNativeRequest(HttpServletRequest.class); String requestUri = urlPathHelper.getRequestUri(request); logger.debug("Concurrent handling starting for " + request.getMethod() + " [" + requestUri + "]"); &#125;&#125;/** * Clear &#123;@linkplain #getConcurrentResult() concurrentResult&#125; and * &#123;@linkplain #getConcurrentResultContext() concurrentResultContext&#125;. */public void clearConcurrentResult() &#123; this.concurrentResult = RESULT_NONE; this.concurrentResultContext = null;&#125; processingContext参数传进来的是处理器中使用的ModelAndViewContainer，concurrentResultContext用来在WebAsyncManager中保存ModelAndViewContainer，在请求处理完成后会设置到RequestMappingHandlerAdapter中，具体过程后面再分析。 下面再来说一下执行处理，执行处理使用的是taskExecutor，不过需要注意的是，这里并没直接使用taskExecutor.submit(callable)来提交，而是提交了新建的Runnable，并将Callable的call方法直接放在run方法里调用。代码如下：1234567891011121314151617this.taskExecutor.submit(new Runnable() &#123; @Override public void run() &#123; Object result = null; try &#123; interceptorChain.applyPreProcess(asyncWebRequest, callable); result = callable.call(); &#125; catch (Throwable ex) &#123; result = ex; &#125; finally &#123; result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result); &#125; setConcurrentResultAndDispatch(result); &#125; &#125;); 这么做主要有两个作用：①可以在处理过程中的相应位置调用拦截器链中相应的方法；②在call方法执行完之前不会像Future#get()那样阻塞线程。 不过Runnable是没有返回值的，所以Callable处理的结果需要自己从run方法内部传递出来，WebAsyncManager中专门提供了一个setConcurrentResultAndDispatch方洪来处理返回的结果，这里边会将处理的结果传递出来，代码如下：1234567891011121314151617181920private void setConcurrentResultAndDispatch(Object result) &#123; synchronized (WebAsyncManager.this) &#123; if (hasConcurrentResult()) &#123; return; &#125; this.concurrentResult = result; &#125; if (this.asyncWebRequest.isAsyncComplete()) &#123; logger.error("Could not complete async processing due to timeout or network error"); return; &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Concurrent result value [" + this.concurrentResult + "] - dispatching request to resume processing"); &#125; this.asyncWebRequest.dispatch();&#125; concurrentResult是WebAsyncManager中用来保存异步处理结果的属性，hasConcurrentResult方法用来判断concurrentResult是否已经存在返回值。整个方法过程是：如果concurrentResult已经有返回值则直接返回，否则将传人的参数设置到concurrentResult，然后调用asyncWebRequest.isAsyncComplete()检查Request是否已设置为异步处理完成状态（网络中断会造成Request设置为异步处理完成状态），如果是则保存错误日志并返回，否则调用asyncWebRequest.dispatch0发送请求。SpringMVC申异步请求处理完成后会再次发起一个相同的请求，然后在HandlerAdapter中使用一个特殊的HandlerMethod来处理它，具体过程后面再讲解，不过通过Request的dispatch方法发起的请求使用的还是原来的Request，也就是说原来保存在Request中的属性不会丢失。 startDeferredResultProcessing方法和startCallableProcessing方法执行过程类似，只是并没有使用taskExecutor来提交执行，这是因为DeferredResult并不需要执行处理，在后面讲了DeferredResult的用法后大家就明白了。 WebAsyncManager就分析到这里，下面来看WebAsyncUtils。 WebAsyncUtils WebAsyncUtils里面提供了四个静态方法，其中一个是private权限，只供内部调用的，也就是一共提供了三个供外部使用的静态方法。它们定义如下： public static WebAsyncManager getAsyrtcManager (ServletRequest servletRequest) public static WebAsyncManager getAsyncManager (WebRequest webRequest) `public static AsyncWebRequest createAsyncWebRequest (HttpServletRequest request, HttpServletResponse response) 两重载的getAsyncManager方法通过Request获取WebAsyncManager，它们一个使用ServletRequest类型的Request，一个使用WebRequest类型的Request，获取过程都是先判断Request属性里是否有保存的WebAsyncManager对象，如果有则取出后直接返回，如果没有则新建一个设置到Request的相应属性中并返回，下次再获取时直接从Request属性中取出。 createAsyncWebRequest方法用于创建AsyncWebRequest，它使用ClassUtils.hasMethod判断传人的Request是否包含startAsync方法从而判断是否支持异步处理，如果不支持则新建NoSupportAsyncWebRequest类型的Request并返回，如果支持则调用createStandardServletAsyncWebRequest方法创建StandardServletAsync WebRequest类型的Request并返回。 22.2.2 Spring MVC对异步请求的支持Spring MVC对异步请求的处理主要在四个地方进行支持，详述如下：1)FrameworkServlet中给当前请求的WebAsyncManager添加了CallableProcessinglnterceptor类型的拦截器RequestBindinglnterceptor，这是定义在FrameworkServlet内部的一个私有的拦截器，其作用还是跟FrameworkServlet处理正常请求一样，在请求处理前将当前请求的LocaleContext和ServletRequestAttributes设置到了LocaleContextHolder和RequestContextHolder中，并在请求处理完成后恢复，添加过程在processRequest方法中，相关代码如下：123456789101112131415161718192021WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());private class RequestBindingInterceptor extends CallableProcessingInterceptorAdapter &#123; @Override public &lt;T&gt; void preProcess(NativeWebRequest webRequest, Callable&lt;T&gt; task) &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); if (request != null) &#123; HttpServletResponse response = webRequest.getNativeRequest(HttpServletResponse.class); initContextHolders(request, buildLocaleContext(request), buildRequestAttributes(request, response, null)); &#125; &#125; @Override public &lt;T&gt; void postProcess(NativeWebRequest webRequest, Callable&lt;T&gt; task, Object concurrentResult) &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); if (request != null) &#123; resetContextHolders(request, null, null); &#125; &#125;&#125; 2) RequestMappingHandlerAdapter酌invokeHandleMethod方法提供了对异步请求的核心支持，其中做了四件跟异步处理相关的事情： 创建AsyncWebRequest并设置超时时间，具体时间可以通过asyncRequestTimeout属性配置到RequestMappingHandlerAdapter申。 对当前请求的WebAsyncManager设置了四个属性：taskExecutor,asyncWebRequest,callablelnterceptors和deferredResultlnterceptors，除了asyncWebRequest的另外三个都可以在RequestMappingHandlerAdapter中配置，taskExecutor如果没配置将默认使用SimpleAsyncTaskExecutor。 如果当前请求是异步请求而且已经处理出了结果，则将异步处理结果与之前保存到WebAsyncManager里的ModeIAnd\fiewContainer取出来,并将WebAsyncManager里的结果清空，然后调用ServletlnvocableHandlerMethod的wrapConcurrentResult方法创建ConcurrentResultHandlerMethod类型（ServletlnvocableHandlerMethod的内部类）的ServletlnvocableHandlerMethod来替换自己，创建出来的ConcurrentResultHandlerMethod并不执行请求，它的主要功能是判断异步处理的结果是不是异常类型，如果是则抛出，如果不是则使用ReturnValueHandler对其进行解析并返回。 如果requestMappingMethod的invokeAndHandle方法执行完后检查到当前请求已经启动了异步处理，则会直接返回null。 RequestMappingHandlerAdapter中相关代码如下：12345678910111213141516171819202122232425AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);asyncWebRequest.setTimeout(this.asyncRequestTimeout);final WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);asyncManager.setTaskExecutor(this.taskExecutor);asyncManager.setAsyncWebRequest(asyncWebRequest);asyncManager.registerCallableInterceptors(this.callableInterceptors);asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); if (logger.isDebugEnabled()) &#123; logger.debug("Found concurrent result value [" + result + "]"); &#125; requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);&#125;requestMappingMethod.invokeAndHandle(webRequest, mavContainer);if (asyncManager.isConcurrentHandlingStarted()) &#123; return null;&#125; 这里的步骤3是调用了ServletInvocableHandlerMethod的wrapConcurrentResult方法创建了新的ServletlnvocableHandlerMethod来处理异步处理的结果，代码如下：123ServletInvocableHandlerMethod wrapConcurrentResult(Object result) &#123; return new ConcurrentResultHandlerMethod(result, new ConcurrentResultMethodParameter(result)); &#125; ConcurrentResultHandlerMethod是在ServletlnvocableHandlerMethod中定义的继承白ServletInvocableHandlerMethod的内部类，代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static final Method CALLABLE_METHOD = ClassUtils.getMethod(Callable.class, "call");private class ConcurrentResultHandlerMethod extends ServletInvocableHandlerMethod &#123; private final MethodParameter returnType; public ConcurrentResultHandlerMethod(final Object result, ConcurrentResultMethodParameter returnType) &#123; super(new Callable&lt;Object&gt;() &#123; @Override public Object call() throws Exception &#123; if (result instanceof Exception) &#123; throw (Exception) result; &#125; else if (result instanceof Throwable) &#123; throw new NestedServletException("Async processing failed", (Throwable) result); &#125; return result; &#125; &#125;, CALLABLE_METHOD); setHandlerMethodReturnValueHandlers(ServletInvocableHandlerMethod.this.returnValueHandlers); this.returnType = returnType; &#125; /** * Bridge to actual controller type-level annotations. */ @Override public Class&lt;?&gt; getBeanType() &#123; return ServletInvocableHandlerMethod.this.getBeanType(); &#125; /** * Bridge to actual return value or generic type within the declared * async return type, e.g. Foo instead of &#123;@code DeferredResult&lt;Foo&gt;&#125;. */ @Override public MethodParameter getReturnValueType(Object returnValue) &#123; return this.returnType; &#125; /** * Bridge to controller method-level annotations. */ @Override public &lt;A extends Annotation&gt; A getMethodAnnotation(Class&lt;A&gt; annotationType) &#123; return ServletInvocableHandlerMethod.this.getMethodAnnotation(annotationType); &#125;&#125; ConcurrentResultHandlerMethod调用父类的构造方法(super)将HandlerMethod中的Handler和Method都替换掉了，Handler用了新建的匿名Callable，Method使用了ServletInvocableHandlerMethod酌静态属性CALLABLE—METHOD，它代码Callable的call方法。新建的Callable的执行逻辑也非常简单，就是判断异步处理的返回值是不是异常类型，如果是则抛出异常，不是则直接返回，然后使用和原来请求一样的返回值处理器处理返回值（因为在构造方法中将原来ServletjnvocableHandlerMethod的返回值处理器设置给了自己）。 3)返回值处理器：一共有四个处理异步请求的返回值处理器，它们分别是AsyncTaskMethodReturnValueHandler、CallableMethodReturnValueHandler、De ferredResultMethodReturn ValueHandler和ListenableFutureReturnValueHandler，每一个对应一种类型的返回值，它们的作用主要是使用WebAsyncManager启动异步处理，后面依次对每一类返回值进行分析。 4)在DispatcherServlet的doDispatch方法中，当HandlerAdapter使用Handler处理完请求耐，会检查是否已经启动了异步处理，如果启动了则不再往下处理，直接返回，相关代码如下：123456// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler());if (asyncManager.isConcurrentHandlingStarted()) &#123; return;&#125; 检查方法是调用的WebAsyncManager的isConcurrentHandlingStarted方法，其实内部就是调用的request的isAsyncStarted方法，代码如下：1234567891011/** * Whether the selected handler for the current request chose to handle the * request asynchronously. A return value of "true" indicates concurrent * handling is under way and the response will remain open. A return value * of "false" means concurrent handling was either not started or possibly * that it has completed and the request was dispatched for further * processing of the concurrent result. */public boolean isConcurrentHandlingStarted() &#123; return ((this.asyncWebRequest != null) &amp;&amp; this.asyncWebRequest.isAsyncStarted());&#125; Spring MVC中跟异步请求处理相关的四个位置孰分析完了。主要处理流程是这样的：首先在处理器中返回需要启动异步处理的类型时（四种类型）相应返同值处理器会调用WebAsyncManager的相关方法启动异步处理，然后在DispatcherServlet中将原来请求直接返回，当异步处理完成后会重新发出一个相同的请求，这时在RequestMappingHandlerAdapter中会使用特殊的ServletlnvocableHandlerMethod来处理请求，处理方法是：如果异步处理返回的结果是异常类型则抛出异常，否则直接返回异步处理结果，然后使用返回值处理器处理，接着返回DispatcherServlet中按正常流程往下处理。 异步处理完成后会重新发起一个请求，这时会重新查找HandlerMethod并初始化PathVariable、MatrixVariable等参数，重新初始化Model中的数据并再次执行Handler-Interceptor中相应的方法。这么做主要是可以复用原来的那套组件进行处理而不需要重新定义。不过新请求的HandlerMethod是用的专门的类型，而Model是使用的原来保存在WebAsyncManager的concurrentResultContext届性中的ModelAndViewContainer所保存的Model，所以这里的查找HandlerMethod和初始化Model的过程是没用的，在这里可以进行一些优化，比如，将创建ConcurrentResultHandlerMethod的过程放在HandlerMapping中（这样也更符合组件的功能），然后在调用ModeIFactory的initModel方法前判断是不是异步处理dispatcher过来的请求，如果是则不再初始化了，或者干脆创建新的HandlerAdapter来处理。 除了上述可以优化的地方，这里还有两个漏洞，第一个是相应的拦截器里的方法会被调用两次，这是不合适的，而且有的时候还会出问题，比如，如果用了拦截器来检查Token．那么第一次检查通过后就会将相应内容删除，第二次再检查的时候就检查失败了，这就有问题了。第二个是通过FlashMap传递Redirect参数的情况，在前面分析FlashMapManager获取FlashMap的时候说过，每次获取后就会将相应的FlashMap删除，但异步请求会获取两次，如果异步处理器是Redirect刭的结果处理器，并且使用FlashMap传递了参数，这种情况下如果在第二次获取FlashMap的时候（异步请求处理完了）正好用户又发了一个相同的请求，而且RedirectView已经将FlashMap设置到了Session，在获取之前可能被前面的请求获取删除，导致自己获取不到，这么说不容易理解，下面将两个请求的处理过程列出来大家就容易理解了： 请求1 请求2 saveOutputFlashMap 设置FM1 retrieveAndUpdate 获取到FM1 saveOutputFlashMap 设置FM2 retrieveAndUpdate 获取到FM2 retrieveAndUpdate 获取到null retrieveAndUpdate 获取到null 这样请求2设置的FlashMap就会被请求1的第二次retrieveAndUpdate获取到并从Session中删除，请求2就获取不到了，这样两个请求的值就都出了问题了。 这里的第二个漏洞只是从原理上来说存在，一般不会造成什么影响，因为这种情况发生的概率非常小，但第一个漏洞是比较严重的，如果真正使用了类似判断Token等的拦截器需要在具体方法内部自己处理一下。 异步处理流程就说到这里，下面分析每一类返回值的具体处理过程。 22.2.3 WebAsyncTask和Calla ble类型异步请求的处理过程及用法当处理器方法返回WebAsyncTask或Callable类型时将自动启用异步处理。下面来看一下处理WebAsyncTask类型返回值的处理器AsyncTaskMethodReturnValueH andler．它的handleReturnValue方法如下：12345678910111213@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; WebAsyncTask&lt;?&gt; webAsyncTask = (WebAsyncTask&lt;?&gt;) returnValue; webAsyncTask.setBeanFactory(this.beanFactory); WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(webAsyncTask, mavContainer);&#125; 如果返回值为null，就会给mavContainer设置为请求已处理，然后返回。如果返回值不为null，调用WebAsyncManager的startCallableProcessing方法处理请求。WebAsyncManager是使用WebAsyncUtils获取的。下面来看一个例子，首先给配置Spring MVC的Servlet添加异步处理支持，也就是添加async-supported属性，代码如下：123456789&lt;servlet&gt; &lt;servlet-name&gt;let'sGo&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/let'sGo-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt; 接下来写一个AsyncController，代码如下:123456789101112131415161718192021222324252627package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Controllerpublic class AsyncController &#123; @ResponseBody @RequestMapping(value = "/webasynctask",produces = "text/plain; charset=UTF-8") public WebAsyncTask&lt;String&gt; webAsyncTask()&#123; System.out.println("WebAsyncTask处理器主线程进入"); WebAsyncTask&lt;String&gt; task = new WebAsyncTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5*1000L); System.out.println("WebAsyncTask处理执行中。。。"); return "久等了"; &#125; &#125;); System.out.println("WebAsyncTask处理器主线程退出"); return task; &#125;&#125; 这里新建了WebAsyncTask，并使用匿名类建了Callable进行异步处理，实际使用中可以在其中写数据库请求等耗时的业务，这里直接等了5秒来模拟。处理器注释了@ResponseBody，其返回值会直接返回给浏览器。当调用http://localhost:8080/ webasynctask时，会在等待大约5秒后返回给浏览器久等了三个字。 现在再返回去看WebAsyncManager的startCallableProcessing方法就容易理解了，其实就是先添加拦截器，并在相应的地方执行拦截器里的方法，最后使用taskExecutor调用返回WebAsyncTask申的Callable处理。 当然这里只是给WebAsyncTask设置了Callable，除此之外还可以设置executor、timeout、timeoutCallback和completionCallback等属性。 Callable的处理其实是在WebAsyncManager内部封装成WebAsyncTask后再处理的。当处理器中返回Callable类型的返回值时，Spring MVC会使用CallableMethodReturnValueHandler来处理返回值，它的handleReturnValue方法代码如下：123456789101112131415161718192021public class CallableMethodReturnValueHandler implements HandlerMethodReturnValueHandler &#123; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return Callable.class.isAssignableFrom(returnType.getParameterType()); &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; Callable&lt;?&gt; callable = (Callable&lt;?&gt;) returnValue; WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer); &#125;&#125; 这里直接调用了WebAsyncManager的startCallableProcessing方法进行处理，不过这是一个重载的第一个参数是Callable类型的startCallableProcessing方法，其代码如下:1234public void startCallableProcessing(Callable&lt;?&gt; callable, Object... processingContext) throws Exception &#123; Assert.notNull(callable, "Callable must not be null"); startCallableProcessing(new WebAsyncTask(callable), processingContext);&#125; 它还是将Callable封装成了WebAsyncTask然后处理的。如果WebAsyncTask中只有Callable而没有别的属性的时候可以直接返回Callable，比如前面的处理器可以修改为：1234567891011121314151617181920212223242526package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class AsyncController &#123; @ResponseBody @RequestMapping(value = "/callable",produces = "text/plain; charset=UTF-8") public Callable&lt;String&gt; callable()&#123; System.out.println("Callable处理器主线程进入"); Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5 * 1000L); System.out.println("Callable处理执行中。。。"); return "久等了"; &#125; &#125;; System.out.println("Callable处理器主线程退出"); return callable; &#125;&#125; 它和前面使用WebAsyncTask执行的效果是一样的。 22.2.4 DeferredResult类型异步请求的处理过程及用法DeferredResult是spring提供的一种用于保存延迟处理结果的类，当一个处理器返回DeferredResult类型的返回值时将启动异步处理。 不过DeferredResult和WebAsyncTask的使用方法完全不同，DeferredResult并不是用于处理请求的，而且也不包含请求的处理过程，它是用来封装处理结果的，有点像Java中的Future，但不完全一样。 使用DeferredResult的难点就在理解其含义，对其含义理解了之后就会觉得非常简单，而且使用起来也很方便。在返回WebAsyncTask时是因为处理的时间过长所以使用了异步处理，但其实还是自己来处理的（因为WebAsyncTask需要提供Callable），而返回DeferredResult表示要将处理交个别人了，什么时候处理完、怎么处理的自己并不需要知道，这就好像在单位经常用到的“妥否，请批示”的请示报告，自己并不知道什么时候能批下来，而且也不需要知道具体批示过程，只需要知道最后的结果就可以了。DeferredResult就是来保存结果的，当处理完之后调用它的setResult方法将结果设置给它就可以了。 DeferredResult还提供了一些别的属性，如resultHandler可以在设置了结果之后对结果进行处理、timeout设置超时时间、timeoutCallback设置超时处理方法、completionCallback设置处理完成后酌处理方法、timeoutResult设置超时后返回的结果等。 下面看一下Spring MVC中处理DeferredResult返回值的DeferredResultMethodReturnValueHandler处理器，它的handleReturnValue方法如下：123456789101112131415161718192021public class DeferredResultMethodReturnValueHandler implements HandlerMethodReturnValueHandler &#123; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return DeferredResult.class.isAssignableFrom(returnType.getParameterType()); &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; DeferredResult&lt;?&gt; deferredResult = (DeferredResult&lt;?&gt;) returnValue; WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer); &#125;&#125; 这里直接凋用了WebAsyncManager的startDeferredResultProcessing方法进行处理。 下面来看一个返回值为DeferredResult的处理器的例子。123456789101112131415161718192021222324252627282930313233package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Controllerpublic class AsyncController &#123; @ResponseBody @RequestMapping(value = "/deferred",produces = "text/plain; charset=UTF-8") public DeferredResult&lt;String&gt; deferredResultExam() &#123; final DeferredResult&lt;String&gt; result = new DeferredResult&lt;String&gt;(7*1000L, "超时了"); approve(result); return result; &#125; private void approve(DeferredResult&lt;String&gt; result)&#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(5 * 1000L); result.setResult("同意 "+new SimpleDateFormat("yyyy-MM-dd").format(new Date())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; new Thread(r).start(); &#125;&#125; 在处理器方法中直接新建了个DeferredResult类型的result代表处理结果，构造方法的两个参数分别表示超时时间和超时后返回的结果，建出来后将其交给approve方法进行处理（审批），当approve方法给result使用setResult方法设置了值后异步处理就完成了。 approve方法启动了一个新线程，然后在里面等待5秒后给result设置值。因为这里的处理器有@ResponseBody注释，所以返回值会直接显示到浏览器，当调用http://localhost:8080/deferred时，浏览器会在过大约5秒后显示同意2015-04-02。 现在大家再返回去看WebAsyncManager酌startDeferredResultProcessing方法就容易理解了，它并没有而且也不需要执行，只需要等待别的线程给设置返回值就可以了。方法中给result设置了处理返回值的处理器，当有返回值返回时会自动调用，代码如下：1234567deferredResult.setResultHandler(new DeferredResultHandler() &#123; @Override public void handleResult(Object result) &#123; result = interceptorChain.applyPostProcess(asyncWebRequest, deferredResult, result); setConcurrentResultAndDispatch(result); &#125;&#125;); 这里的处理器中首先调用了拦截器链中的applyPostProcess方法，然后调用setConcurrentResultAndDispatch万法处理了返回值，setConcurrentResultAndDispatch方法前面已经说过了。 现在大家应该对DeferredResult返回值的异步处理就理解了，DeferredResult是一个用于保存返回值的类，只需要在业务处理完成后调用其setResult方法设置结果就可以了，至于怎么处理的、在哪里处理的它并不关心，这也就给我们带来了很大的自由。 22.2.5 ListenableFuture类型异步请求的处理过程及用法ListenableFuture继承自Future，Future在前面已经介绍过了，它用来保存Callable的处理结果，它提供了get方法来获取返回值，不过Future并不会在处理完成后主动提示。ListenableFuture在Future基础上增加了可以添加处理成功和处理失败回调方法的方法，代码如下：1234567public interface ListenableFuture&lt;T&gt; extends Future&lt;T&gt; &#123; void addCallback(ListenableFutureCallback&lt;? super T&gt; callback); void addCallback(SuccessCallback&lt;? super T&gt; successCallback, FailureCallback failureCallback);&#125; ListenableFutureCallback继承自SuccessCallback和FailureCallback接口，后两个接口分别有一个onSuccess方法和onFailure方法，用于处理异步处理成功的返回值和异步处理失败的返回值，就和DeferredResult中的resultHandler差不多，它们定义如下：12345678910111213141516171819202122public interface ListenableFutureCallback&lt;T&gt; extends SuccessCallback&lt;T&gt;, FailureCallback &#123;&#125;public interface SuccessCallback&lt;T&gt; &#123; /** * Called when the &#123;@link ListenableFuture&#125; successfully completes. * @param result the result */ void onSuccess(T result);&#125;public interface FailureCallback &#123; /** * Called when the &#123;@link ListenableFuture&#125; fails to complete. * @param ex the exception that triggered the failure */ void onFailure(Throwable ex);&#125; ListenableFuture足spring4.0新增的接口，它主要使用在需要调用别的服务的时候，spring还同时提供了AsyncRestTemplate，用它可以方便地发起各种Http请求，不同类型的请求（如Get、Post等）都有不同的方法，而且还可以使用url的模板参数uriVariables（类似于处理器参数中的pathVariables】，它的返回值就是ListenableFuture类型，比如，可以这样使用12ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; futureEntity = template.getForEntity("http://localhost:8080/students/&#123;studentld&#125;/books/&#123;bookldl" , String.class, "176", "7"); 这样就可以返回http://localhost:808 0/students/1 7 6/books/7的Get请求结果，而且是非阻塞的异步调用。 下面看一下处理ListenableFuture返回值的处理器ListenableFutureReturnValueHandler，它的handleReturnValue方法代码如下：123456789101112131415161718192021222324@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; final DeferredResult&lt;Object&gt; deferredResult = new DeferredResult&lt;Object&gt;(); WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer); ListenableFuture&lt;?&gt; future = (ListenableFuture&lt;?&gt;) returnValue; future.addCallback(new ListenableFutureCallback&lt;Object&gt;() &#123; @Override public void onSuccess(Object result) &#123; deferredResult.setResult(result); &#125; @Override public void onFailure(Throwable ex) &#123; deferredResult.setErrorResult(ex); &#125; &#125;);&#125; 可以看到在ListenableFuture的返回值处理器里实际使用了DeferredResult．首先新建了DeferredResult类型的deferredResult，接着调用了WebAsyncManager的startDeferredResultProcessing方法进行处理，然后给ListenableFuture类型的返回值添加了回调方法，在回调方法中对deferredResult设置了返回值。可以说ListenableFuture类型的返回值只是DeferredResult类型返回值处理器的一种特殊使用方式。大家好好体会这里的处理过程就可以对DeferredResult跟具体处理过程无关这一点理解得更加深入。 下面来看一个ListenableFuture类型返回值处理器的例子。123456789101112131415161718package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Controllerpublic class AsyncController &#123; @RequestMapping(value = "/listenable",produces = "text/plain; charset=UTF-8") public ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; listenableFuture() &#123; ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; future = new AsyncRestTemplate().getForEntity( "http://localhost:8080/index", String.class); return future; &#125;&#125; 这里处理器的返回值ListenableFuture的泛型是ResponseEntity类型，所以不需要使用@ResponseBody注释也会将返回值直接显示到浏览器。当调用http://localhost:8080/listenable时，浏览器会显示excelibGoGoGo!，也就是http://localhost:8080/index的返回结果.。 多知道点 ListenableFuture和Future的比较 ListenableFuture在Future的基础上增加了可以添加处理成功和处理失败回调方法的方法，这就从Future的“拉”模式变成了ListenableFuture的“推”模式。 Future只能调用get方法来主动拉数据，而且get方法还是阻塞的，而ListenableFuture可以等待处理完成后自己将结果推过来，而且不会阻塞线程，这么看好像ListenableFuture比Future更好用。其实在很多地方Future中阻塞的get方法才是真正需要的，因为很多时候都需要等到线程处理的结果才可以向下进行，比如，要找四个数中最大的那个，可以将四个数分成两组然后启动两个线程分别选出每组中比较大的数，然后再启动一个线程取出两个结果中比较大的，那就是四个数中最大的数，代码如下：12345678910111213141516171819202122232425262728293031public class ObtainBigger &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService executor = Executors.newCachedThreadPool(); // 需要查找最大数的数组 Double data[] = new Double[]&#123;210.32, 517.96, 986.77, 325.13&#125;; // 获取前两个里较大的 BiggerCallable c1 = new BiggerCallable(data[0],data[1]); Future&lt;Double&gt; bigger1 = executor.submit(c1); // 获取后两个里较大的 BiggerCallable c2 = new BiggerCallable(data[2],data[3]); Future&lt;Double&gt; bigger2 = executor.submit(c2); // 获取两个结果中较大的，这时会阻塞，只有前面两个结果都返回时才会往下进行 BiggerCallable c = new BiggerCallable(bigger1.get(), bigger2.get()); Future&lt;Double&gt; bigger = executor.submit(c); // 输出结果 System.out.println(bigger.get()); executor.shutdown(); &#125; private static class BiggerCallable implements Callable &#123; Double d1, d2; public BiggerCallable(Double d1, Double d2)&#123; this.d1 = d1; this.d2 = d2; &#125; @Override public Object call() throws Exception &#123; return d1&gt;d2?d1:d2; &#125; &#125;&#125; 这里使用了内部类BiggerCallable来比较，第三个BiggerCallable创建时前两个cl）c2必须已经执行完才可以，否则就会出问题，所以在这种情况下阻塞就是必要的，而且这种需要线程返回结果后才能往下进行的情况很多。而ListenableFuture的典型用法就是Web异步请求这种并不需要对线程返回的结果进一步处理，而且线程在返回之前主线程可以继续往下走的情况，这时如果程序阻塞就起不到应有的作用了。 22.3小结本章系统地介绍了Servlet和SpringMVC中异步处理的原理和使用方法，首先介绍了Servlet3.0中对异步请求的支持及其使用方法，然后又分析了SpringMVC中异步处理的执行过程并编写了示例程序。 Servlet中使用异步请求非常方便，只需要调用request的startAsync方法，然后对其返回值AsyncContext进行处理，如果需要还可以为其添加AsyncListener监听器，它可以监听异步请求的启动、超时、处理完成和处理异常四个节点。 Spring MVC为异步请求提供了专门的工具，并对处理器默认提供了四种用于异步处理的返回值： 1. Callable、 2. WebAsyncTask、 3. DeferredResult 4. ListenableFuture。 对异步请求的支持主要在RequestMappingHandlerAdapter中，启动异步处理在各返回值对应的返回值处理器中。 原文链接：https://github.com/sixtrees/kantouspringmvc/blob/master/%E7%AC%AC22%E7%AB%A0%20%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.md]]></content>
    </entry>

    
  
  
</search>
