<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[内存伪共享测试及Java对像内存估算]]></title>
      <url>%2F2018%2F08%2F17%2F%E7%AC%94%E8%AE%B0-%E4%BC%AA%E5%85%B1%E4%BA%AB%E6%B5%8B%E8%AF%95%E5%8F%8AJava%E5%AF%B9%E5%83%8F%E5%86%85%E5%AD%98%E4%BC%B0%E7%AE%97%2F</url>
      <content type="text"><![CDATA[引入之前每次入门Disruptor对此部分总是泛泛看过，主要关注点在如何应用上，急于按照文档完成第一个Demo，怠慢了其实现的核心思想及其要解决的主要问题，导致虽然入门过几次Disruptor，仍对其认识十分浅薄。最近有空再次入门Disruptor时，不出意外的又遇到了难以规避的问题–内存的伪共享。 前车之鉴，后事之师。这次花了一些时间先去了解下久闻其名的伪共享。 Java对象内存估算要想先搞清楚伪共享问题，就先需要搞清楚使用的语言（Java）对实例对象的内存布局以及如何来检测估算实例的内存占用。 InstrumentationInstrumentation是Java SE5开始引入的，我们可以通过它来检测Java对象的大小，当然这只是Instrumentation强大功能之一，还可以通过Instrumentation增加自定义类转换器，对Class进行增强或者替换，只是我们在这里并不关心。 找到了检测工具后怎么去使用呢？ 首先，要获取Instrumentation实例。Instrumentation由虚拟机来实例化和维护的，可以通过两种方式来获取： 当JVM以指示一个代理类的方式启动时，将传递给代理类的premain方法一个Instrumentation实例。 当JVM提供某种机制在JVM启动之后某一时刻启动代理时，将传递给代理代码的agentmain方法一个Instrumentation实例。 这里通过方法一来做。 步骤1. 创建一个用来检测对象大小的工具类，并在该类中声明实现premain方法； 1234567891011121314151617public class ObjectSizeUtil &#123; private static Instrumentation inst; public static void premain(String agentArgs, Instrumentation instP) &#123; inst = instP; &#125; public static long shallowSizeOf(Object o) &#123; if(inst == null) &#123; throw new IllegalStateException("Can not access instrumentation environment.\n" + "Please check if jar file containing SizeOfAgent class is \n" + "specified in the java's \"-javaagent\" command line argument."); &#125; return inst.getObjectSize(o); &#125;&#125; 步骤2. 利用javaagent方式启动来获取Instrumentation实例。这里以IDEA为例使用maven插件的方式来配置javaagent。 插件名 功能简介 maven-jar-plugin maven 默认打包插件，用来创建 project jar，可参考下一些开源软件项目对该插件的使用，比如：dubbo maven-shade-plugin 用来打可执行包，包含依赖，以及对依赖进行取舍过滤，可参考下一些开源软件项目对该插件的使用，比如：dubbo maven-assembly-plugin 支持定制化打包方式，更多是对项目目录的重新组装，可参考下一些开源软件项目对该插件的使用，比如：dubbo 1234567891011121314151617181920212223 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;com.cxd.jvm.jml.ObjectSizeUtil&lt;/Premain-Class&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 配置完成后使用maven进行打包。 步骤3. 在启动脚本中增加代理类路径，我的是-javaagent:/Users/childe/Documents/workspace/goodGoodStudy/target/childe-1.0-SNAPSHOT.jar 完成上面的操作后，基本工具就完成了，接下来就使用Instrumentation来帮助我们获取对象内存大小。 对象大小检测在估算内存大小时，会遇到类似Retained heap和Shallow heap两个概念，Shallow heap表示一个实例自身占用堆空间的大小，而Retained Heap不仅包含自身占用堆空间还包括自身引用其他对象的Shallow heap。在MAT中Retained Heap是一个对象被GC回收时，能够释放其所有引用的Shallow Heap的总和。 在开始检测前，先回顾下Java中元类型的大小。 类型 大小（字节byte） byte 1 short 2 int 4 long 8 float 4 double 8 char 2 boolean 大小没有明确指定，和虚拟机具体实现有关 一个类的实例对象在内存中这么分布：对象头 + 实例数据 + 填充。对象头里面保存了对象相关的诸如GC标记、锁标记等一些必要信息，实例数据就是对象的各个属性，填充是为了让对象的大小为8的倍数。 在开启指针压缩（-XX:+UseCompressedOops）的情况下，测试了一些元类型的大小。 12345678910111213141516171819202122// 64位机器上reference类型占用8个字节，开启指针压缩后占用4个字节private static void primitiveTest() &#123; int integer = 90; // int 自身4byte // +UseCompressedOops Integer shallowSizeOf : 16 = 12(head) + 4(instance data) retainedSizeOf : 16 System.out.println("Integer shallowSizeOf : " + ObjectSizeUtil.shallowSizeOf(integer) + " retainedSizeOf : " + ObjectSizeUtil.retainedSizeOf(integer)+ "\n"); long a = 100L; // long 自身8byte // +UseCompressedOops Long shallowSizeOf : 24 = 12(head) + 8(instance data) + 4(padding) retainedSizeOf : 24 System.out.println("Long shallowSizeOf : " + ObjectSizeUtil.shallowSizeOf(a) + " retainedSizeOf : " + ObjectSizeUtil.retainedSizeOf(a)+ "\n"); byte b = 1; // byte 自身1byte // +UseCompressedOops byte shallowSizeOf : 16 = 12(head) + 1(instance data) + 3(padding) retainedSizeOf : 16 System.out.println("byte shallowSizeOf : " + ObjectSizeUtil.shallowSizeOf(b) + " retainedSizeOf : " + ObjectSizeUtil.retainedSizeOf(b)+ "\n"); char c = '2'; // char 自身2byte // +UseCompressedOops char shallowSizeOf : 16 = 12(head) + 2(instance data) + 2(padding) retainedSizeOf : 16 System.out.println("char shallowSizeOf : " + ObjectSizeUtil.shallowSizeOf(c) + " retainedSizeOf : " + ObjectSizeUtil.retainedSizeOf(c)+ "\n");&#125; 当然，还有array、reference、String（特别的）类型内存大小的测试，这里不一一列出，全部代码-&gt;请戳这里-&lt;。 伪共享缓存说到伪共享就不得不提一下CPU和高速缓存。我们知道，CPU的计算速度时远远大于磁盘的读写速度的，为了缓解两者之间的速度差，就有了内存，CPU计算时需要的数据先放到内存中，CPU直接操作内存的数据而不是操作磁盘，内存又分成几部分：一级缓存（L1）、二次缓存（L2）、三级缓存（L3）、主存（Main Memory）。 如图所示，越靠近CPU的缓存速度越快，容量就越小。当CPU执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3（被单个插槽上的所有CPU核共享），最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果在做一些很频繁的事，就要确保数据在L1缓存中。 缓存行数据在缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。 如上图，为了简化问题，把缓存表示成了一块。线程0和线程1会用到不同变量，它们在内存中彼此相邻，并驻留在同一高速缓存行。高速缓存行被加载到CPU0和CPU1的高速缓存中（灰色箭头）。尽管这些线程修改的是不同变量（红色和蓝色箭头），高速缓存行仍会无效(MSEI协议)，并强制内存更新以维持高速缓存的一致性。 那么，伪共享的存在到底对我们的程序有多大影响呢？我们做个-&gt;测试（戳我看源码）&lt;-看下。 以下测试数据环境：123456CPU 2.7 GHz Intel Core i5内存 8 GB 1867 MHz DDR3java version &quot;1.8.0_74&quot;Java(TM) SE Runtime Environment (build 1.8.0_74-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class FalseSharing implements Runnable &#123; /** * 每改变一次，要重新编译一次，不然跑出的时间差别不准确 */ public final static int NUM_THREADS = 1; public final static long ITERATIONS = 500L * 1000L * 1000L; private final int arrayIndex; private static VolatileLong[] longs = new VolatileLong[NUM_THREADS]; static &#123; for (int i = 0; i &lt; longs.length; i++) &#123; longs[i] = new VolatileLong(); &#125; &#125; public FalseSharing(final int arrayIndex) &#123; this.arrayIndex = arrayIndex; &#125; public static void main(final String[] args) throws Exception &#123; final long start = System.nanoTime(); runTest(); System.out.println("duration = " + (System.nanoTime() - start)); &#125; private static void runTest() throws InterruptedException &#123; Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(new FalseSharing(i)); &#125; for (Thread t : threads) &#123; t.start(); &#125; for (Thread t : threads) &#123; t.join(); &#125; &#125; @Override public void run() &#123; long i = ITERATIONS + 1; while (0 != --i) &#123; longs[arrayIndex].value = i; &#125; &#125; /** * 从不断上升的测试所需时间中能够明显看出伪共享的影响。没有缓存行竞争时，我们几近达到了随着线程数的线性扩展。 * 这并不是个完美的测试，因为我们不能确定这些VolatileLong会布局在内存的什么位置。它们是独立的对象。 * 但是经验告诉我们同一时间分配的对象趋向集中于一块。 * 所以你也看到了，伪共享可能是无声的性能杀手。 */ public final static class VolatileLong &#123; // 8byte public volatile long value = 0L; // 40byte comment out // 0. NUM_THREADS = 1 duration = 4587.402.329 // 1. NUM_THREADS = 2 duration = 5249.820.613 // 2. NUM_THREADS = 3 duration = 6329.667.147 // 3. NUM_THREADS = 4 duration = 7743.024.530 public long p1, p2, p3, p4, p5; // 无填充时 // 0. NUM_THREADS = 1 duration = 8213.558.562 // 0. NUM_THREADS = 2 duration = 15874.759.369 // 0. NUM_THREADS = 3 duration = 27350.752.730 // 0. NUM_THREADS = 4 duration = 27435.461.116 &#125;&#125; 上面代码在disruptor用户手册中文翻译中有所描述，查看了网络上的一些关于伪共享的文章，测试代码大同小异，但VolatileLong这个类中，网上大多写的是填充6个long类型的属性，但经过计算和测试，基于上述代码环境时填充5个才是合适的，大家在做实验的时候注意一下自己的环境问题，这也是为什么文章开头先介绍计算对象大小的原因。 在VolatileLong类的注解中我贴出了自己跑的几组数据，得出的结论和我们的分析时一致的，伪共享随着竞争的加剧，表现的更加明显。 总结在Java8之后，新增了注解@sun.misc.Contended，来避免伪共享的问题，在JDK的源码中也可以搜寻到她的身影，像我们常用的Thread和ConcurrentHashMap中都有使用该注解。 那么是不是我们编码时要特别关注伪共享这个问题呢？个人认为除非是真的是要追求卓越的性能表现，大可不必在普通的业务应用中过分考虑该问题。首先，这个问题很隐蔽，难以从系统层面上通过工具来探测伪共享事件；其次，做测试之前我也强调了自己的测试环境，这个问题实际上和环境也有一定的关系；另外，缓存资源是很珍贵的，这些事情我们毕竟不专业，如果滥用就造成了浪费；最后，像Intel这类的厂商在做设计时必然会对此类问题做优化。所以呢，我们只要在真正需要时去考虑这些问题就行了。 终于把Disruptor一大优势-避免伪共享的基础了解完了，可以继续了解它在RingBuffer中精巧的无锁设计了！ 参考disruptor用户手册中文翻译 软件包 java.lang.instrument 的描述 JVM源码分析之javaagent原理完全解读 Instrumentation新功能 java对象内存分布（Java Memory Layout） 怎样精确计算一个对象的内存大小 避免并发线程之间的假共享 扩展infoQ上《maven实战》作者关于Maven的介绍 Maven实战（七）——常用Maven插件介绍（上）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dubbo源码-网络通信之提供者消费者通信]]></title>
      <url>%2F2018%2F05%2F29%2FDubbo%E6%BA%90%E7%A0%81-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8B%E6%8F%90%E4%BE%9B%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[引入之前简单看过Dubbo基于SPI的“微核+插件”形式的架构模式，Dubbo因为这种架构模式使得扩展十分简单，另外Dubbo的框架分层十分清晰，看起源码来相对轻松不少。 在使用Dubbo时突然想到几个问题，Dubbo默认使用tcp长链接，消费者们可能同时发起调用，提供者是怎样处理这些请求的？消费者和生产者之间链接如何复用？消费者和提供者之间几个长链接？要搞清楚这几个问题要从Dubbo的exchange和transport层来找答案。 exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec Dubbo在这两层提供了不同的实现，信息交换层默认的是自定义协议dubbo，传输层默认使用Netty。下面的一些探讨以Dubbo的默认配置为基础进行，可能因为Dubbo版本不同其中一些类名或者方法名称不一致，但不影响对其本身的理解。可借由具体实现更好的理解Dubbo的抽象分层。 网络通信模型 Client表示应用具体的某个服务引用，每个服务的引用可根据提供者的配置（connections）建立多个链接。 Dubbo协议缺省每服务每提供者每消费者使用单一长连接。 在NettyServer中区分Boss和Woker的角色，Boss负责建立新链接，Woker负责链接建立后的IO工作，Woker的数量可由配置指定。 Dispatcher部分Dubbo按照不同场景提供了几种不同的实现，也可根据自身业务特点进行扩展。 all（默认） 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。 direct 所有消息都不派发到线程池，全部在IO线程上直接执行。 message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在IO线程上执行。 execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在IO线程上执行。 connection 在IO线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。 上面提到的线程池指执行业务调用的线程池，此线程池可自行配置，默认为FixedThreadPool，大小为200，拒绝策略为AbortPolicyWithReport，队列为SynchronousQueue（不是很了解，后面再深入了解下）。上图中从ChannelEventRunner之后进入线程池。 服务启动Dubbo在解析service标签时会向外暴露服务，同时会检查打开网络服务。下图是dubbo服务暴露的时序图（摘自dubbo官网）。 在export阶段，会调用相应协议的export方法去完成invoker到exporter转化同时根据url（如下）中的address打开本地网络通信服务，默认启动netty服务。 123URL内容dubbo://10.1.87.93:20880/com.xx.IAdminUserLoginService?accesslog=/Users/childe/logs/access.log&amp;anyhost=true&amp;application=dmall-provider&amp;connections=4&amp;default.delay=-1&amp;default.retries=0&amp;default.service.filter=-monitor,-exception&amp;default.timeout=10000&amp;delay=-1&amp;dubbo=2.5.9&amp;generic=false&amp;interface=com.xx.IAdminUserLoginService&amp;loadbalance=roundrobin&amp;logger=slf4j&amp;methods=checkUser,getUserById,getUserByAccount&amp;monitor=dubbo%3A%2F%2Fzk1.daily.com%3A2181%2Fcom.alibaba.dubbo.registry.RegistryService%3Fapplication%3Ddmall-provider%26backup%3Dzk2.daily.com%3A2181%2Czk3.daily.com%3A2181%26dubbo%3D2.5.9%26file%3D%2FUsers%2Fchilde%2F.dubbo%2FDDD-soa.cache%26logger%3Dslf4j%26owner%3Dmazha%26pid%3D21874%26protocol%3Dregistry%26refer%3Ddubbo%253D2.5.9%2526interface%253Dcom.alibaba.dubbo.monitor.MonitorService%2526pid%253D21874%2526timestamp%253D1528104644722%26registry%3Dzookeeper%26timestamp%3D1528104644709&amp;owner=childe&amp;pid=21874&amp;revision=1.0.28&amp;side=provider&amp;timestamp=1528104644712&amp;uptime=1528104644716&amp;version=1.0.0.fsm.chen 启动netty服务的代码如下，分别有boss和worker线程池供netty来完成新链接的建立及网络IO。在创建NioServerSocketChannelFactory时我们可以通过Dubbo的配置（dubbo:protocol 中iothreads）来指定IO的线程数量。默认数量为CPU可用核数加1，但不能超过32个。 12345678910111213141516171819202122232425262728//NettyServerprotected void doOpen() throws Throwable &#123; NettyHelper.setNettyLoggerFactory(); ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerBoss", true)); ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerWorker", true)); ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS)); bootstrap = new ServerBootstrap(channelFactory); //Dubbo采用组合的形式来组织自身Handler，在此部分断点可清楚的看到其最终组合出来的handler都包含了哪些 //NettyHandler-&gt;NettyServer(本身实现了Channelhandler接口)-&gt;MultiMessageHandler //-&gt;HeartbeatHandler-&gt;AllChannelhandler(根据选择的Dispatcher方式决定)-&gt;DecodeHandler //-&gt;HeaderExchangeHandler-&gt;DubboProtocol$XX(内部匿名实现了Channelhandler) final NettyHandler nettyHandler = new NettyHandler(getUrl(), this); channels = nettyHandler.getChannels(); bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123; public ChannelPipeline getPipeline() &#123; NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec() ,getUrl(), NettyServer.this); ChannelPipeline pipeline = Channels.pipeline(); pipeline.addLast("decoder", adapter.getDecoder()); pipeline.addLast("encoder", adapter.getEncoder()); pipeline.addLast("handler", nettyHandler); return pipeline; &#125; &#125;); // bind channel = bootstrap.bind(getBindAddress());&#125; Provider完成一次业务请求操作流程如下： 接收数据-&gt;AllChannelHandler-&gt;ChannelEventRunner-&gt;DecodeHandler-&gt;HeaderExchangeHandler-&gt;DubboProtocol::reply-&gt;Invoker::invoke-&gt;Impl 除了IO及具体业务的执行过程，一次处理最重要的就是数据的交换啦，即：请求数据根据协议转成对应的数据结构，业务相应数据也要根据协议进行转换。 下面这段代码起的便是承上启下的作用，在这个步骤中，根据Request的信息构造出Response，并调用具体协议的reply实现获取业务相应数据。 在构造Response时回写入了Request的ID和Version。这是channel复用的关键。每个channel的Request都有一个唯一的ID，类型为long。 12345678910111213141516171819202122232425262728//HeaderExchangeHandlerResponse handleRequest(ExchangeChannel channel, Request req) throws RemotingException &#123; Response res = new Response(req.getId(), req.getVersion()); if (req.isBroken()) &#123; Object data = req.getData(); String msg; if (data == null) msg = null; else if (data instanceof Throwable) msg = StringUtils.toString((Throwable) data); else msg = data.toString(); res.setErrorMessage("Fail to decode request due to: " + msg); res.setStatus(Response.BAD_REQUEST); return res; &#125; // find handler by message class. Object msg = req.getData(); try &#123; // handle data. Object result = handler.reply(channel, msg); res.setStatus(Response.OK); res.setResult(result); &#125; catch (Throwable e) &#123; res.setStatus(Response.SERVICE_ERROR); res.setErrorMessage(StringUtils.toString(e)); &#125; return res;&#125; 服务引用Consumer启动时会从注册中心拉取订阅的Provider信息，并建立和Provider的链接，时序图如下（摘自dubbo官网）： Consumer的一次调用时序: DubboInvoker::doInvoke-&gt;NettyClient-&gt;AbstractClient::send-&gt;AbstractPeer-&gt;HeaderExchangeChannel::send-&gt;DefaultFuture::send-&gt;NettyChannel::send-&gt;DefaultFuture::received Consumer每发起一次调用时会构建出本次调用的Request，每个Request有唯一的ID。Dubbo中用AtomicLong实现ID，短时间内不会重复，所以可作为唯一标识。 1234567891011121314151617181920//HeaderExchangeChannelpublic ResponseFuture request(Object request, int timeout) throws RemotingException &#123; if (closed) &#123; throw new RemotingException(this.getLocalAddress(), null, "Failed to send request " + request + ", cause: The channel " + this + " is closed!"); &#125; // create request. // 无参构造方法中生成一个ID Request req = new Request(); req.setVersion("2.0.0"); req.setTwoWay(true); req.setData(request); DefaultFuture future = new DefaultFuture(channel, req, timeout); try &#123; channel.send(req); &#125; catch (RemotingException e) &#123; future.cancel(); throw e; &#125; return future;&#125; 123456789101112//Requestprivate static final AtomicLong INVOKE_ID = new AtomicLong(0);public Request() &#123; mId = newId();&#125;private static long newId() &#123; // getAndIncrement() When it grows to MAX_VALUE, it will grow to MIN_VALUE, and the negative can be used as ID return INVOKE_ID.getAndIncrement();&#125; Consumer发起调用后，使用DefaultFuture将异步变成同步，等待Provider的返回。当Provider有数据写回，我们将其转换为Response后，通过ID就可以知道通知哪个DefaultFuture来进行后续的处理了。这样就完成了channel的复用。 1234567891011121314151617//DefaultFuturepublic static void received(Channel channel, Response response) &#123; try &#123; DefaultFuture future = FUTURES.remove(response.getId()); if (future != null) &#123; future.doReceived(response); &#125; else &#123; logger.warn("The timeout response finally returned at " + (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date())) + ", response " + response + (channel == null ? "" : ", channel: " + channel.getLocalAddress() + " -&gt; " + channel.getRemoteAddress())); &#125; &#125; finally &#123; CHANNELS.remove(response.getId()); &#125;&#125; 疑问回答 消费者和提供者之间长链接？ 缺省是长链接，也可以使用其他的（自定义）的通讯方式。 消费者和提供者之间几个长链接？ 缺省每服务每提供者每消费者使用单一长连接，如果数据量较大，可以使用多个连接。 消费者和提供者之间连接如何复用？ 请求和应答消息使用同一个ID作为唯一标识来区分同一个链接内的不同请求。 官网释疑的几个问题 为什么要消费者比提供者个数多? 因 dubbo 协议采用单一长连接，假设网络为千兆网卡，根据测试经验数据每条连接最多只能压满 7MByte(不同的环境可能不一样，供参考，PS：1024Mbit=128MByte)，理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。 为什么dubbo协议不能传大包？ 因 dubbo 协议采用单一长连接，如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡，每条连接最大 7MByte(不同的环境可能不一样，供参考)，单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。 为什么采用异步单一长连接? 因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步 IO，复用线程池，防止 C10K 问题。 参考及扩展链接netty之boss-workerC10K问题Dubbo框架设计dubbo协议]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[状态机选型简记]]></title>
      <url>%2F2018%2F04%2F28%2F%E7%8A%B6%E6%80%81%E6%9C%BA%E9%80%89%E5%9E%8B%E7%AE%80%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[背景业务中涉及到一些关于单据的操作，每种单据单据都会有自己的状态，单据的一些行为受限于当前订单的状态，单据的状态直接用常量表示，业务进行前的检查部分通过if判断来检测当前单据是否可以流转到目标状态。 痛点业务发展的比较快，某些单据状态不停的增加，每一次增加都需要改动业务中使用到状态的相关代码，更糟的的是这些代码可能遍布于多个类的多个方法中（散弹枪一样），不仅增加发布的风险也同时增加了测试的回归任务。 目的单据的状态及状态转换与业务解耦，避免散弹一样的效果。 涉及到的知识点了解以下几个知识点有助于我们更好的理解状态机，也相当于是调研状态机是否满足我们最核心的需求。 FSM1有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。 状态存储关于过去的信息，就是说：它反映从系统开始到现在时刻的输入变化。转移指示状态变更，并且用必须满足确使转移发生的条件来描述它。动作是在给定时刻要进行的活动的描述。有多种类型的动作： 进入动作（entry action）：在进入状态时进行 退出动作：在退出状态时进行 输入动作：依赖于当前状态和输入条件进行 转移动作：在进行特定转移时进行 FSM（有限状态机）可以使用上图那样的状态图（或状态转移图）来表示。此外可以使用多种类型的状态转移表。下面展示最常见的表示：当前状态（B）和条件（Y）的组合指示出下一个状态（C）。完整的动作信息可以只使用脚注来增加。包括完整动作信息的FSM定义可以使用状态表。 当前状态→ 条件↓ 状态A 状态B 状态C 条件X … … … 条件Y … 状态C … 条件Z … … … 状态图的基本概念2状态图（Statechart Diagram）主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件（Event），以及因状态转移而伴随的动作（Action）。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机（State Machine Diagram），重点在与描述状态图的控制流。 状态图有以下几类元素构成： 状态（States） 转移（Transitions） 动作（State Actions） 自身转移（Self-Transitions） 组合状态（Compound States） 进入节点（Entry Point） 退出节点（Exit Point） 历史状态（History States） 并发区域（Concurrent Regions） 警备条件（Guard condition） 网上介绍状态图的文章很多，给出两篇我认为不错的，里面对状态图介绍的比较详尽，内容不多。 UML建模之状态图-中文 状态机图-英文 状态模式在之前设计模式-行为模式之State的博文中有详细的介绍，不再赘述。 开源的状态机实现状态机是上述对状态图定义的实现，下面几种实现遵循基本的定义，但实现的完善度不尽相同。学习时Demo放在GitHub上，需要可取。 spring-statemachinespring-statemachine的优点官网中介绍的很清楚，不赘述，但在简单看了介绍和实现后基本就放弃了，原因如下： 天生依赖spring，目前最新版本的依赖到Spring框架5.0.X，而我需要引入状态机的工程目前还停留在4.2.X。 状态机实例较重，在官方文档给出的Demo中，推荐注解的形式注入状态机，这样难以随用随new。 关于上一点，其给出了采用工厂的方式解决，但根据单据的业务场景来看，缓存这些实例意义并不大。 squirrel-foundation特点 代码量适中，扩展和维护相对而言比较容易 StateMachine轻量 StateMachine实例创建开销小，本身不支持单例复用，状态机的生命周期清晰 切入点丰富 支持exit、transition、entry基本动作，转换过程留有足够的切入点。 下面是一个状态转换的过程，可以看到我们有很多可以切入的点来记录或者改变状态机的行为。比较蛋疼的是，在状态机初始化时，squirrel把初始化状态当作一个事件发布，导致会多出来一个相应的事件记录。 1234567891011121314//第一行为初始化状态机为OffHook时，注册事件处理器所打印15:59:09.570 [main] WARN com.cxd.squirrel.StateMachineSquirrel - Entry State OffHook//以下是一个完整的状态转换过程15:59:09.574 [main] WARN com.cxd.squirrel.StateMachineSquirrel - beforeTransitionBegin15:59:09.581 [main] WARN com.cxd.squirrel.MyCondition - 自定义转换条件 isSatisfied MyContext&#123;no='yes'&#125;15:59:09.581 [main] WARN com.cxd.squirrel.StateMachineSquirrel - beforeActionInvoked15:59:09.581 [main] WARN com.cxd.squirrel.StateMachineSquirrel - exit State OffHook15:59:09.581 [main] WARN com.cxd.squirrel.StateMachineSquirrel - afterActionInvoked15:59:09.582 [main] WARN com.cxd.squirrel.StateMachineSquirrel - beforeActionInvoked15:59:09.582 [main] WARN com.cxd.squirrel.StateMachineSquirrel - callMethod Transition...15:59:11.586 [main] WARN com.cxd.squirrel.StateMachineSquirrel - afterActionInvoked15:59:11.587 [main] WARN com.cxd.squirrel.StateMachineSquirrel - Entry State Ringing15:59:11.588 [main] WARN com.cxd.squirrel.StateMachineSquirrel - afterTransitionCompleted15:59:11.589 [main] WARN com.cxd.squirrel.StateMachineSquirrel - afterTransitionEnd 支持异步 事件处理机制上squirrel和Spring-statemachine比较相似，将事件处理与产生分离，使用deque交互，通过这种方式可以支持异步，采用生产-消费的方式，让线程责任更加明确。 在我们的业务场景中所有关于单据状态流转的操作都是用户通过移动端发起，需要同步响应操作结果，所以异步在我的场景中不适用。 鸡肋 过于便利的设计 squirrel在设计上为了足够的便利，在注册事件处理方法时通过传入方法名来实现，框架在处理时从状态机实现类中去找这些方法，通过动态的方式调用。 1builder.onEntry(States.OffHook).callMethod("entry"); 个人认为这种方式不是很好，不具有强制约束性，编译期间难以发现错误，也不知道自定义方法的签名到底是怎样。 框架的约定性太强 123方法名为transitFrom[SourceStateName]To[TargetStateName]On[EventName]，参数名为[MyState, MyState, MyEvent, MyContext]的方法会被添加到transition “A-(GoToB)-&gt;B”的action列表中。当状态机从’A’到’B’且触发的event为GoToB的时候，该方法会被调用。 这是框架的一个约定，个人认为作为一个框架不应该有这种画蛇添足的约定，对于框架而言，这太过于约定了。 难以理解的异步处理方式 看了下异步处理的过程，Spring-statemachine在把事件塞进队列后仅是提交了异步任务到Executor，业务线程便立刻返回，这和我理解的异步是一致的。 12345678910111213AbstractStateMachine#sendEventInternalprivate boolean sendEventInternal(Message&lt;E&gt; event) &#123; //...省略... //此处是一个扩展，用户可自行加业务逻辑决定是否接受当前event boolean accepted = acceptEvent(event); //在此方法中创建了一个Runnable并提交到Executor stateMachineExecutor.execute(); if (!accepted) &#123; notifyEventNotAccepted(buildStateContext(Stage.EVENT_NOT_ACCEPTED, event, null, getRelayStateMachine(), getState(), null)); &#125; return accepted;&#125; 而squirrel在把事件塞进队列后还需要等待消费线程消费完毕，不知道此时异步的意义体现在哪里。 另外所有的事件处理默认均有同一个线程来处理，如果用得到异步这种方式，请务必通过扩展方式定义自己的线程池。 squirrel有依赖较低版本Guava中被注解为@Beta的方法，使用时务必注意框架本身对其他开源工具的引用。 1234567891011121314151617181920212223242526272829303132333435363738AbstractExecutionService#doExecuteprivate void doExecute(String bucketName, List&lt;ActionContext&lt;T, S, E, C&gt;&gt; bucketActions) &#123; final Map&lt;ActionContext&lt;T, S, E, C&gt;, Future&lt;?&gt;&gt; futures = Maps.newHashMap(); for (int i=0, actionSize = bucketActions.size(); i&lt;actionSize; ++i) &#123; final ActionContext&lt;T, S, E, C&gt; actionContext = bucketActions.get(i); //...省略... Future&lt;?&gt; future = SquirrelConfiguration.getExecutor().submit(new Runnable() &#123; @Override public void run() &#123; StateMachineContext.set(instance, isTestEvent); try &#123; actionContext.run(); &#125; finally &#123; StateMachineContext.set(null); &#125; &#125; &#125;); futures.put(actionContext, future); //...省略... &#125; for(Entry&lt;ActionContext&lt;T, S, E, C&gt;, Future&lt;?&gt;&gt; entry : futures.entrySet()) &#123; final Future&lt;?&gt; future = entry.getValue(); final ActionContext&lt;T, S, E, C&gt; actionContext = entry.getKey(); try &#123; logger.debug("Waiting action \'"+actionContext.action.toString()+"\' to finish."); if(actionContext.action.timeout()&gt;=0) &#123; future.get(actionContext.action.timeout(), TimeUnit.MILLISECONDS); &#125; else &#123; future.get(); &#125; logger.debug("Action \'"+actionContext.action.toString()+"\' finished."); &#125; catch (Exception e) &#123; //...省略... &#125; &#125;&#125; sateless4j特点 sateless4j是C#版本FSM的Java实现，代码量很少，不到30个类。 StateMachine轻量，比squirrel创建实例代价还要小。 支持基本的事件迁移，exit/entry action、guard、dynamic permit(根据自定义的condition来控制状态的迁移)。 鸡肋因为状态迁移模型设计过于简单，导致本身的扩展点太少。 小结作出决定时我的考量： 上手速度（越简单越快速） 和现有框架的兼容（只需要做代码的变动，不涉及到框架层面） 改动代码少 社区的活跃度 是否有公司在使用 使用状态机到那种地步：仅做状态判断？状态机是否和业务关联？持久化？ 是否引用其他开源项目？被引用的项目是否稳定？是否使用其中明确被告知不稳定的方法或者类？ 至此，我需要再次回顾我最初的诉求：管理状态的转换，避免散弹式的效果。结合考量点，其实sateless4j和squirrel都满足我现在的要求，但我只是想方便管理单据状态的转换，并不想基于这些状态的特性更多的改动工程中的代码，所以决定使用sateless4j。PS：一般PS都是重点啦。朋友的项目中已经在使用sateless4j。 最后，迎留言指正讨论^_^。 参考及引用 有限状态机FSM UML建模之状态图 中文版squirrel文档-部分 英文版squirrel文档-全 别人的选型记录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Visitor]]></title>
      <url>%2F2018%2F02%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BVisitor%2F</url>
      <content type="text"><![CDATA[意图Visitor是行为模式的一种，允许你在不改变要操作对象类的情况下定义一个新操作。 问题你的团队正在开发一款地理信息结构地图的app。图的节点不仅表示城镇也有其他诸如景点，行业等信息。节点间通过道路关联。在引擎中，每个节点都是一个对象，他们的类型由他们自己的类来表示。 你接到一个任务，要把地图导出为XML。乍看之下很容易实现。你需要为每个类型的节点添加一个导出方法，然后遍历地图并为每个节点执行导出方法。这个方法不仅简单而且优雅，因为你可以使用多态来避免和具体的节点类耦合。 但不幸的是，系统架构师不允许修改已存在的node类。这些代码已经在生产环境，没有人希望冒着风险修改他。 另外，他质疑节点类中的XML导出是否有意义。这些类的主要工作是和地理数据协作。导出行为放在这里看起来很不合适。 还有另一个拒绝的原因。在此之后，市场部门的人可能会要求你导出其他格式或添加其他一些奇怪的功能。这会迫使你再次修改那些珍贵的代码。 解决Visitor模式建议你把新的行为放在一个单独的类中，而不是把它继承在已存在的类中。关联到对象的行为，不会被对象本身调用。对象被作为visitor对象的方法参数传递。 对于不同类型的对象，行为的代码可能有点不同。因此，visitor类必须为不同类型的参数提供不同的行为方法。 12345class ExportVisitor implements Visitor is method doForCity(City c) &#123; ... &#125; method doForIndustry(Industry f) &#123; ... &#125; method doForSightSeeing(SightSeeing ss) &#123; ... &#125; // ... 但是，我们怎么为整个地图调用这些方法呢？这些方法有不同的签名，这不允许我们使用多态。为了找到合适的方法来执行给定的对象，我们需要检查它的类。这听起来就是个噩梦。 1234567foreach (Node node : graph) if (node instanceof City) exportVisitor.doForCity((City) node); if (node instanceof Industry) exportVisitor.doForIndustry((Industry) node); // ...&#125; 即使给定的编程语言支持重载（比如：Java或者C#），方法的重载也不会有帮助。因为无法事先知道给定节点的精确类，即使使用了重载也不一定能正确找到执行方法。 但是Visitor迷失对整个问题有一个解决方案。它使用Double Dispatch技术来保持多态性。如果我们把确定正确visitor方法的工作委托给我们传递给visitor的对象会怎么样？这些对象自己知道自己的类，所以他们可以挑选一个合适的方法。 123456789101112131415// Client codeforeach (Node node : graph) node.accept(exportVisitor);// Cityclass City is method accept(Visitor v) is v.doForCity(this); // ...// Industryclass Industry is method accept(Visitor v) is v.doForIndustry(this); // ... 我必须承认，我们必须改变node类。但是至少这个改动很小，并且具有可扩展性。 我们接下来要为所有的个性visitor抽离出通用的接口。现在，如果你需要给程序添加一个新的行为，你要做的仅仅是增加一个visitor类。所有已存在的类仍然可以不受影响的很的工作。 真实世界的类比保险代理想象下一个刚入行的保险员，迫切需要新的客户。他随机访问附近的邻居，为他们提供服务。但是不同类型的邻居，需要不同的保险服务。 在住宅，他兜售医疗保险。 在银行，他兜售防盗保险。 在公司，他兜售自然灾害险。 结构 Visitor为所有类型的visitor声明了通用的接口。他声明了一系列把Context Components当作参数的参观方法。这些方法的名字在支持重载的语言中可以一样，但是参数类型不能一样。 Concrete Visitor实现通用接口描述的操作。每个具体的visitor都表示一个独立的行为。 Component声明了一个用来接收Visitor参数的方法。这个方法以Visitor接口作为参数。 Concrete Component实现这个验收方法。这个方法的目的是为了用来为当前组件重定向到一个正确的visitor方法。 Client表示一个集合或者其他复杂对象（比如，一个Composite树）。Client通常不知道其组件的具体类别。 伪代码在这个例子中，Visitor模式将XML导出添加到几何图形的层次结构中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// A complex hierarchy of components.interface Shape is method move(x, y) method draw() method accept(v: Visitor)// It is crucial to implement the accept() method in every// single component, not just a base class. It helps the// program to pick a proper method on the visitor class in// case if a given component's type is unknow.class Dot extends Shape is // ... method accept(v: Visitor) is v.visitDot(this)class Circle extends Dot is // ... method accept(v: Visitor) is v.visitCircle(this)class Rectangle extends Shape is // ... method accept(v: Visitor) is v.visitRectangle(this)class CompoundShape implements Shape is // ... method accept(v: Visitor) is v.visitCompoundShape(this)// Visitor interface must have visiting methods for the// every single component. Note that each time you add a new// class to the component history, you will need to add a// method to the visitor classes. In this case, you might// consider avoiding visitor altogether.interface Visitor is method visitDot(d: Dot) method visitCircle(c: Circle) method visitRectangle(r: Rectangle) method visitCompoundShape(cs: CompoundShape)// Concrete visitor adds a single operation to the entire// hierarchy of components. Which means that if you need to// add multiple operations, you will have to create// several visitor.class XMLExportVisitor is method visitDot(d: Dot) is Export dot's id and center coordinates. method visitCircle(c: Circle) is Export circle's id, center coordinates and radius. method visitRectangle(r: Rectangle) is Export rectangle's id, left-top coordinates, width and height. method visitCompoundShape(cs: CompoundShape) is Export shape's id and the list of children ids.// Application can use visitor along with any set of// components without checking their type first. Double// dispatch mechanism guarantees that a proper visiting// method will be called for any given component.class Application is field allShapes: array of Shapes method export() is exportVisitor = new XMLExportVisitor() foreach shape in allShapes shape.accept(exportVisitor) 如果你不知道为什么这里需要accapt方法，你需要了解一下二次分派。在Java 8之后，接口允许有默认实现，所以本例子可以利用重载和default实现的更加精简。 适用性 当你需要对复杂对象结构（例如树）的所有元素执行操作时，并且所有元素都是异构的。 Visitor模式允许你为一系列不同类型的对象执行一个操作。 当你需要能够在一个复杂的对象结构上运行几个不相关的行为，但是你不想用这些行为的代码来“阻塞”结构的类。 Visitor模式允许你从一堆构成对象结构的类中提取和统一相关的行为，并将其集成到一个visitor类中。这些转型与虚拟在不同的app中重用这些类，而不用关心和它不相关的行为。 当一个新行为只对现有层次结构中的某些类有意义。 Visitor模式允许你制作一个特殊的visitor类实现某些对象的行为，但不为其他对象。 如何实现 为程序中的具体组件创建Visitor接口并且声明一个“visiting”方法。 在组件的基类中添加抽象的accept方法。 具体的组件实现抽象的accept方法。他们必须把请求重定向到适合当前组件类的特定visitor方法。 组件层级结构只需要关心Visitor接口。这样visitor就不必和具体的组件耦合。 对于每个新行为，创建一个新的Concrete Visitor类并实现所有的访问方法。 客户端创建visitor对象，并把他们当作参数传给组建的accept方法。 优点 简化类在复杂的对象结构上添加新的操作。 将相关的行为移动到一个类中。 visitor可以在对对象结构的工作过程中积累状态。 缺点 如果组件的层次经常改变，不适合使用该模式。 违反组件的封装。 和其他模式的关系 Visitor模式像加强版的Command模式，它可以在任何类型的对象上执行一个操作。 Visitor可以对整个Composite树应用一个操作。 Visitor可以和Iterator模式协作来遍历复杂的数据结构，并对所有元素执行一些操作，即使它们有不同的类型。 小结Visitor模式的结构比较简单，其中比较巧妙的是“二次分派”技术，这里不做展开，大家可自行问度娘或者谷哥。给个简单的例子，自行体会下。 参考翻译整理自：https://refactoring.guru/design-patterns/visitor]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Template-Method]]></title>
      <url>%2F2018%2F01%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BTemplate-Method%2F</url>
      <content type="text"><![CDATA[意图Template Method 时行为模式的一种，让你定义一个算法的骨架，允许子类重新定义在不改变结构的情况下重新定义算法的某些步骤。 问题假设你正在写一个挖掘办公文档数据的应用程序。用户想要输入各种格式的文件（PDF，DOC，CSV），程序输出给他们有用的格式化数据。 第一个版本你仅支持DOC文件。下一个版本支持CSV格式文件。一个月后，你又增加了从PDF中分析数据的功能。 这时候，你注意到这三种转换算法有很多相似之处。他们除了处理不同的文件格式外，对数据的萃取和分析都是一致的。这点对减少重复代码和算法独立很有帮助。 客户端代码使用这些算法还有另一个问题。选择合适的行为的许多条件都需要依赖选择的算法。如果这三个转换类都遵循一个通用接口或者一个基类，这些条件就可以用多态消灭掉。 解决Template Method模式建议把一个算法分成几个步骤，把步骤封装到方法中并在一个“template”方法中挨个调用。 子类可以复写特定的步骤，但是无法修改模板方法，保持算法的结构不变。 在我们的应用中，我们为所有的转换算法创建一个通用的基类。模版方法的关键步骤看起来像这样子： 123456method templateMethod() is openDocument(); extractRawData(); parseRawData(); analyzeData(); closeDocument(); 首先，你要把模版方法声明为abstract的，让所有的步骤都需要子类实现。然后，在子类的所有方法都实现后，再把子类共有的部分放到基类中，并使这些步骤（方法）成为可选的复写方法。 在我们的例子中，打开和关闭文档的操作对三种文件方式都不同，所以这点不需要默认实现。但是其他的步骤，比如，转换和分析，可以放到基类中，使得子类间共享这些代码。 还有另外一种步骤，叫做钩子。钩子时可选的步骤，他默认是空的。因此，即使一个模板没有腹泻够爱方法，它依然可以工作。通常，钩子被用来再算法开始之前或者结束之后给子类提供机会来做一些事情。 真实世界的类比大众住房建设建筑商使用模板方法来进行大规模住房建设。有一个标准的建筑模板来描述施工步骤：打地基，筑桩，垒墙，走水电等。 但是，尽管标准化，建筑商可以稍微改变每一步，使一个房子有点不同（即添加更多的窗口，用不同的颜色涂墙…） 结构 Abstract class声明了算法的每个步骤，以及用来统筹调用每个步骤的模版方法。这些步骤可以被声明为abstract或者有默认的实现。 Concrete class实现模版方法中定义的每个抽象步骤，但是它也可以复写抽象类中的默认实现。具体的实现类不能自己复写模板方法。 适用性 当子类能够扩展基本算法而不能修改他的结构时。 模版方法模式把算法分割成几个定义在基类中的个性化的步骤，可以被子类轻松扩展，并保持算法的结构。 当你需要几个类来做相似的事情但是又有一些不同时时。当你修改其中一个类时，你必须同时修改其他的类。 模版方法模式把相似的算法步骤抽取到基类中。代码的不同部分保留在各个子类中。 如何实现 分析算法，看他们是否可以被分解成几个步骤。这些步骤中那些事所有子类公用的，哪些事子类唯一的。 创建抽象基类，并且声明模版方法。列出这些算法的结构，把他们声明为abstract。考虑哪些方法应当被声明为final来阻止子类的重写。 如果所有的步骤都是抽象的那就好了。然而，一些步骤适合有默认实现。子类必须实现哪些抽象的方法。 考虑在合适的步骤之间增加钩子，以及在模板方法的开始和结束之间添加钩子。 算法的每个变种都从抽象类继承。变种必须实现所有必要的步骤，但是可以选择性重写可选步骤。 优点 帮助消除重复代码。 缺点 你将受限于现有算法的架构。 如果通过子类复写默认的步骤实现就违背了里氏替换原则。 模板方法往往难以保持更多的步骤。 和其他模式的关系 Factory Method是专业化的Template Method。另一方面，Factory Method通常作为大型Template Method的一个步骤。 Template Method采用继承方式来扩展不同的类取修改算法。Strategy采用修改委托对象行为的方式来改变对象的行为。Template Method工作在类级别。Strategy允许你更改单个对象的行为。 小结Java核心库中有些例子： java.io.InputStream，java.io.OutputStream，java.io.Reader和java.io.Writer中所有非抽象的方法。 java.util.AbstractList，java.util.AbstractSet和java.util.AbstractMap中所有非抽象的方法。 javax.servlet.http.HttpServlet中所有的doXXX()方法都默认响应一个HTTP 405 “Method Not Allowed”错误。你可以自由复写他们。 参考翻译整理自：https://refactoring.guru/design-patterns/template-method]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Strategy]]></title>
      <url>%2F2018%2F01%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BStrategy%2F</url>
      <content type="text"><![CDATA[意图Strategy是行为模式的一种，让你定义一组算法，各自封装，并且他们可替换。Strategy让这些算法独立与使用他们的客户端。 问题一天你决定写一个给驴友使用的导航应用。这个应用以漂亮的地图为中心，允许用户在任何城市快速的定位。应用最大的特点是能够自动规划路线，所以你决定特别关注这点。用户可以输入一个期望的目的地，能够快速在屏幕上画出路线。 第一个版本的应用只能规划道路上的路线，适合汽车旅客。但显然不是所有的人都喜欢在休假时开车。所以下一次更新，你添加了规划步行路线的选项。之后，你又增加了一个选项，允许用户规划基于公共交通的路线。 但这仅是一个开始。最近的版本中你计划增加一个可以规划自行车路线的特性。之后，根据沿途景点规划路线成为可选项。 这款应用的业务是成功的，但是技术部分让你头疼不已。每次增加一个新的路线算法，Map类的大小就会增长。至此，应用开始变得难以维护。 任何搜索算法的改变，比如修复一个BUG或者微调算法行为，都会影响整个类，增加了让已存在代码出错的风险。 最终，团队合作变得低效。你的队友在你成功发布一次之后都会抱怨要花费大量的时间在处理代码合并冲突上，因为它们都和一个大类相关联。 解决策略模式建议采使用一个以许多不同方式做重要事情的类，并将这些算法分别提取到单独的被称为策略的类中。 源类被称为context，它有一个字段来接受存储所有策略中的一种。上下文把工作委托给关联的策略，而不是自己去执行。 上下文没有选择合适算法的职责，客户端负责传递一个适当的策略到上下文中。 事实上，上下文不知道策略的细节。上下文只通过策略基本接口暴漏出来的方法和它通信。这是的上下文独立与策略，允许你在不修改上下文或者其他策略的情况下添加新的策略。 在我们导航应用中，每个路线算法都将被抽离到它们自己对应的只有一个buildRoute方法的类中。这个方法接受出发地和目的地，返回路线检查点的集合。 甚至每个路线类在相同的参数下会给出不同的路线。Map类不需要在关心那个策略被选中，因为它唯一的工作就是把检查点渲染到地图上。 这个Map将会提供出一个方法来切换路线策略，这样客户端就可以提供出一个按钮给用户来修改当前规划路线的方式。 真实世界的类比运输你必须到机场去。你可以坐巴士，打的或者骑单车。出行方式就是策略。你根据上下文来选择一个策略，比如预算或者时间限制。 结构 Context存储一个Concrete Strategy对象，但是只通过通用的Strategy接口和其协作。上下文应当报漏出一个setter方法让其他对象可以替换关联的策略对象。 Strategy为所有的策略声明了一个通用接口。这个接口让具体的策略在上下文中是可替换的。 Concrete Strategy实现了不同的算法，旨在以不同的方式完成相同的工作。 上下文只在它需要的时候去调用策略来执行任务。但它并不知道到底是那个策略在执行。 Client会根据不同的场景选择不同的策略。他们可以在运行时根据需要来配置上下文的策略。 伪代码在这个例子中，上下文使用策略来进行不同的算数运算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Common interface for all strategies.interface Strategy is method execute(a, b)// Each concrete strategy provides unique implementation.class ConcreteStrategyAdd implements Strategy is method execute(a, b) is return a + bclass ConcreteStrategySubtract implements Strategy is method execute(a, b) is return a - bclass ConcreteStrategyMultiply implements Strategy is method execute(a, b) is return a * b// Context (as a client) always works with strategies// through a common interface. It does not know or care// which strategy is currently active.class Context is private strategy: Strategy method setStrategy(Strategy strategy) is this.strategy = strategy method executeStrategy(int a, int b) is return strategy.execute(a, b)// The concrete strategy is picked on a higher level (for// example, by application config) and passed to the client// object. At any time, the strategy object can be replaced// by a different strategy.class ExampleApplication is method main() is Create context object. Read first number. Read last number. Read the desired action from user input. if (action == addition) then context.setStrategy(new ConcreteStrategyAdd()) if (action == subtraction) then context.setStrategy(new ConcreteStrategySubtract()) if (action == multiplication) then context.setStrategy(new ConcreteStrategyMultiply()) result = context.executeStrategy(First number, Second number) Print result. 适用性 当你有一个对象需要以许多不同的方式来做相同的任务时。 策略模式允许你在运行时通过提供不同的子对象（实际处理工作的对象）来修改对象的行为。 当你有许多相似的类，它们以不同的方式执行一些行为。 策略模式允许你将所有这些类的行为抽取到单独的类层次结构中，从而使原始类的行为可以自定义。 当你不想把算法实现的细节暴露给其他类时。 策略模式通过把代码，内部数据和算法的依赖关系提取到自己的类中来隔离其他对象。 一个算法通过大量条件操作被选择执行。背个条件分支代表不同的算法。 策略允许你通过抽离每个算法到自己的类中来分解条件，这些类都遵循一个相同的接口。上下文把工作委托给这些对象，而不是自己实现这些行为。 如何实现 确定客户希望通过“flex ponit”访问的算法。 为这个算法所有的实现声明通用的接口。 挨个把这些算法抽离到它们自己的类中。它们都应当遵循通用的Strategy接口。 给Context类增加一个字段来关联当前使用的策略，并提供一个setter方法用来改变策略。上下文应当只通过Strategy接口和策略协作。 当客户端需要上下文来以某种方式工作的时候，必须提供一个合适策略对象。 优点 允许在运行时热替换算法。 对其他类隔离代码和算法数据。 用委托替代继承。 符合开闭原则。 缺点 通过创建多个额外类增加代码复杂度。 客户端必须关心策略间的差异以便选择正确的策略。 和其他模式的关系 State，Strategy，Bridge（和某种程度上的Adapter）都有相似的解决结构。它们都是共享“handle/body”句柄。它们的意图不一样，所以他们用来解决不同的问题。 Command和Strategy很相似，因为他们都是把一些行为参数化到上下文。Command可以用爱把任何操作转换到一个对象中。可选的参数变成了那个对象的字段。这个转换允许延迟或者远程执行，存储命令历史等。 另一方面，Strategy模式通常用来描述处理相同事情的不同方式。它可以帮助我们让这些算法在一个单独的上下文类中是可替换的。 Decorator可以让你改变一个对象的皮肤（外部表象）。Strategy让你改变胆子（内部实现）。 Template Method使用继承来改变算法（子类扩展父类的某些方法）。Strategy通过把工作委托给可替换的策略对象来改变对象的行为。模版方法模式工作在类这一层面。策略模式允许你改变个性化对象的行为。 State可以看作是Strategy模式的一种扩展。这两种模式都采用组合的方式来改变主对象的行为，主对象委托工作给这些帮助对象。Strategy模式让这些对象完全独立。State模式允许状态对象改变上下文对象的当前状态，他们之间是相互依存的。 小结策略模式是行为模式的一种，他把一系列行为分解到不同的对象中，使得他们在源上下文对象中可以互换。 源对象被叫做上下文，他会持有一个策略对象的引用，并把任务委托给策略执行。为了改变上下文处理工作的方式，其他对象可以修改当前上下文中的策略对象。 参考翻译整理自：https://refactoring.guru/design-patterns/strategy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之State]]></title>
      <url>%2F2018%2F01%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BState%2F</url>
      <content type="text"><![CDATA[意图State是行为模式的一种，它允许你在对象内部状态发生变化时改变其行为。这个对象会改变它的类。 问题状态模式和有限状态机很相似。 它主要的思想是程序是几个状态之一，这些状态相互关联。状态的数量和它们之间的转换是有限的并且是预先定义的。根据当前的状态，程序对相同的事件会有不同的响应。 类似的方法可以应用到对象上。比如，Document（提案）对象可以是以下三种状态之一：Draft（草案），Moderations（待审）和Publish（发布）。对每种状态而言，publish方法会有不同的处理方式： 第一种状态，它将改变提案的状态到待审。 第二种状态，它将使提案变成发布状态，当然只有在当前用户是管理员时。 第三种状态，它什么也不做。 状态机通常基于许多条件操作来实现，比如，if或者wsitch来检查当前状态并作出适当的行为。即使你第一次听说状态机，你很可能已经至少实现多一次。下面这段代码看起来是不是很眼熟？ 1234567891011121314151617class Documentstring state;// ...method publish() &#123; switch (state) &#123; "draft": state = "moderation"; break; "moderation": if (currentUser.role == 'admin') state = "published" break; "published": // Do nothing. &#125;&#125;// ... 当你你要添加更多状态或者状态依赖行为到Document中时，使用条件构建起来的状态机最大的限制就展露出来。大多方法需要有很多条件参数来决定这个状态下的正确行为。 这些代码很难维护，因为任何转换逻辑的改变都需要在每个方法中对每个条件做双重检查。 项目越老这个问题往往越大，因为在设计阶段事先预测所有可能的状态和转换是相当困难的。因此，一个由少量条件构成的精简状态机随着时间的推移会变的一团糟。 解决状态模式建议为上下文对象的所有可能状态创建新类，并将与状态有关的行为提取到这些类中。 上下文将会包含一个代表当前状态的状态对象。上下文将把执行交给状态对象，而不是自己去处理。 为了改变上下文对象，一个状态对象可以将另一个状态对象传到上下文中。但是为了让状态可以呼唤，所有的状态类必须遵循相同的接口，并且上下文必须通过状态对象的接口和它通信。 上面描述的结构看起来有些像Strategy模式，但是它们有一个关键点不同。在状态模式中，上下文和特定的状态都可以发起状态间的转换。 真实世界类比智能手机智能手机当前处于不同的状态会有不同的行为： 当手机处于解锁状态，按下按钮会执行一些列功能。 当手机被锁定，所有的按钮都会展示解锁画面。 当手机电量低，所有按钮都会展示充电画面。 结构 Context（上下文）持有Concrete State（具体状态）对象的引用，并把状态相关的行为委托给它。上下文通过状态通用的接口和状态对象协作。上下文必须报漏出一个方法来接收一个新状态对象。 State（状态）为具体状态声明通用的接口。它声明的方法应当对所有的状态都是有意义的。但是每个状态应该提供不同的实现。 Concrete State实现特定状态的行为。增加状态基类避免在多个状态中出现重复代码。 一个状态可以持有上下文的引用。这不仅让它可以访问上下文数据，也提供了一种法器状态转变的方式。 上下文和具体的状态都可以决定何时发起状态转换及决定转换到什么状态。为了处理转换，一个新的状态对象应当被传给上下文。 伪代码在这个例子中，状态模式依赖当前不同的播放器的状态来控制播放器不同的行为。Player主类持有一个状态对象的引用，它被用来处理播放器的大多数工作。用户的一些操作会使播放器转换到另一个状态。 状态模式让播放器改变其行为而对其他对象无感知。转换可以被播放器本身或者特定的状态对象执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// Common interface for all states.abstract class State is protected field player: Player // Context passes itself through the state constructor. // This may help a state to fetch some useful context // data if needed. constructor State(player) is this.player = player abstract method clickLock() abstract method clickPlay() abstract method clickNext() abstract method clickPrevious()// Concrete states provide the special implementation for// all interface methods.class LockedState is // When you unlock a locked player, it may assume one of // the two states. method clickLock() is if (player.playing) player.changeState(new PlayingState(player)) else player.changeState(new ReadyState(player)) method clickPlay() is Do nothing. method clickNext() is Do nothing. method clickPrevious() is Do nothing.// They can also trigger state transitions in the context.class ReadyState is method clickLock() is player.changeState(new LockedState(player)) method clickPlay() is player.startPlayback() player.changeState(new PlayingState(player)) method clickNext() is player.nextSong() method clickPrevious() is player.previousSong()class PlayingState is method clickLock() is player.changeState(new LockedState(player)) method clickPlay() is player.stopPlayback() player.changeState(new ReadyState(player)) method clickNext() is if (event.doubleclick) player.nextSong() else player.fastForward(5) method clickPrevious() is if (event.doubleclick) player.previous() else player.rewind(5)// Player acts as a context.class Player is field state: State field UI, volume, playlist, currentSong constructor Player() is this.state = new ReadyState(this) // Context delegates handling user's input to a // state object. Naturally, the outcome will depend // on what state is currently active, since all // states can handle the input differently. UI = new UserInterface() UI.lockButton.onClick(this.clickLock) UI.playButton.onClick(this.clickPlay) UI.nextButton.onClick(this.clickNext) UI.prevButton.onClick(this.clickPrevious) // Other objects must be able to switch Player's // active state. method changeState(state: State) is this.state = state // UI methods delegate execution to the active state. method clickLock() is state.clickLock() method clickPlay() is state.clickPlay() method clickNext() is state.clickNext() method clickPrevious() is state.clickPrevious() // State may call some service methods on the context. method startPlayback() is // ... method stopPlayback() is // ... method nextSong() is // ... method previousSong() is // ... method fastForward(time) is // ... method rewind(time) is // ... 适用性 当你有一个对象在不同状态下会有不同行为时。状态的数量有很多。状态关联的代码经常改变。 状态模式建议隔离那些和状态相关的代码到不同的类中。源类被叫做“上下文”，它要持有这些状态对象中的其中一个。它应当把工作委托给这个状态对象。这种结构允许通过提供给上下文不同状态对象的方式改变上下文的行为。 当一个类被大量的通过当前类字段值来改变方法行为的条件污染。 状态模式把条件分支转换成合适状态类中的方法。然后需要依赖多态吧执行委托到关联的状态对象。 在基于条件的状态机中有大量重复代码分布在相似状态和转换中时。 状态模式允许你组合状态类的层次，通过把通用的代码移动到层级的基类中来减少重复。 如何实现 声明那个类来扮演Context角色。这可能是一个存在的类，已经有了状态依赖的相关代码；或者是一个新类，如果状态相关的代码分布在各个类中。 创建State接口。大多情况下，他将镜像声明在Context中的方法。 为每个真正的状态，创建一个State接口的实现。遍历Context的方法，把所有和状态有关的代码放到对应的状态类中。 添加一个State类型的引用字段到Context类中，并且需要提供一个可复写这个字段值的public方法。 再一次遍历Context中的方法，用状态对象的相应方法替换剩余的状态条件部分。 为了转换Context的状态，必须创建一个状态实例传给上下文。这步可有Context自己，或者通过State，或者Client来完成。注意，创建者将需要依赖具体的State类进行实例化。 优点 消除状态机条件。 把与特定状态相关的代码组织到不同的类中。 简化代码上下文。 缺点 如果一个状态机只有少数几个状态或很少发生变化，那么这可能是过度设计。 和其他模式的关系 State，Strategy，Bridge（某种意义上的Adapter）有相似的解决结构。他们都共享“handle/body”元素。他们的意图有所不同 - 也就是说，他们解决不同的问题。 State可以看作是Strategy模式的扩展。这两种模式都使用组合把工作委托给辅助对象来改变主对象的行为。但是，State模式允许状态对象用另一个状态改变当前上下文的状态，使得它们相互依赖。 小结State是一种行为设计模式，允许对象在其内部状态改变时改变行为。该模式将与状态相关的行为提取为单独的状态类，并强制原始对象将工作委派给状态类的实例，而不是自行处理。 参考翻译整理自：https://refactoring.guru/design-patterns/state]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Observer]]></title>
      <url>%2F2018%2F01%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BObserver%2F</url>
      <content type="text"><![CDATA[意图Observer是行为模式的一种，允许你定义对象间一对多的关系，以便一个对象状态改变后，它的依赖者可以被通知并可以自动更新。 问题假设你有两个对象，Customer和Store。商店采购了一批新产品，一些客户对这些产品很感兴趣。 客户可能每天都来商店看下是否有感兴趣的产品售卖，但大多情况下的是无意义的，因为产品还在路上。 另一方面，商店可以给所有的客户发送上新的邮件。但是对那些不关心这类产品的用户来说是不必要的。 因此，我们遇到了一个冲突：是客户浪费时间来顶起检查还是商店浪费时间来通知到错误的客户。 解决我们把有一些有趣状态的对象叫做Publisher。把另外那些想要追踪状态改变的对象叫做Subscriber。 Observer模式提供一个发布者，他有要追踪状态订阅者的列表。这个列表可以通过几个订阅方法来供订阅者修改。因此，在任何时候，每个订阅者都能够把自己从列表中添加或者移除。发布者每次有新的事件发布，它会遍历它的订阅者列表并调用订阅者的通知方法。 发布者可以和任何订阅者协作，因为他们都遵循通用的接口。这个接口生命力一个带有一些参数的通知方法，这些参数提供给订阅者事件的细节。 如果应用有几个发布者类型，通用的发布者接口也需要提取出来。它由几个订阅方法组成。这个接口允许订阅者观察发布者的状态却不必和某个具体的实现类耦合。 类比杂志订阅一旦你订阅了杂志或者报纸，你不在需要去商店检查是否有新的杂志或者报纸发布。相反，发布者将会在期刊发布后直接发送到你的邮箱。 发布者维护了订阅者的信息，并且知道他们感兴趣的杂志。如果订阅者不想发布者再发送新的杂志给他们，他们可以随时取消对杂志的订阅。 结构 Publisher（发布者）发布其他对象感兴趣的事件。这些事件发生在发布者改变了他的状态或者它执行力一些行为时。发布者包含订阅的基本设施，允许新订阅者的加入和老订阅者的退出。 当一个新事件发生，发布者遍历订阅者列表并调用他们的通知方法，这些方法声明在Subscriber（订阅者）接口中。 Subscriber（订阅者）声明通知接口。大多情况下，它只有update方法。这个方法可能有几个参数让订阅者可以获取到事件详情。 具体的订阅者实现通知接口并且响应发布者发布的事件。 订阅者只需要一个简单的方法来争取的处理更新。基于这个原因，发布者通常把一些上下文数据当作这个方法的参数传递给订阅者。甚至可能是发布者自身的引用。 客户端分别创建发布者和订阅者对象，并且把订阅者注册到发布者。 有时候，订阅者可以直接访问发布者是很便利的。这个链接通常通过订阅者的构造方法建立。它允许订阅者在收到通知后直接从发布者抓取更新的状态。 伪代码在这个例子中，Observer允许文本编辑器对象通知其他对象状态的变化。订阅者列表是动态编译的。对象可以在运行期间开始或者停止对更新的监听。 在这个实现中，编辑器自己维护订阅者列表而不是把它委托给特别的helper对象。这允许其他对象复用订阅基础结构。因此，Observer模式允许动态配置对象内发生的各种事件的处理者。 添加新的订阅者不需要改变已经存在的发布者类，只要他们之间通过通用接口协作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Base publisher class. It should include the subscription// management code and notification methods.class EventManager is private field listeners: hash map of event types and listeners method subscribe(eventType, listener) is listeners.add(eventType, listener) method unsubscribe(eventType, listener) is listeners.remove(eventType, listener) method notify(eventType, data) is foreach listener in listeners.of(eventType) listener.update(data)// Concrete publisher, which contains real business logic// interesting for some subscribers. We could derive this// class from a base publisher, but that is not always// possible in real life, since the concrete publisher might// already have a different parent class. In this case, you// can patch the subscription logic in with composition,// just like we did it here.class Editor is private field events: EventManager private field file: File constructor Editor() is events = new EventManager() // Business logic methods can notify subscribers about // the changes. method openFile(path) is this.file = new File(path) events.notify("open", file.name) method saveFile() is file.write() events.notify("save", file.name) // ...// Common subscribers interface. By the way, modern// programming languages allow to simplify this code and use// functions as subscribers.interface EventListener is method update(filename)// List of concrete listeners. They react to publisher// updates by doing some useful work.class LoggingListener is private field log: File private field message constructor LoggingListener(log_filename, message) is this.log = new File(log_filename) this.message = message method update(filename) is log.write(replace('%s',filename,message))class EmailAlertsListener is private field email: string constructor EmailAlertsListener(email, message) is this.email = email this.message = message method update(filename) is system.email(email, replace('%s',filename,message))// Application can configure publishers and subscribers even// in run time.class Application is method config() is editor = new TextEditor() logger = new LoggingListener( "/path/to/log.txt", "Someone has opened file: %s"); editor.events.subscribe("open", logger) emailAlers = new EmailAlertsListener( "admin@example.com", "Someone has changed the file: %s") editor.events.subscribe("save", emailAlers) 适用性 当一个对象的状态发生变化其他对象也需要改变，但是这些对象事先不知道或者需要动态改变时。比如，你在开发一个专注于按钮的GUI框架。你想你的客户端能够在用户按下按钮时回调一些定制的代码。 Observer模式允许任何实现了订阅者接口的对象到发布者订阅事件通知。 一些对象需要观察其他对象，但只在限定的时间内或者特别的情况下。 Observer模式让发布者维护一个动态的订阅列表。所有的订阅者可以在运行时随时加入或者离开这个列表。 如何实现 区分核心（独立的）功能和可选（依赖的）功能。前者扮演发布者，后者扮演订阅者。 创建Subscriber接口。大多情况下，一个update方法足够。 创建Publisher接口并且定义开始和结束订阅操作。切记，发布者和订阅者通过通用接口协作。 你必须决定真实的订阅列表和订阅方法的实现放在哪里。通常，这些代码对所有类型的发布者而言都差不多。所以最恰当的地方是放在Publisher接口派生出的抽象基类中。但是如果你在已存在的类结构层次中集成Observer，那么创建一个小的helper类来维护制定发布者的订阅关系会比较方便。 创建具体的发布者类。在每次有重要事件发生时，他们都应当通知列表中所有的订阅者。 在具体的订阅者类中实现update方法。大多订阅者需要事件的上下文数据。可以通过update方法的参数传递给接受者。但是还有另外的方式。在收到通知后，接受者可以直接从发布者对象中抓取任何数据。在这种情况下，发布者必须把它自己当作参数传递给接受者。最不灵活的方法是通过订阅者构造方法持久的建立和发布者的关系。 客户端代码必须创建所有必须的订阅者并把它们注册到正确的发布者上。 优点 发布者不会和具体的订阅者类耦合。 你可以动态的订阅或者取消订阅。 -遵循开闭原则。 缺点 通知到订阅者的顺序是随机的。 和其他模式的关系 CoR、Command、Mediator和Observer处理各种方式的发送者和接受者： CoR让请求沿着一个动态的潜在接受者链条传递直到某个接口者处理它。 Command建立了发送者和接受者的单项链接。 Mediator让发送者和接受者相互间简介关联。 Observer在同一时间把请求发送给所有关心的接收者，但是允许他们动态的订阅和取消订阅之后的请求。 Mediator和Observer模式的区别常常很模糊。在大多数情况下，模式间是竞争的，但有时他们可以合作。 Mediator调模式的主要目标是消除一组系统组件之间的相互依赖关系。所有组件都变成独立的对象。另一方面，Observer的主要目的是建立对象间动态的单向链接，其中一些随想作为其他对象的下属。 有一个非常受欢迎的Mediator实现依赖于Observer模式。中间人对象扮演发布者，所有的同事组件扮演订阅者。他们动态的订阅和取消订阅中间人的事件。这种实现方式看起来和两种模式都很像。 但是Mediator模式可以有不同的实现方式，比如所有的组件都永久连接到形同的中间人对象。这种实现看起来不像Observer，但仍是Mediator模式的一个例子。 现在想象另一个程序，其中所有的组件都是发布者，并允许彼此动态链接。这里没有一个中央中间人对象，而是一个分布式的观察员系统。 参考翻译整理自：https://refactoring.guru/design-patterns/observer]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Mediator]]></title>
      <url>%2F2018%2F01%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BMediator%2F</url>
      <content type="text"><![CDATA[意图Meditor是行为模式的一种，允许你定一个对象来封装一些对象的关联关系，以使这些对象相互独立。 问题你有一个对话框用来编辑用户的配置。它是由TextEdit、Checkboxes、Button等组成的表单。 表单中元素会相互影响。比如，“我有一条狗”的复选框应当展示隐藏的文本框用来输入狗的名字。另外一个例子是提交按钮在保存数据钱必须娇艳所有字段的数据。 把这些逻辑直接放在表单元素代码中，使得这些类难以被app其他表单复用。比如，你不能使用另一个表单中的复选框，因为它和狗名字的文本框紧密耦合。 解决Mediator模式阻止单个组件间的直接交。取而代之，他们发行请求到中间人对象，这个对象知道如何引导请求。组件摆脱了相互间的依赖，只和中间人对象有关联。 在我们的例子中，对话框类可以当这个中间人。可能，甚至不需要在类中添加任何新的依赖关系，因为对话框已经知道它的子表单元素。 表单元素代码会发生重大的变化。比如，提交按钮之前必须在按钮点击后校验变淡元素，但是现在它只需要发出被点击的通知即可。收到提交通知后，对话框自己完成所有的校验。通过这种方式，按钮将只需要依赖对话框类。 你甚至可以更进一步使得依赖更加宽松，为所有对话框抽离出一个通用接口。这个接口需要声明一个方法去通知对应表单元素相关的事件。这样，我们的提交按钮就可以和任意一个遵循这个接口的的对话框通信。 通过这种方式，Mediator模式包装各个组件的关联关系到一个单独的中间人对象中。类的依赖越少，修改、扩展或重用它就越容易。 现实世界类比空中管制塔台控制机场很形象的展示了Mediator模式。飞行员在降落或者起飞时和塔台通信，而不是和其他飞行员直接通信。塔台控制哪架飞机可以起飞或者降落。 注意，塔台并不控制整个航程，只对终端区域进行管制。 结构 Components（组件）是包含业务逻辑程序的各种对象。每个组件都持有一个中间人的引用。组件不关心中间人的实际类型，因为他们通过Mediator接口协作。这允许在其他程序中复用组件，只要改变他们的关联中间人即可。 组件也不关心其他组件。当它们的状态改变时，它们只需要通知中间人。中间人知道哪些组件需要响应这个事件。 Mediator声明了和Component通信的接口，它通常含有一个方法。组件组件使用这个方法通知中间人他们发生了一个重要的事件。组件把他们自己当作事件的一部分传给通知方法。 中间人接口是已存在组件可被其他程序崇重用的关键。你需要做的是提供一个新的中间人来控制组件如何在新的上下文中同其他组件协作。 Concrete Mediator（具体的中间人）封装了各个组件间的关系。中间人通常持有它它管理的所有组件的引用。 具体的中间人常常和他们的组件紧密耦合。当中间人收到一个通知，他可以轻松的识别出发送者。它也知道哪个组件应当被触发。但是对组件而言，它就是一个黑盒。发送者不知道谁来处理它的事件，接受者也不知道谁发出的这个事件。 伪代码在这个例子中，Mediator模式帮助消除UI类间的相互依赖：按钮、复选框和文本标签。当用户与元素进行交互时，他们不直接进行通信，而是把这个事件通知给中间人。 认证对话框扮演了这个中间人。它知道具体的要素应该如何协作并促进其合作。在接收到一个通知事件后，他把事件传递给适当的组件来执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// The mediator interface.interface Mediator is method notify(sender: Component, event: string)// The concrete mediator class. All chaotic communications// between concrete components were extracted to the// mediator class.class AuthenticationDialog implements Mediator is private field title: string private field loginOrRegister: Checkbox private field loginUsername, loginPassword: Textbox private field registrationUsername, registrationPassword private field registrationEmail: Textbox private field ok, cancel: Button constructor AuthenticationDialog() is Create all component objects. Link meditor with components via constructor params. // When something happens with a component, it notifies // the mediator. Upon receiving a notification, the // mediator may do something on its own or pass the // request to another component. method notify(sender, event) is if (sender == loginOrRegister and event == "check") if (loginOrRegister.checked) title = "Log in" Show login components Hide registration components. else title = "Register" Show registration components. Hide login components if (sender == ok and event == "click") if (loginOrRegister.checked) Try to find user using login credentials. if (!found) Show errors over login fields. else Create account using registration fields. Log user in. // ...// Components communicate with a mediator using the mediator// interface. Thanks to that, you can use the same// components in other contexts by linking them with a// different mediator object.class Component is field dialog: Mediator constructor Component(dialog) is this.dialog = dialog method click() is dialog.notify(this, "click") method keypress() is dialog.notify(this, "keypress")// Concrete components do not talk to each other. They have// only one communication channel, which is sending// notifications to the mediator.class Button extends Component is // ...class Textbox extends Component is // ...class Checkbox extends Component is method check() is dialog.notify(this, "check") // ... 适用性 当组件间依赖混乱，某个组件简单的改变导致其关联的组件都需要改变。 中间人把类之间的关系抽离到一个单独的类中，使得一个组件的改变对其他代码是隔离的。 当你无法在不同的程序中复用一个组件，因为它太依赖其他组件。 使用了中间人后，组件个体不在关心其他组件。他们通过中间人间接通信。在不同的app中复用一个组件只需要创建一个新的中间人类。 当你必须创建组件的多个子类但只是为了在不同的上下文中使用相同的组件时。 中间人封装了组件之间的关系。因此，完全可以创建一个新的中间人子类为同一群组件定义一个新的关系。 如何实现 确定一组紧密联系的类，他们如果相互更加独立，我们能从中获得收益。 创建Mediator接口并且声明其和各个组件间的通讯协议。大多情况下，定义一个从组件接收通知的方法就足够了。 在具体的Mediator中实现这个方法。Mediator类最好持有它管理的所有组件的引用。 你甚至可以把创建组件的代码挪到Mediator中。这将使中间人变成一个工厂。 组件也应当持有中间人的引用。这个链接通常在组件的构造方法中建立，中间人对象是组件构造方法的一部分。 改变组件的代码以便当一些事情发生时它能够调用中间人的通知方法。剥离真正的业务代码到Mediator类中，并在其接收到组件的通知后执行它。 优点 减少一个程序中组件的耦合。 允许复用单个组件。 集中各个组件之间的通信。 缺点 Mediator可能会发展成God Object。 和其他模式的关系 CoR、Command、Mediator和Observer处理各种方式的发送者和接受者： CoR让请求沿着一个动态的潜在接受者链条传递直到某个接口者处理它。 Command建立了发送者和接受者的单项链接。 Mediator让发送者和接受者相互间简介关联。 Observer在同一时间把请求发送给所有关心的接收者，但是允许他们动态的订阅和取消订阅之后的请求。 Mediator和Facade在抽象已存在类的功能这点上很像。Mediator 抽象/集中同事间的任意通信。它通常“添加值”并且是同事对象所知道/参考的。相比之下，Facade为子系统定义了一个更简单的接口，它不会增加新的功能，而且子系统类也不知道它的存在。 Mediator和Observer模式的区别常常很模糊。在大多数情况下，模式间是竞争的，但有时他们可以合作。 Mediator调模式的主要目标是消除一组系统组件之间的相互依赖关系。所有组件都变成独立的对象。另一方面，Observer的主要目的是建立对象间动态的单向链接，其中一些随想作为其他对象的下属。 有一个非常受欢迎的Mediator实现依赖于Observer模式。中间人对象扮演发布者，所有的同事组件扮演订阅者。他们动态的订阅和取消订阅中间人的事件。这种实现方式看起来和两种模式都很像。 但是Mediator模式可以有不同的实现方式，比如所有的组件都永久连接到形同的中间人对象。这种实现看起来不像Observer，但仍是Mediator模式的一个例子。 现在想象另一个程序，其中所有的组件都是发布者，并允许彼此动态链接。这里没有一个中央中间人对象，而是一个分布式的观察员系统。 小结Java代码中Mediator模式最流行的用法是促进应用程序的GUI组件之间的通信。Mediator的同义词是MVC模式的控制器部分。 在Java核心库中有以下使用该模式的例子： java.util.Timer (所有的scheduleXXX()方法) java.util.concurrent.Executor#execute() java.util.concurrent.ExecutorService (invokeXXX()和submit()方法) java.util.concurrent.ScheduledExecutorService (所有的 scheduleXXX()方法) java.lang.reflect.Method#invoke() 参考翻译整理自：https://refactoring.guru/design-patterns/mediator]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Iterator]]></title>
      <url>%2F2018%2F01%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BIterator%2F</url>
      <content type="text"><![CDATA[意图Iterator是行为模式的一种，允许在不暴露底层结构的情况下顺序访问聚合对象中的元素。 问题集合是编程中最常用的数据结构。它把一组对象放到一个单独的容器中。 大多集合看起来都像元素的列表。然而，一些集合以树、图或者其他复杂数据结构组织数据。并且每个集合都必须提供一个方法让用户可以按照顺序处理集合中的元素。 但是，要怎么顺序遍历一个复杂结构呢？必须有几个方法来做到这一点。比如，今天想要深度优先来遍历树。但是，明天又想宽度优先来遍历。下周，又可能需要随机访问集合元素。添加越来越多的遍历算法使其丧失了它主要的职责，即高效存储数据。另一方面，一些特定的算法只只在指定的应用场景中适用。 解决Iterator模式建议抽出集合遍历方法到一个叫做“Iterator”的独立对象中。 迭代器封装遍历细节，像当前位置及还有多少元素需要遍历。允许几个迭代器去独立遍历相同的集合。集合本身甚至不知道有人在访问它的元素。 甚至，如果你需要一个特别的方式来遍历一个集合，你只需要创建一个新的迭代器类而不需要改动集合代码。 真实世界的类比旅游向导你计划去罗马一周来参观它所有的景点。但是到那后，你花了很长的时间来找斗兽场。 另一方面，你还有些备用预算可以请当地的导游。这个导游可以带你去看每个景点并且能给你讲许多有趣的故事。 如果预算不够，你可以在手机上使用虚拟导游。它虽然没有真正的导游那么有趣，但是便宜。你可以只去你感兴趣的地方。 真正的导游和虚拟导游都是罗马提供的遍历景点的迭代器。 结构 Iterator定义了遍历集合的接口。通常有获取下/上一个元素方法和用来跟踪是否迭代完毕的方法。 具体的Iterator实现遍历集合的特定算法。迭代器对象应当自己追踪遍历进度。它允许几个迭代器独立遍历相同的集合。 Collection接口声明了可以被迭代的集合。正如我们之前提到的，不是每一个集合都被表示成一个列表。集合可能把元素存储在一个数据库中，需要通过远程API获取他们；或者存储在一个Composite树中。因此，集合本身可能会创建迭代器，因为有一定数量的迭代器能够处理给定的集合类型。 具体的Collection在每次客户端请求时都会返回一个新的特定的迭代器实例。注意，这个方法的参数都要返回抽象迭代器类型。这将使得客户端和具体的迭代器独立。 客户端通过集合和迭代器的通用接口工作。这种方式让客户端与具体的类解耦。它允许添加新的迭代器并且不要修改现有代码。 通常，客户端自己不创建迭代器，而是从集合对象获取。但是客户端总是可以直接创建迭代器如果它需要特定的迭代器。 伪代码在这个例子中，迭代器模式被用来遍历封装了访问Facebook社交关系的集合。这个集合提供了几种可以以不同方式遍历配置文件的迭代器。 friend迭代器遍历给定配置集合中所有的朋友。colleague迭代器遍历同样遍历给定配置文件集合中的朋友但跳过了那些不是同事的朋友。所有的迭代器遵循相同的接口，这些接口允许客户端在不深入社交网络细节的情况下获取配置（比如，认证，发送REST请求等）。 因为客户端代码通过通用接口同集合、迭代器协作，所以，需要支持新的社交网络时仅需要添加新的集合类，而不用改变现有代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// The collection interface must declare a factory method for producing// iterators. You can declare several methods if there are different kinds// of iteration available in your program.interface SocialNetwork is method createFriendsIterator(profileId): ProfileIterator method createCoworkersIterator(profileId): ProfileIterator// Each concrete collection will be coupled to a set of concrete iterator// classes it returns. But the client will not be, since the signature of these// methods returns iterator interfaces.class Facebook implements SocialNetwork is // ... The bulk of the collection's code should go here ... // Iterator creation code. method createFriendsIterator(profileId) is return new FacebookIterator(this, profileId, "friends") method createCoworkersIterator(profileId) is return new FacebookIterator(this, profileId, "coworkers")// The common interface for all iterators.interface ProfileIterator is method getNext(): Profile method hasMore(): bool// The concrete iterator class.class FacebookIterator implements ProfileIterator is // The iterator needs a reference to the collection that it traverses. private field facebook: Facebook private field profileId, type: string // An iterator object traverses collection independently from other // iterators. Therefore it has to store the iteration state. private field currentPosition private field cache: array of Profile constructor FacebookIterator(facebook, profileId, type) is this.facebook = network this.profileId = profileId this.type = type private method lazyInit() is if (cache == null) cache = facebook.sendSophisticatedSocialGraphRequest(profileId, type) // Each concrete iterator class has its own implementation of the common // iterator interface. method getNext() is if (hasMore()) currentPosition++ return cache[currentPosition] method hasMore() is lazyInit() return cache.length &lt; currentPosition// Here is another useful trick: you can pass an iterator to a client class,// instead of giving it access to a whole collection. This way, you do not// expose the collection to the client.//// But there is another benefit: you can change the way the client works with// the collection at run time by passing it a different iterator. This is// possible because the client code is not coupled to concrete iterator classes.class SocialSpammer is method send(iterator: ProfileIterator, message: string) is while (iterator.hasNext()) profile = iterator.getNext() System.sendEmail(profile.getEmail(), message)// The application class configures collections and iterators and then passes// them to the client code.class Application is field network: SocialNetwork field spammer: SocialSpammer method config() is if working with Facebook this.network = new Facebook() if working with LinkedIn this.network = new LinkedIn() this.spammer = new SocialSpammer() method sendSpamToFriends(profile) is iterator = network.createFriendsIterator(profile.getId()) spammer.send(iterator, "Very important message") method sendSpamToCoworkers(profile) is iterator = network.createCoworkersIterator(profile.getId()) spammer.send(iterator, "Very important message") 适用性 当你有一个复杂的数据结构，并且你想对客户端隐藏它的复杂性（为了安全或者方便）。 迭代器封装与复杂数据结构的交互并保护它免受粗心和恶意行为。迭代器模式允许客户端和集合元素协作而不必暴露集合对象。 当你需要几种不同的遍历数据结构的方式，但是你不能把它加到集合中或者这个代码和业务逻辑关联。 遍历数据结构的算法可能很大。把它放在集合或者主业务逻辑代码中，导致原有代码责任不明确且难以维护。把这些代码放在迭代器中让应用代码简洁和清晰。 当你想要一个单独接口来遍历不同的数据结构。 迭代器为所有实现者提供了通用的接口，允许在客户端代码中更换不同的迭代器。 如何实现 定义Iterator接口。它至少包含用来获取容器中下一个元素的方法。方便起见，它还可以包含获取上一个元素，追踪当前位置，检查是否到达迭代器尾部等方法。 创建Collection接口，它要提供获取一个新迭代器的方法。注意，它应当返回抽象迭代器类型。 为一个可迭代的集合实现一个具体的迭代器类。一个迭代器只能关联一个集合实例。通常通过迭代器的构造方法产生关联。 在相应的集合类中实现Collection接口。他们应当创建并返回一个适当的迭代器实例。集合通过迭代器的构造方法和迭代器建立关联。 在使用了这个模式后，在集合和客户端代码中应该不会再有遍历的代码。客户端每次需要迭代集合元素时都要通过集合获取新的迭代器。 优点 简化集合代码。 提供不同的方式遍历相同的数据结构。 允许并行遍历相同的集合。 缺点 对于使用简单集合的程序来说，有些导致矫枉过正。 和其他模式的关系 Iterator可以用来遍历Composite树。 Factory Method可以和Iterator一起使用，让集合的子类返回合适的迭代器。 Memento可以和Iterator一起使用来捕捉迭代器的当前状态，后面如果需要可以进行回滚。 Visitor可以和Iterator一起使用来遍历一个复杂的数据结构，并在这些元素上执行一些操作，即使他们类型不同。 小结Iterator可以在不暴露复杂数据结构的前提下让客户端顺序访问其元素。 Iterator模式在Java代码中很常见。很多框架和库都提供一种标准的方式来遍历他们的集合。 Java核心库中的java.util.Iterator和java.util.Enumeration是很好的例子。 参考翻译整理自：https://refactoring.guru/design-patterns/iterator]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Memento]]></title>
      <url>%2F2018%2F01%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BMemento%2F</url>
      <content type="text"><![CDATA[意图Memento是行为模式的一种，他允许你在不暴露对象内部结构的情况下捕获其内部状态，以便稍后对象可以返回到这个状态。 问题假设你在写一个文本编辑器。核心逻辑放在Editor主类中。另外一些特性，像文本格式化，内联图像等，放在不同的命令类中。 你决定让用户的操作变得可逆。换句话讲，要增加“撤销”功能。为了实现它，你需要在执行任何操作前保存Editor的状态。之后，如果用户决定还原他的一些操作，程序要从历史中拿出快照并恢复Editor到过去状态。为了拷贝一个对象的状态，你必须遍历它的字段并拷贝字段的值。但是，一个对象必须要有宽松的访问它内容的方式，可以让其他对象窥视其内部并拷贝他的内容。 虽然这种方式可以简单完成这个任务并且允许每个类都能够生产编辑器的备份，但是这种方式与我们的想法相去甚远。如果你决定重构或者修改Editor类的字段，你就必须同时修改那些和Editor耦合的类。 更近一步。我们考虑下真实的Editor备份。即使最原始的编辑器也必须有一些字段来存储数据，比如真实的文本，游标坐标，当前滚动的位置等。为了创建一个备份，你必须记录所有的值并把它们放到一些容器中。 这个容器中最终放置了一些类的对象。这些类可能有许多编辑器状态的镜像字段并且没有什么方法。为了允许其他对象能够读写数据到备份对象，你肯能需要把字段声明为public。但是，这将导致与无限制的Editor类相同的问题。Editor的变化将会影响其他的类。 看起来这个问题无解了。你要么暴露一个类的内部，使得所有关联的类变得脆弱，要么限制对状态的访问，使得撤销操作难以实现。难道没有其他方法了吗？ 解决上面问题的本质是破坏了封装。当一些对象试图做比他们想象的更多的事情时，往往会发生这种情况。这些对象不是请求其他对象为他们做一些事情，而是入侵了其他对象的私有空间来搜集执行动作需要的数据。 Memento模式把创建状态快照的工作委托给状态拥有者本身，也即是Originator对象。因此，也就不需要其他对象从外部拷贝Editor的状态，Editor本身就可以创建快照，因为它自己可以访问自己的所有状态。 模式提供了一种特殊对象来存储对象状态的快照，叫做Memento。memento的内容除了创建者自己外其他的对象都无法访问。其他对象可以通过限制性接口和menento交流，该接口只允许获取快照的元数据，比如创建时间，标签等。 这些数据保护允许把memento存储在叫做Caretakers的对象中。因为他们只能通过限制性接口访问menento，caretakers无法修改存储在里面的状态。 在编辑器例子中，我们创建一个单独的History类来扮演caretakers。它把memento组织成一个栈，每个操作被执行前它会被压入新的memento。当用户触发撤销操作，History弹出栈顶memento并把它传给Editor，请求回滚。因为Editor可以完全访问memento，它将用memento的状态值覆盖当前变量值。 结构嵌套类实现经典的实现方式依赖编程对嵌套类的支持，许多流行的编程语言（C++，C#和Java）都支持该方式。 Originator包含复杂的状态并且你不想把它们暴露出去。它能够自己创建快照，也能够在需要的时候从快照恢复。 Memento是一个值对象，用来扮演Originator状态的快照。最佳实践是将Memento做成不可变的，并且Memento只通过其构造方法接收一次数据。 Caretaker不仅知道何时及为什么要捕捉Originator的状态，也知道什么时候应该恢复状态。 caretaker能够把originator的状态存储成一个栈。当originator要回到历史时，caretaker拿到栈顶数据并把它传给originator的恢复方法。 这种实现的下，Memento是Originator的嵌套类，Memento可以访问Originator的变量和方法，即使他们被声明为private。另一方面，Caretaker被限制性访问Memento的字段和方法，这对存储memento很好但是对修改他们的状态不是很好。 中间接口实现不支持嵌套类语言（PHP）的替代方式。 在没有嵌套类的情况下，通过让caretaker使用有限接口和memento协作来限制其对memento的访问。 另一方面，originator可以直接和memento类协作并访问他的public方法，而caretaker不行。 更严格的封装实现当你不想给远程的其他类通过Memento来访问Originator状态时，这种方式很有用。 这种实现允许有多个类型的originator和memento。每个originator和其对应的memento协作。originator和memento不把他们的状态暴露给任何人。 Caretaker不能间接修改memento存储的状态。甚至，它独立与originator。和originator的关联及恢复方法都移动到memento中。 每个memento都关联指定的originator。originator把它自己和状态值一起传入到memento的构造方法中。由于具体的memento和originator之间的密切关系，memento可以恢复其originator的状态。 伪代码在这个例子中，采用Memento和Command模式来存储复杂的文本编辑器对象并在需要时恢复它。 command对象扮演caretaker，在它执行前请求editor创建一个memento。当用户需要回滚操作时，之前command关联的memento就可以反转编辑器的状态。 memento不需要有任何public的字段，set或者get方法。因此没有对象可以修改它的内容。memento和创建它的editor关联在一起，能够随意恢复它的状态。这就允许应用支持多个独立的编辑器窗口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Originator class should have a special method, which captures originator's// state inside a new memento object.class Editor is private field text, cursorX, cursorY, selectionWidth method setText(text) is this.text = text method setCursor(x, y) is this.cursorX = cursorX this.cursorY = cursorY method setSelectionWidth(width) is this.selectionWidth = width method createSnapshot(): EditorState is // Memento is immutable object; that is why originator passes its state // to memento's constructor parameters. return new Snapshot(this, text, cursorX, cursorY, selectionWidth)// Memento stores past state of the editor.class Snapshot is private field editor: Editor private field text, cursorX, cursorY, selectionWidth constructor Snapshot(editor, text, cursorX, cursorY, selectionWidth) is this.editor = editor this.text = text this.cursorX = cursorX this.cursorY = cursorY this.selectionWidth = selectionWidth // At some point, old editor state can be restored using a memento object. method restore() is editor.setText(text) editor.setCursor(cursorX, cursorY) editor.setSelectionWidth(selectionWidth)// Command object can act as a caretaker. In such case, command gets a memento// just before it changes the originator's state. When undo is requested, it// restores originator's state with a memento.class Command is private field backup: Snapshot method makeBackup() is backup = editor.saveState() method undo() is if (backup != null) backup.restore() // ... 适用性 当你需要制作一些对象的快照以便稍后恢复其状态时。 Memento模式允许生成对象状态的完整副本，并将其与对象分开存储。虽然这种模式的“撤销”应用已经相当普遍，但在处理交易时也是不可或缺的（如果你需要在出错时会滚一个操作）。 当直接访问对象的字段/setter/getter违反了其封装时。 Memento让对象自己有能力创建自己状态的快照。其他对象不能读取这个快照，使得这个对象的状态变得安全可靠。 如何实现 确定那个类扮演Originator角色。知道程序使用这种类型的一个还是多个中心对象是很重要的（？）。 创建memento类。挨个声明Originator类需要镜像的字段。 让Memento对象不可变。他们应该通过构造方法一次性初始化字段的值。Memento类不应该有setter方法。 如果你的编程语言支持嵌套类，把Memento当作Originator的内部类。 如果不支持，抽象出一个memento类的一个接口，并让其他要和Memento关联的对象使用这个接口。你应该在接口中添加一些操作元数据的方法，但不要暴露originator的状态。 为Originator类添加创建memento的方法。Originator应该通过传递向memento构造方法传递它属性值的方式来创建一个新的memento实例。 这个方法的返回类型应当是之前抽象出来的接口类型（如果你提取了的话）。但是在这个方法内部，你要和具体的memento类型协作。 为Originator类增加恢复状态的方法。这个方法把memento对象当作参数之一。按照与上一步相同的逻辑分配参数类型。 对caretaker而言，不管是操作历史，命令对象，或者其他不同的实体，它都应当知道何时向originator请求一个新的memento，如何存储它以及恢复它。 caretaker和originator的关联关系可以移动到memento中。在这种情况下，每个memento都有与之对应的originator。它将有责任恢复originator的状态。但这仅当memento是originator的内部类或者originator提供了相应的复写其状态的setter方法时。 优点 没有破坏originator的封装。 通过允许caretaker来维护originator历史状态的方式，简化了originator的代码。 缺点 如果客户端频繁创建memento会浪费许多RAM。 caretaker需要追踪originator的生命周期以便清理过时的memento。 大多数动态编程语言，像PHP，Python或者JavaScript，不能保证memento中的状态是不变的。 和其他模式的关系 Command和Memento可以一起使用。他们可以充当魔法token，在稍后时间被传递和调用。在Command中，token代表一个请求；在Memento中，token代表一个对象在特定时间的内部状态。多态对Command很重要，但对Memento不重要，因为它的接口很狭隘所以只能被当作值传递。 Memento可以和Iterator一起只用来捕捉当前迭代的状态，在有必要的时候进行回滚。 如果一个对象想在历史中保存状态相对简单（没有外部资源的链接，或者这些链接很容易重新建立），Prototype可以作为Memento更简单的替代方案。 参考翻译整理自：https://refactoring.guru/design-patterns/memento]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-行为模式之Command]]></title>
      <url>%2F2017%2F12%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8Bcommand%2F</url>
      <content type="text"><![CDATA[意图Command（命令）是一种行为模式，让你可以把请求转换到单独的对象，可以用来把不同的请求参数化，排队或者记录请求，并且支持撤销操作。 问题假设你在做一个新的文本编辑器。你创建了一个Button类，可以被用做工具栏的按钮，也可以用作对话框的通用按钮。 这些按钮看起来很像，但是它们做不同的事情。此时我们要把针对不同按钮点击的处理代码放在哪里呢？简单的解决方法是为每个按钮创建一个Button的子类，然后把处理点击事件的代码放到子类中。 但是这么做的缺点很明显。首先，你创建了许多子类。其次，GUI代码依赖了易变的业务逻辑代码。还有更加讨厌的部分。一些操作，比如拷贝文本，可以在几个不同地方调用。比如，工具栏的按钮，上下文菜单的按钮或者使用Ctrl+C。当应用只有按钮时，拷贝逻辑的代码只会出现在CopyButton子类中。但是，现在你需要拷贝相同的代码到其他两个地方。 解决Command模式建议封装请求到它们各自的命令（command）对象中。如果这个操作有参数，把它们变成command类的字段。 大多数command作为客户端之间的链接，它们触发请求和接收对象，接收对象通过执行一些操作来处理它们。 现在command只有一个无参方法，让各个command遵循通用接口很容易。通常，一个command接口只有一个类似execute()的方法。一旦通用接口创建，你可以用command替换掉客户端代码之前耦合的特定操作。 在编辑器例子中使用了Command模式之后，你讲不再需要Button子类。基础类将需要增加一个字段来保存command对象的引用。一个按钮对象将把用户发起的点击请求委托给关联的command对象，而不是自己去完成处理。command要么他自己执行一些操作要么把它委托给一个业务逻辑对象。 你可以对上下文按钮和热键代码做类似处理。这些类将把工作委托给在它们之间共享的单个command对象。 因此，command类将使得GUI和业务逻辑类的衔接变得很方便。这只是Command众多优点中的一部分。 真实世界的类比在餐厅下单你到一个餐厅中并找了个靠窗的位置坐下。服务员拿走了你写在纸上的订单，把它贴在厨房的墙上，它之前还有其他订单。 正如你猜的那样，这个纸条就是一个command。它排在队列中知道一个厨师准备去做。这个订单包含了做这道菜的所有信息。他允许厨师立马开始做菜而不是跑来跑去来搞清楚订单的细节。 结构 Invoker保存Command对象的引用，并且当一个操作需要被执行的时候使用它。Invoker通过通用接口和command协作，这个接口通常只有一个execute()方法。Invoker不负责创建command对象。他们通常通过构造函数从客户端获取预创建的command。 为具体的Command声明接口。接口最少需要一个方法来执行实际操作。 具体的Command实现实际操作。一些command是自足的，不可变的。它们通过构造方法一次性接收所有必要的数据。其他的需要一个Receiver，作为外部的上下文对象。 Receiver包含特定命令所必需的业务逻辑或数据。命令可以查询这些对象的其他信息或整个操作委托给他们。在某些情况下，为了简单起见，可以将接收者的代码合并到命令类中。 Client创建并配置具体的Command对象。然后把他们传给适当的Invoker。 伪代码在这个例子中，Command模式用来记录操作历史，还可以还原它。不想之前的例子，这个应用每次用户操作都创建一个新的command。之后在帮助列表中会展示这些个性的命令。 在执行操作前，command会创建编辑器当前状态的备份。执行后，command把自己放到历史栈中。 客户端的代码，比如UI元素，command历史和其他类将不会和具体的command类耦合，因为他们通过command接口来协作。这就允许在不改变已存在代码的情况下新增command。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// Abstract command defines the common interface for all concrete commands.abstract class Command is protected field app: Application protected field editor: Editor protected field backup: text constructor Command(app: Application, editor: Editor) is this.app = app this.editor = editor // Make a backup of the editor's state. method saveBackup() is backup = editor.text // Restore the editor's state. method undo() is editor.text = backup // The execution method is declared abstract in order to force all concrete // commands to provide their own implementations. The method must return // true or false depending on whether or not the command changes the // editor's state. abstract method execute()// Concrete commands.class CopyCommand extends EditorCommand is // The copy command is not saved to the history since it does not change // editor's state. method execute() is app.clipboard = editor.getSelection() return falseclass CutCommand extends EditorCommand is // The cut command does change the editor's state, therefore it must be // saved to the history. And it will be as long as the method returns true. method execute() is saveBackup() app.clipboard = editor.getSelection() editor.deleteSelection() return trueclass PasteCommand implements Command is method execute() is saveBackup() editor.replaceSelection(app.clipboard) return true// The undo operation is also a command.class UndoCommand implements Command is method execute() is app.undo() return false// The global command history is just a stack.class CommandHistory is private field history: array of Command // Last in... method push(c: Command) is Push command to the end of history array. // ...first out method pop():Command is Get the most recent command from history.// The editor class has an actual text editing operations. It plays the role of// a receiver: all commands end up delegating execution to the editor's methods.class Editor is field text: string method getSelection() is Return selected text. method deleteSelection() is Delete selected text. method replaceSelection(text) is Insert clipboard contents at current position.// The application class sets up object relations. It acts as a sender: when// something needs to be done, it creates a command object and executes it.class Application is field clipboard: string field editors: array of Editors field activeEditor: Editor field history: CommandHistory // The code which assigns commands to UI objects may look like this. method createUI() is // ... copy = function() &#123; executeCommand(new CopyCommand(this, activeEditor)) &#125; copyButton.setCommand(copy) shortcuts.onKeyPress("Ctrl+C", copy) cut = function() &#123; executeCommand(new CutCommand(this, activeEditor)) &#125; cutButton.setCommand(cut) shortcuts.onKeyPress("Ctrl+X", cut) paste = function() &#123; executeCommand(new PasteCommand(this, activeEditor)) &#125; pasteButton.setCommand(paste) shortcuts.onKeyPress("Ctrl+V", paste) undo = function() &#123; executeCommand(new UndoCommand(this, activeEditor)) &#125; undoButton.setCommand(undo) shortcuts.onKeyPress("Ctrl+Z", undo) // Execute a command and check whether it has to be added to the history. method executeCommand(command) is if (command.execute) history.push(command) // Take the last command from the history and run its undo method. Note that // we do not know the class of that command. But we don't have to, since the // command knows how to undo its own action. method undo() is command = history.pop() if (command != null) command.undo() 适用性 当你想要把行为参数化成对象。举个例子，你在开发一个用户接口组件，比如一个菜单，你想你的用户可以配置菜单元素被点击之后的行为。 Command模式将操作转换为可以从各种UI元素链接的对象。每个元素把工作委托给command对象而不是自己去做。command可以自己执行操作或者调用时昂的业务逻辑对象。 当你需要排队，规划，或者执行远程操作。 和其他任何对象以牙膏，command是可以序列化的，意味着它可以转换成一个字符串。这个字符串可以背保存到一个文件或者数据库并且稍后可以再把它转换成一个commadn对象。甚至，你可以通过网络发送一个序列化的command，然后在远程服务上恢复并执行它。 当你需要撤销操作。 想要支持撤销操作的第一件事就是保存历史。尽管有很多实现方式，Command模式或许是最流行的。 command历史栈由已执行的command对象组成。每个command在执行操作前线创建当前应用状态的快照。在操作完成后，command把自己压入历史栈中。注意，它始终保持应用程序状态的备份。当需要撤销时，程序从历史栈中拿到栈顶command并且恢复它存储的快照。 这个方法有两个缺点。首先，保存应用的状态不容易，因为一些是私有的。这个问题可以使用Memento模式缓解。 其次，状态的保存需要消耗大量RAM。因此，有时候你可以修改实现，不是恢复过去的状态，而是执行命令的逆操作。这个选择是昂贵的。反转操作通常很难以实现甚至不能实现。 如何实现 声明只有一个execute方法的Command接口。 在遵循通用Command接口情况下抽离操作到具体的Command实现中。把操作的参数转换成具体command类的字段。他们应当通过command的构造方法来初始化。 确保command中有字段来持有需要和它协作Receiver对象的引用。这个字段也应该通过构造方法来初始化。 识别Invoker类并为其提供用于存储command对象的字段。Invoker应当只通过Command的接口和command对象交互。他们通常不是自己创建command对象，而是从客户端获取。 应用的主要代码，看作Client，应该创建并配置具体的command并且传递给适当的Invoker对象。有时，多个Invoker可以使用相同的command对象。 优点 解耦操作调用和处理类。 允许撤销操作。 允许延迟操作。 允许简单命令组装成更大的命令。 符合开闭原则。 缺点 创建了多个额外类导致代码复杂度上升。 和其他模式的关系 Chain Of Responsibility，Command，Mediator和Observer处理连接请求的发送者和接收者的各种方式： 责任链沿着潜在接收者的动态链顺序传递一个请求，直到其中一个处理这个请求。 命令模式建立从发送者到接收者的单向连接。 调解模式持有发送者和接收者间接引用。 观察者会在同一时间把一个请求发送给所有关心的接受者，但是允许它们动态的确定是否继续订阅和取消订阅后面的请求。 责任链中的处理者可以表示为命令（Command）。在这种情况下，许多不同的操作可以在由请求表示的相同上下文中执行。 但还有另外一种方式，请求本身就是一个Command对象，沿着对象链传递。这种情况下，相同的操作可以在由链条对象表示的不同上下文中执行。 Command和Memento可以一起使用。他们可以充当魔法token，被延迟传递和调用。在Command中，token代表一个请求；在Memento中，它代表了某个特定时间的物体的内部状态。多态性对Command而言是重要的，但对于Memento来说却是非常重要的，因为它的接口太狭隘所以Memento只能作为一个值来传递。 Command和Strategy很像，因为他们都用于参数化一些行为的上下文。Command被用来转化任意操作到一个对象。操作的参数变成对象的字段。转换允许延迟或远程执行命令，存储命令历史等。 另一方面，Strategy模式通常来描述做相同事情的不同方式。它可以帮助在单个上下文类中交换这些算法。 在我们需要保存Command拷贝到历史中时Prototype可以提供帮助。 Visitor模式就像增强版的Command模式，可以对任何类型的对象执行操作。 小结Command是行为模式的一种，可以将请求或者简单的操作转换到对象中。这种转换允许延迟或者远程执行命令，存储命令历史等。 在Java中这种模式很常见。大多数情况下，它被用作参数化UI元素的动作回调。也被用来任务排队，追踪操作历史等。 Java核心库中的一些例子： java.lang.Runnable接口的所有实现 javax.swing.Action接口的所有实现 参考翻译整理自：https://refactoring.guru/design-patterns/command]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-行为模式之Chain-Of-Responsibility]]></title>
      <url>%2F2017%2F12%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%E4%B9%8Bchain-of-responsibility%2F</url>
      <content type="text"><![CDATA[意图责任链（Chain Of Responsibility）是一种行为模式，通过给多个对象一个机会去处理请求的的方式来避免请求发送者和接受者的耦合。责任链接收对象并且沿着链条传递它，直到一个对象来处理它。 问题假设你在做一个订单系统。你第一个任务就是限制用户对系统的访问，只有已经授权的用户可以创建订单。另外，一些用户拥有管理员权限，可以访问全部的订单。 你意识到这些检查必须顺序处理。程序能够在任何时候对用户进行尝试认证，只要用户的证书被请求传递。但是，如果未能对用户进行身份验证，则无法检查用户的权限。几个月后，你已经实现了这些顺序检查。 你的同时建议，将原始数据直接交给代码处理不安全。所以你添加了一个额外校验步骤来验证请求数据。 之后，其他人建议协同无法应对暴力的密码破解。为了解决这个问题，你添加了另一个检查来过滤重复使用相同用户名但是失败的请求。 你甚至添加了缓存来提升订单在高负载下的性能。 不幸的是，随着新特性的增加，代码变得越来越臃肿。甚至，你为了保护其他页面，把这些检查代码的一部分做了拷贝，导致出现重复代码片段。 这个系统变得难以维护。但是，一天你收到了重构系统的任务… 解决和其他行为模式很像，责任链依赖于将行为转化为独立的对象。在我们的例子中，每个检查都将被移动到不同的类中，这些类只有一个方法来执行这些检查。这个方法通过参数来接收请求数据。 现在，到了有趣的部分。模式建议连接这些对象到一个链条中。 每个处理者都有一个字段来存储这个链条中下一个处理者的引用。不管什么时候，一个处理者接收到一个请求，它可以把请求传递给链条中在其之后的处理者。这个请求沿着链条旅行知道所有的处理者都有机会来处理它。 最后，一个处理者不需要在继续传递这个请求。有两种流行的方式来处理这个想法。 在我们访问过滤的例子中，处理者排队并挨个处理他们的检查。流的终点只可能是某个检查失败或者到达链条尾部。 但还有一个略微不同的方式，处理者只会传递那些它们自己无法处理的请求。否则，它们执行自己的业务并且终止链条的执行。这个选项在处理GUI组件事件时很常见。 比如，当用户点击一个按钮，这个事件便沿着由按钮开始的组件链传播，传到他们的父组件，像form和panel，直到应用的窗口停止。这个事件被链条中第一个可以处理它的组件处理。这个例子值得一提，因为它告诉我们一个链条可以从一个树结构中抽离出来。 所有的处理者类都需要遵循一样的接口。这将让你可以在运行时使用各个处理者组合一个链条，而代码不会和处理者的具体实现类耦合。每个具体的处理者应该只关心自己的execute方法。 现实世界的类比技术支持你为你的PC买了一个新的显卡。Windows可以自动检测并启用他。但你钟爱的Linux却无法使用新硬件。抱着微小的希望，你打电话给技术支持。 首先，你听到了自动应答的机器人声音。它提出了九种解决各种问题的流行解决方案，但没有一个与你的问题有关。过了一会，机器把你转给在线客服。 客服也没有给出有用的解决方法，于是你请求联系一个正确的工程师。 客服把你转给了工程师。最后，这个工程师告诉你到哪下载显卡驱动及如何在Linux中怎么安装。于是，你愉快的结束了这通电话。 结构 Handler为所有具体的处理者声明一个通用接口。通常，它只有一个处理请求的方法，但有时候也会有设置链条下一个处理者的方法。 Base Handler是可选的类，它可以包含负责构建维护对象责任链的模版代码。 这个类可以包含一个字段来存储链条中下一个处理者。使用这个字段，客户端可以将多个处理者链接到一个链中。这个字段可以通过构造方法或者一个set方法来控制。这个类也可能有一个基本处理方法的实现，这个方法检查下一个处理者是否存在然后把执行传递给它。 Concrete Handlers包含处理请求的实际代码。接收到请求后，处理者必须决定是否处理该请求，另外还要决定是否在链条中继续传递它。 处理者通常是独立的和不可变的，通过构造函数参数一次性接收所有必要的数据。 Client可以只组装一次链条或者依赖于程序逻辑动态组装。注意，一个请求可以被发送到链中的任何处理者，它并不总必须是第一个。 伪代码在这个例子中，责任链负责显示活动UI元素关联的一个上下文帮助。 这些GUI元素是树状结构。Dialog类渲染树根的主窗口。中间层由Panel组成。叶子结点有：Component、Button、TextEdit等。 一个Component能够显示上下文提示，只要它有帮助文本。一些复杂的组件有他们自己的方式来显示上下文帮助。 当用户将鼠标光标指向组件并按下F1时，应用抓取这个组件并发送帮助请求。这个请求向上传递给所有父容器知道这个组件可以显示帮助。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Handler interface.interface ComponentWithContextualHelp is method showHelp() is// Base class for simple components.abstract class Component implements ContextualHelp is field tooltipText: string // Container, which contains component, severs as a following object // in chain. protected field container: Container // Component shows tooltip if there is a help text assigned to it. Otherwise // it forwards the call to the container if it exists. method showHelp() is if (tooltipText != null) Show tooltip. else container.showHelp()// Containers can contain both simple components and other container as// children. The chain relations are established here. The class inherits// showHelp behavior from its parent.abstract class Container extends Component is protected field children: array of Component method add(child) is children.add(child) child.container = this// Primitive components may be fine with default help implementation...class Button extends Component is // ...// But complex components may override the default implementation. If a help can// not be provided in a new way, the component can always call the base// implementation (see Component class).class Panel extends Container is field modalHelpText: string method showHelp() is if (modalHelpText != null) Show modal window with a help text. else parent::showHelp()// ...same as above...class Dialog extends Container is field wikiPage: string method showHelp() is if (wikiPage != null) Open a wiki help page. else parent::showHelp()// Client code.class Application is // Each application configures the chain differently. method createUI() is dialog = new Dialog("Budget Reports") dialog.wikiPage = "http://..." panel = new Panel(0, 0, 400, 800) panel.modalHelpText = "This panel does..." ok = new Button(250, 760, 50, 20, "OK") ok.tooltipText = "This is a OK button that..." cancel = new Button(320, 760, 50, 20, "Cancel") // ... panel.add(ok) panel.add(cancel) dialog.add(panel) // Imagine what happens here. method onF1KeyPress() is component = this.getComponentAtMouseCoords() component.showHelp() 适用性 当一个程序有几个处理不同请求的处理者，但事先并不知道过来的是什么类型的请求。 你要把几个处理者放到一个链条中。请求沿着链条传递直到有个处理者能够处理它。 当要以特定顺序执行处理程序。 责任链允许按照给定的顺序依次执行处理者。 当有很多对象来处理请求，并且它们的顺序动态改变。 责任链允许对一个存在的链条中的处理者进行新增、移除或者排序操作。 如何实现 声明Handler接口，包含一个处理请求的方法。决定如何传递请求的信息到方法中。最灵活的方法是将请求数据转换为对象并传递给处理方法。 为了减少重复的样板代码，从Handler接口派生出一个抽象BaseHandler类是很值得的。 添加一个字段来保存下一个处理者的引用。这个字段可以从构造参数中获得初始化数据。你也可以定义一个set方法来修改这个字段。但仅当你想要在运行时想要修改链条才需要这么做。 实现处理方法，以便将请求转发给链中的下一个对象（如果有的话）。具体的处理者能够通过调用父类方法来转发请求。因此，它们不需要访问引用字段，你就可以把它声明为private了。 创建ConcreteHandler子类并且实现它们的处理方法。每个处理者在收到请求时应做出两个决定： 是否要处理这个请求。 是否要继续传递这个请求。 Client可以自己组装链条也可以从其他对象接收已经构造好的链条。在后一种情况下，可以采用工厂对象通过应用配置护着环境变量来构建链条。 Client可能触发链条中任意一个处理者，不仅仅只是第一个。这个调用将会沿着链条传递直到链条结尾或者一些处理者拒绝进一步传递它。 由于链条的动态特性，Client应该准备好处理以下情况： 有时一个链可能包含一个单一的链接。 一些请求可能无法到达链条的尾部。 一些请求到达链条尾部还未被处理。 优点 减少请求发送者和接受者的耦合。 遵循单一职责原则。 遵循开闭原则。 缺点 一些请求肯能到链条尾部仍未被处理。 和其他模式的关系 Chain Of Responsibility，Command，Mediator和Observer处理连接请求的发送者和接收者的各种方式： 责任链沿着潜在接收者的动态链顺序传递一个请求，直到其中一个处理这个请求。 命令模式建立从发送者到接收者的单向连接。 调解模式持有发送者和接收者间接引用。 观察者会在同一时间把一个请求发送给所有关心的接受者，但是允许它们动态的确定是否继续订阅和取消订阅后面的请求。 责任链通常和组合（Composite）结合使用。在这种情况下，一个组件的父类可以看作是他的后继者。 责任链中的处理者可以表示为命令（Command）。在这种情况下，许多不同的操作可以在由请求表示的相同上下文中执行。 但还有另外一种方式，请求本身就是一个Command对象，沿着对象链传递。这种情况下，相同的操作可以在由链条对象表示的不同上下文中执行。 责任链和装饰者（Decorator）的类结构很相似。它们都依赖于递归组合来在一系列对象中传递执行。但是它们也有几个关键区别。 责任链的处理者能够随意执行动作，之间相互独立。它们也能够随意终止请求的进一步传递。另一方面，各个装饰者扩展一个特定行为并应该保持其接口一致。另外，装饰者不允许随意中断链条的执行。 小结责任链允许请求烟盒潜在的处理链传递直到某个处理者处理这个请求。这种模式允许多个对象处理这个请求而不发送者类不需要和具体接受者类耦合。这个链可以在运行时动态组合遵循标准处理者接口的任何处理者。 在Java中比较流行的使用样例：在GUI类中向父组件传递事件；过滤访问请求。 在Java的核心类库中有些例子： javax.servlet.Filter#doFilter() java.util.logging.Logger#log() 当我们发现组织结构类似以下描述时，可能就采用了责任链模式：一个对象的行为方法间接调用其他对象中的相同方法，而所有对象都遵循共同的接口。 参考翻译整理自：https://refactoring.guru/design-patterns/chain-of-responsibility]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Singleton]]></title>
      <url>%2F2017%2F11%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BSingleton%2F</url>
      <content type="text"><![CDATA[意图Singleton是创建模式的一种，让你可以确保一个类只有一个实例，并为此实例提供一个全局访问点。 问题Singleton同时解决了两个问题（违反了单一职责原则）： 确保一个类只有一个实例。最常见原因是控制一些共享资源，比如，数据库。 假设你已经创建了一个新对象，不久，又尝试创建一个新的。在这种秦光下，你想要老的那个对象而不是新创建一个实例。 它不能通过正常的构造方法完成，因为在设计上每个构造方法总是返回一个新对象。 为实例提供一个全局的访问点。听起来像一个全局变量，不是吗？但是你无法做一个只读的全局变量。任何可以访问这个变量的人都可以替换他的值。 还有另外一个问题：你不希望解决以前的问题的代码分散在你的程序中。它们最好放在一个类中，特别当你的代码已经依赖那个类时。 注意，Sigleton同时解决了上面两个问题。但是现在模式很流行，即使他只解决了其中一个问题人们也会把它称为Sigleton。 解决单例所有实现的都有以下两个步骤： 创建私有的构造方法。 创建静态的创建方法扮演构造方法的角色。这个方法使用私有的构造方法创建一个对象并把它保存在静态变量或者字段中。对这个方法的所有调用都将返回缓存的对象。 Singleton保持把单实例的生产代码放在一个地方–Singlton类的创建方法中。任何可以访问Singleton类的客户端也都可以访问他的创建方法。因此，他提供给我们Singleton实例的一个全局访问点。 真实世界的类比政府政府是Singleton模式的一个很好的例子。一个国家只能有一个官方政府。不管组件政府的个人身份如何，“X的政府”这个称号是全球的一个访问点，他可以识别这个组织的负责人。 结构 Singleton声明静态的方法getInstance()，这个方法返回相同的Singleton类实例。 Singleton的构造方法对客户端代码应当不可见。getInstance()应该是唯一的可以创建并获得Singleton对象的途径。 伪代码在这个例子中，数据库连接类扮演Singleton角色。这个类没有公开的构造方法，所以只有调用getInstance方法可以获取这个对象。这个方法混存第一次创建的对象，在随后所有的调用中都返回它。 单例模式保证他的类只有一个实例被创建。并且，他提供了实例全局访问点：这个静态方法getInstance。 123456789101112131415161718192021222324252627282930class Database is private field instance: Database static method getInstance() is if (this.instance == null) then acquireThreadLock() and then // Ensure that instance has not yet been initialized by other // thread while this one has been waiting for the lock release. if (this.instance == null) then this.instance = new Database() return this.instance private constructor Database() is // Some initialization code, such as the actual connection to a // database server. // ... public method query(sql) is // All database queries of an app will go through this methods. // Therefore, you can place a throttling or caching logic here. // ...class Application is method main() is Database foo = Database.getInstance() foo.query("SELECT ...") // ... Database bar = Database.getInstance() bar.query("SELECT ...") // The variable `bar` will contain the same object as the variable `foo`. 适用性 当程序需要提供给所有客户端一个类的一个可以实例。比如，一个单独的数据库对象，在程序的不同模块贡献。 除了特别的的创建方法，Singleton对客户端隐藏了所有创建类的新对象的方法。这个方法创建一个新对象或者返回之前已经创建过的已经存在的对象。 当你需要严格控制全局变量。 不想全局变量，Singleton保证只有一个类实例。除了Singleton本身，没有任何类可以替换缓存的实例。 Sigleton让你可以轻松改变这个限制。比如，允许任何数量的实例，你只需要在一个地方修改代码–getInstance()方法体内。 如何实现 在类中添加一个静态字段用来持有单实例。 声明静态的公开创建方法，它将用来检索单实例。 在创建方法中实现“懒初始化”。它应该在第一次调用时创建一个新实例，并把它放到静态变量中。在随后的调用中这个方法都返回这个实例。 把类的构造方法声明为私有。 把客户端代码中所有直接对构造方法的调用替换为对创建方法的调用。 优点 保证类只有一个实例。 提供实例的全局访问点。 允许懒实例。 缺点 违背单一职责原则。 面具坏设计（Masks bad design？）。 在多线程的环境下需要特别处理。 在单元测试中要无尽mock。 和其他模式的关系 Facade可以改造成Singleton，因为大多情况下，一个门面对象就足够了。 在一些情况下Flyweight和Sigleton很像，Flyweight把什么事情都减少到一个享元对象。但是记住，它们之间有两个基本的不同： 1.Singleton对象时易变的。Flyweight对象时不变的。 单例类只有一个类实例，而享元类有多个不同状态的实例。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 小结Singleton在优缺点方面几乎和全局变量一样。尽管它们很好用，但却破坏了你代码的模块化。 在其他的上下文中，你可以使用一个依赖于Singleton的类。你将不得不携带Singleton类。大多数时候，在创建单元测试时会出现这个限制。 尽管许多开发着认为Singleton是反模式，但是在Java的核心类中也有许多例子： java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() Singleton可以通过一个返回相同缓存对象的静态创建方法来识别。 参考翻译整理自：https://refactoring.guru/design-patterns/singleton]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Prototype(Clone)]]></title>
      <url>%2F2017%2F11%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BPrototype%2F</url>
      <content type="text"><![CDATA[目的Prototype（也叫做Clone）是创建型模式的一种，允许你通过复制现有的对象来生成新的对象，而不会影响现有对象的内部。 问题你有一个对象并且想要创建一个副本。你该怎么做？首先，你需要创建同样class的一个新对象。然后，你必须遍历源对象的所有字段并把值拷贝到新对象中。 但是这么做有一个问题。不是所有对象都可以通过这种方式被拷贝。一些对象拥有无法从外部访问的私有字段。 这么做还有另外的问题。因为你必须知道对象类能够被遍历的所有字段，你的代码需要依赖你要拷贝对象的类。在你仅知道拷贝对象的接口时无法拷贝对象。 解决Prototype模式把克隆操作委托给对象自己。 他为所有需要克隆的对象声明通用的接口。他允许在不紧密耦合具体类的情况下克隆对象。通常，prototype接口只包含一个clone方法。 所有类对clone方法的实现都很像。这个方法创建一个当前类的对象，然后把他的字段值拷贝到新对象中。大多数编程语言都允许访问同一个类对象中的私有字段，所以这种拷贝过程比较直接。 可以被克隆的对象叫做prototype（原型）。有时，特别是当你的对象有很多字段并且一些字段可配置，原型可以作为子类的一种替代。在这种情况下，程序提前创建一些原型，然后克隆它们而不是从头开始重建对象。 真实世界的类比工业和细胞分裂在真实生活中，原型在产品量产之前用来做各种测试。然而，在这种情况下，原型并没有参与真正的生产，是一个被动的角色。 因为工业原型自己不会拷贝，对这个模式更相近的类比是有丝细胞分裂（生物学，还记得吗？）。在这种分裂后，两个完全一样的细胞就形成了。源细胞就是原型，在创建拷贝中是一个主动的角色。 结构基本实现 原型注册实现 Prototype声明克隆接口。大多情况下，只要一个clone方法就够了。 Concrete（具体的）Prototype来实现克隆方法。除了直接告杯字段值到新对象外，这个方法也可以解决一些应当对客户端隐藏的警告。比如，克隆引用对象，解开递归依赖等。 客户端使用Prototype接口来检索一个对象的克隆。 Prototype registry提供了对常用原型的简单访问，存储预先创建的一组对象，随时可以复制。通常，它可以用简单的（name-&gt;prototype）哈希映射实现。但是为了方便，任何其他搜索条件都可以添加到注册表中。 伪代码在这个例子中，原型被用来克隆代表几何形状的对象，而不耦合到它们的类。 所有的形状类都实现了只有克隆方法的通用克隆接口。子类先调用父类的克隆方法，然后把他们自己的字段拷贝到结果对象中。 因此，原型模式允许客户端代码克隆对象，即使不知道和独立于其特定的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Base prototype.abstract class Shape is field X: int field Y: int field color: string // A fresh object is initialized with values from the old object in // the constructor. method Shape(source: Shape) is if (source != null) then this.X = source.X this.Y = source.Y this.color = source.color // Clone operation always returns one of the Shape subclasses. abstract method clone(): Shape// Concrete prototype. Cloning method creates a new object and passes itself to// the constructor. Until constructor is finished, has a reference to a fresh// clone. Therefore, nobody has access to a partly built clone. This helps to// make the cloning result consistent.class Rectangle extends Shape is field width: int field height: int method Rectangle(source: Rectangle) is // Parent constructor call is mandatory in order to copy private fields // defined in parent class. super(source) if (source != null) then this.width = source.width this.height = source.height method clone(): Shape is return new Rectangle(this)class Circle extends Shape is field radius: int method Circle(source: Circle) is super(source) if (source != null) then this.radius = source.radius method clone(): Shape is return new Circle(this)// Somewhere in client code.class Application is field shapes: array of Shape method constructor() is Circle circle = new Circle() circle.X = 10 circle.Y = 20 circle.radius = 15 shapes.add(circle) Circle anotherCircle = circle.clone() shapes.add(anotherCircle) // anotherCircle is the exact copy of circle. Rectangle rectangle = new Rectangle() rectangle.width = 10 rectangle.height = 20 shapes.add(rectangle) method businessLogic() is // Prototype rocks because it allows producing a copy of an object // without knowing anything about its type. Array shapesCopy = new Array of Shapes. // For instance, we do not know exact types of elements in shapes array. // All we know is that all of them are Shapes. But thanks to the // polymorphism, when we call the `clone` method on a shape, the program // checks its real class and runs the appropriate clone method, defined // in that class. That is why we get proper clones instead of a set of // simple Shape objects. foreach shapes as shape do shapesCopy.add(shape.clone()) // The variable `shapesCopy` will contain exact copies of the `shape` // array's children. 适用性 当你的代码不应该依赖你要拷贝对象的具体类时。比如，对象的类是未知的，因为你通过接口和他们协作。 原型模式提供给客户端一个和所有原型协作的接口。这个接口对所有支持克隆的对象是通用的。这使得客户端对要克隆产品的具体类保持独立。 当你想要减少由不同方式配置相似对象（换句话说，每个类由唯一的字段值）组成的类层级结构的大小时。 原型模式允许创建一个原型对象集合，这些对象代表了一个对象所有可能的配置。 然后，客户端代码不是初始一个匹配一些配置的子类，而是寻找适当的原型并且克隆他。 如何实现 创建原型接口并在接口中声明clone方法。你可以简单的把这个方法添加到现有类层级中的所有类，如果你有类的话。 为所有原型类添加一个可选的构造方法，这个构造方法接收当前类的一个对象。这个构造函数必须从传递的对象中将类中定义的所有字段的值拷贝到当前实例。然后，它应该调用父类构造方法去拷贝父类中的字段。 如果你的编程语言不支持方法重载，你需要定义一个特别的方法来拷贝数据。构造方法仅仅是最便利的一个，因为他在new操作后就开始拷贝。 clone方法通常是有一行：运行一个使用原型构造方法的new操作符。注意，每个支持克隆的类必须明确重写clone方法，克隆方法要new一个他自己的类。否则，克隆将会生产出一个父类的对象。 此步骤可选。创建一个原型注册中心来存储常用的原型。甚至是相同类的对象，只是配置方式不同。 你可以在原型的基类中用工厂类或者工厂方法实现注册中心。这个工厂方法可以根据客户端代码传递的参数查找适当的原型。搜索条件可以仅仅是一个字符串标签或者复杂的搜索条件。在找到原型后，它应该克隆它并且把拷贝返回给客户端。 最后，我们应该把直接调用对象构造方法的clone方法改成调用原型注册中心的工厂方法。 优点 允许克隆对象而不耦合到具体的类。 减少重复的实例代码。 更快的创建复杂对象。 当你需要处理有许多可选配置的复杂对象时，可以把它当作替代子类的方案。 缺点 引用了许多其他对象的复杂对象很难被克隆。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Abstract Factory类通常使用工厂方法实现，但也可以使用Prototype实现。 当您需要将Command的副本保存到历史记录中时，Prototype可以提供帮助。 大量使用Composite和Decorator模式的设计通常也可以从Prototype中受益。他允许克隆复杂结构，而不是从头构建他们。 Prototype不需要子类，但是需要初始操作。Factory Method需要子类，但是不需要初始化这个步骤。 Prototype是更简单的Memento替代，如果您想要把对象的某种状态保存在历史中，相当简单，没有外部资源的链接，或者链接很容易重新建立（Memento还不了解，此处很模糊）。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 总结Prototype是创建型模式的一种，允许你克隆对象，即使被克隆对象很复杂，它不需要耦合特定的被拷贝对象的类。 用例： java.lang.Object#clone() (class 应当实现java.lang.Cloneable 接口) 鉴定：通过clone()或者copy()等方法轻松识别原型模式。 参考整理翻译自：https://refactoring.guru/design-patterns/prototype]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Builder]]></title>
      <url>%2F2017%2F11%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%2F</url>
      <content type="text"><![CDATA[意图Builder是创建模式的一种，让你可以使用相同的构建过程生成不同类型和对象的表示形式。BUilder允许一步一步构建复杂对象。 问题假设有一个复杂对象需要一步一步的初始化许多字段和嵌套对象。这些代码通常放在一个有很多参数的构造方法中，或者更糟糕，分散在客户端代码中。 比如，让我们考虑下如何创建一个House对象。创建一个简单的房子，你需要盖四面墙，安装一个门和两个窗户，构建房顶。但是，如果你想要一个更大，更亮堂，并且有后院和其他好吃的东西的房子呢？想到的最简单的解决方式是从Hose类扩展，通过创建子类来覆盖所有参数的组合。这种处理方式明显会导致创建许多子类。任何新的参数，比如阳台风格，都需要扩张这个层级甚至扩张很多。 这些参数大多时候是无用的，导致构造方法看起来很丑陋。比如，很多房子没有游泳池。因此，和游泳池相关的所有参数99%情况下都是无用的。 解决Builder模式建议抽离出类自身的构造代码到不同的对象中，这种对象叫做builder。 模式把对象的构造组织称一系列步骤（比如：buildWalls，BuildDoor等）。创建这个对象，你需要调用一个构造类中的几个构造步骤。最重要的一点是你不需要调用所有的步骤。你只能使用生成对象的特定配置所需的步骤。 通常，对于你正在尝试构建的各种产品，相同的构建步骤将会有所不同（一样步骤，但是每个步骤完成的方式不同）。比如，一个机舱可以用木日志建造，但是一座城堡必须用石头。 在这种情况下，你可以在不同的方式下，创建几个不同的实现了相同构建步骤的builder类。然后，你就可以使用这些builder在相同的构建处理中生产不同类型的对象。 比如，有一个StoneBuilder类来处理所有和石头相关的事情，一个WoodBuilder类来处理木头的。你可以使用它们中的一个通过一系列构造步骤来生产一个石头或者木头房子。这种方式仅在客户端代码通过通用接口来和builder交互时可用。 你可以进一步抽离出整个构建过程到一个特别的类：Director。在这种情况下，Director（Director关联了一个Builder对象）可以定义构建步骤的顺序并执行他们。这种结构下将会向客户端隐藏所有构建细节。 结构 Builder声明构建一个产品需要的步骤。 Concrete Builder提供构造步骤的不同实现。Builder也可以提供获取构造结果的方法。这个方法不需要声明在builder接口中，因为builder可能生产没有遵循通用接口的产品。但是如果你处理的产品是单一层次的，你可以安全的把这个方法描述在基本接口中。 Product是创建结果的一个对象。Builder可以生产不属于同一个类层级或者接口的产品。这是Builder和其他创建模式的不同之处。 Director使用Builder对象构建产品。通常，客户端通过构造方法参数传给director一个builder实例。Director使用这个单一的builder对象完成所有的进一步构建。但是也有替代的方式，把builder传递给director的主要生产方法。 注意，Builder不需要创建一了director类。当你有几个需要不同构建流程的产品变种时，用不同的director类是很方便的。Director把代码都封装在一个单独的类中。 伪代码这个例子展示了Builder是如何一步一步的构造出汽车。Director类使用不同的构建步骤生产不同类型的汽车。Director使用给他们的build对象工作。这种方式允许你重用已经存在的代码来生产不同种类汽车的用户手册。为了达到这个目的，你只需要一个新的builder类。 因此，Builder模式允许你只通过简单的改变构造步骤的数量和顺序就可以创建产品的不同变种。另外，通过提交构建器对象的替代版本，您可以使用相同的构造代码生成完全不同类型的产品。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// Builder can create different products using the same building process.class Car is Can have GPS, trip computer and various numbers of seats. Can be a city car, a sports car, or a cabriolet.class Manual is Textual representation of a car.// Builder interface defines all possible ways to configure a product.interface Builder is method reset() method setSeats(number) method setEngine(engine: Engine) method setTripComputer() method setGPS()// Concrete builders implement that interface differently.class CarBuilder implements Builder is private field car:Car method reset() Put a new Car instance into the "car" field. method setSeats(number) is Set the number of seats in car. method setEngine(engine: Engine) is Install a given engine. method setTripComputer() is Install a trip computer. method setGPS() is Install a global positioning system. method getResult(): Car is Return the current car object.// Unlike other creational patterns, Builder can construct unrelated products,// which don't have the common interface.class CarManualBuilder implements Builder is private field manual:Manual method reset() Put a new Manual instance into the "manual" field. method setSeats(number) is Document car seats features. method setEngine(engine: Engine) is Add an engine instruction. method setTripComputer() is Add a trip computer instruction. method setGPS() is Add GPS instruction. method getResult(): Manual is Return the current manual object.// Director defines the order of building steps. It works with a builder object// through common Builder interface. Therefore it may not know what product is// being built.class Director is method constructSportsCar(builder: Builder) is builder.reset(); builder.setSeats(2); builder.setEngine(new SportEngine()); builder.setTripComputer(); builder.setGPS();// Director gets the concrete builder object from the client (application code).// That's because application knows better which builder to use to get a// specific product.class Application is method makeCar is director = new Director(); CarBuilder builder = new CarBuilder(); director.constructSportsCar(builder); Car car = builder.getResult(); CarManualBuilder builder = new CarManualBuilder(); director.constructSportsCar(builder); // The final product is often retrieved from a builder object, since // Director is not aware and not dependent on concrete builders // and products. Manual manual = builder.getResult(); 适用性 当你有一个“伸缩”的构造方法。 调用一个有许多可选参数的构造方法很不方便。你必须指定所有的参数，即使你不需要。 解决这个痛点，可以重载一个长的构造方法，创建几个参数较少的构造方法。它们仍然调用主构造方法，只是把省略的参数传入了默认值。 Builder模式允许一步一步构建对象。在构建一个简单对象时，你可以只使用必要的步骤，跳过可选步骤。 当你的代码必须要创建一个产品的不同表示时（比如，石头和木头房子）。产品的构造步骤一样，但细节不同。另外，尽管这个产品是相似的，它们没有必要必须遵循一个通用基类或者接口。 Builder可以用相同的过程构建不同的产品。 不同的产品被不同的builder类表示。控制构建顺序的代码应该放在一个单独的director类中。 当你必须构建一个Composite树或者其他复杂对象时。 Builder一步一步的构建产品。他循序延时甚至递归构建，这在使用树结构时很有用。Builder在运行构建步骤时不能导出位完成的产品。这样可以阻止客户端代码拿到损坏的结果。 如何实现 确保你有构建产品的共同步骤和导致创建各种产品代表的步骤的变化（？）。 创建Builder接口并声明生产步骤。 为每一个产品表示创建Concrete Builder类。并实现它们的创建步骤。 考虑创建一个Director类。他的方法用相同的builder实例，不同的步骤来创建不同的产品配置。 客户端代码创建Builder和Director对象。它首先床架你个builder实例，然后把它传给director的构造方法或者他的生产方法。 客户端应该调用Director对象的生产方法开始构建过程。 是有在所有产品遵循一个通用接口时可以从Director对象中获取构建结果。相反，每个Builder必须有他自己检索结果的方法。 优点 允许一步一步构建产品。 允许使用相同的代码构建不同产品。 把产品的核心业务逻辑与复杂的构建代码隔离。 缺点 创建多个额外类增加了代码的复杂度。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Builder关注点在一步一步的构造出一个复杂对象。Abstract Factory创建产品对象的系列（不管是简单的还是复杂的）。Builder在最后一步返回产品，但是Abstrct Factory立刻返回结果。 Builder可以一步一步的构建一个复杂的Composite树。 Builder可已才有Bridge结构模式：Director当作接口，Builder当作实现。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 总结Builder是创建型模式的一种，允许你一步一步构造出来复杂的对象。 不想其他的创建型模式，Builder不需要产品遵循一个通用的接口。他可以使用相同的构造过程生成不同的产品。 用例：Builder模式在你需要创建一个有很多可选配置的对象相当有用。 Builder在Java核心库中也有广泛应用： java.lang.StringBuilder#append() (unsynchronized) java.lang.StringBuffer#append() (synchronized) java.nio.ByteBuffer#put() (also in CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer and DoubleBuffer) 所有java.lang.Appendable接口的实现 鉴定：Builder模式可以在类中识别，它有一个创建方法和几个方法来配置结果对象。Builder方法通常是支持链式调用（比如，someBuilder-&gt;setValueA(1)-&gt;setValueB(2)-&gt;create()）。 参考翻译整理自：https://refactoring.guru/design-patterns/builder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Abstract Factory]]></title>
      <url>%2F2017%2F11%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BAbstractFactory%2F</url>
      <content type="text"><![CDATA[目的Abstract Factory是创建模式的一种，让你在没有指定具体类的情况下生产相关对象的系列。 问题假设你在写一个家具店的模拟器。你的代码由以下构成： 相关产品的系列，像：Chair + Sofa + CoffeeTable。 系列的几个变种。比如，产品Chair + Sofa + Coffee + CoffeeTable可以有这些变种：IKEA，VictorianStyle,ArtDeco。 你需要有种方式创建个性化的家具对象，以便它们能够匹配相同系列中的其他对象。在没有匹配到家具时，客户会感到失望。 另外，你不想在添加新产品或者产品系列时改变已经存在的代码。家具供应商常常会更新他们的目录，并且你不想每次在供货商改目录时修改你的核心代码。 解决第一，Abstract Factory模式建议遍历所有不同的产品并且强制这些变种遵循通用的接口。比如，所有的椅子变种必须遵循Chair接口；所有的咖啡桌必须遵循CoffeeTable接口。 第二步，创建AbstractFactory，一个基础接口，声明了创建产品系列的所有产品的方法（比如：createChair，createSofa和createCoffeeTable）。这步最重要的一件事就是让这些方法返回代表抽象产品类型的接口：Chair，Sofa，CoffeeTable。 第三步，实现具体的工厂。工厂是返回某种特定产品的类。比如，IKEAFactory，将只会返回IKEAChair，IKEASofa和IKEACoffeeTable对象。所有的工厂在创建同一个变种的产品时必须遵循AbstractFactory接口。 客户端代码只能通过抽象接口同工厂和产品协作。这样你就可以通过传递不同的工厂对象修改要用的产品类型。 所以，当客户端像工厂请求创建一把椅子时，它不必关心工厂的具体类。也不必关心它将得到椅子的具体类。不管它将得到一把时尚的IKEA模型还是一把Victorian风格的椅子，它都用使用抽象的Chair接口和椅子协作。客户端代码只需要知道椅子实现了在接口中声明的sit方法。它还知道不管返回哪种椅子，它的类型是和沙发还有咖啡桌匹配的，因为它们是同一个工厂创建的。 好了，但是谁创建实际的工厂对象呢？通常，程序在初始化阶段创建一个具体的工厂，并且工厂的类型依赖配置或者环境。 结构 Abstract products为创建产品系列的所有不同产品声明接口。通常，有几个不同的产品接口。 Concrete products实现不同Abstract product接口。实现相同接口的具体产品集合代表一个系列的不同变种。 Abstract factory声明了创建系列中所有产品的接口。 Concrete factory实现了abstract factory的创建方法。每个具体工厂代表一个系列产品的特定变种。 虽然具体的工厂实例化具体的产品，但是创建方法的签名必须声明为相应抽象产品类型。通过这种歌方式，客户端代码在使用工厂时就不会和具体的产品变种耦合。它就能通过使用抽象接口和任何工厂/产品协作。 伪代码这个例子用来说明Abstract Factory模式可一用来创建跨平台的UI而不需要客户端代码和具体UI类耦合。 客户端代码从工厂中请求各个UI元素。返回元素的具体类型取决于客户端代码传递的工厂类型。客户端代码通过抽象接口和元素协作。只要它使用相同的工厂对象，它所有的产品都是兼容的。 Abstract Factory模式使得客户端代码和具体UI元素类独立。另外，当添加一个新的UI变种时，你不需要修改已经存在的代码（比如，实现Linux的UI元素）。你只需要创建一个工厂的新子类，让他返回新类型的UI元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// This pattern assumes that you have several families of products, structured// into separate class hierarchies (Button/Checkbox). All products of the same// family have the common interface.interface Button is method paint()// All products families have the same varieties (macOS/Windows).class WinButton implementing Button is method paint() is Render a button in a Windows styleclass MacButton implementing Button is method paint() is Render a button in a Mac OS X styleinterface Checkbox is method paint()class WinCheckbox implementing Checkbox is method paint() is Render a checkbox in a Windows styleclass MacCheckbox implementing Checkbox is method paint() is Render a checkbox in a Mac OS X style// Abstract factory knows about all (abstract) product types.interface GUIFactory is method createButton():Button method createCheckbox():Checkbox// Each concrete factory extends basic factory and responsible for creating// products of a single variety.class WinFactory implementing GUIFactory is method createButton():Button is return new WinButton method createCheckbox():Checkbox is return new WinCheckbox// Although concrete factories create the concrete products, they still return// them with the abstract type. This fact makes factories interchangeable.class MacFactory implementing GUIFactory is method createButton():Button is return new MacButton method createCheckbox():Checkbox is return new MacCheckbox// Factory users don't care which concrete factory they use since they work with// factories and products through abstract interfaces.class Application is private field button: Button; constructor Application(factory: GUIFactory) is this.factory = factory method createUI(); this.button = factory.createButton() method paint(); button.paint()// Application picks the factory type and creates it in run time (usually at// initialization stage), depending on the configuration or// environment variables.class ApplicationConfigurator is method main() is Read the configuration file If the OS specified in the configuration file is Windows, then Construct a WinFactory Construct an Application with WinFactory else Construct an MacFactory Construct an Application with MacFactory 适用性 当业务逻辑必须要和同一个产品系列的不同变种协作，并且你不想依赖具体产品类时（或者它们无法预先知道）。 Abstract Factory对客户端代码隐藏了创建产品类的信息。客户端代码可以和任何工厂创建出来的任何产品协作，只要客户端通过抽象接口和它们交互。 当一个类拥有多个Factory Method使得它的主要责任不明确时。 每个类专注做一件事是很好的程序设计。当一个类需要处理多个产品类型，它就应该使用一个独立的抽象工厂来替代多个工厂方法。 如何实现 画出不同产品和相同产品不同变种的矩阵。 为所有不同产品类型创建抽象接口并且让所有具体产品遵循这些接口。 声明抽象工厂接口。这个接口应该列出所有不同类型产品的创建方法。 为产品系列的每个变种实现不同的工厂类。 创建一个空场的初始化代码写在客户端中。客户端依赖配置或者当前环境中来决定需要的工厂的类型并创建出来。 在客户端代码中，把所有调用产品构造方法的地方替换成调用工厂的创建方法。 优点 符合开闭原则。 允许构建系列产品对象并担保兼容性。 避免具体产品和使用它们的代码的耦合。 在多个类间隔离责任。 缺点 创建多个额外类，增加代码整体复杂度。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Builder关注点在一步一步的构造出一个复杂对象。Abstract Factory创建产品对象的系列（不管是简单的还是复杂的）。Builder在最后一步返回产品，但是Abstrct Factory立刻返回结果。 Abstract Factory类通常用Factory Method来实现，单丝它们也可以用Prototype来实现。 Abstract Factory可以用来代替Facade隐藏特定平台的类。 Abstract Factory可以和Bridge模式单独使用。当Bridge的“接口”部分只能与特定的“实现”一起工作时非常有用。这种情况下，工厂能够封装这些关系并且对客户端隐藏复杂性。 Abstract Factory，Builder和Prototype都可以实现为Singleton。 小结Abstract Factory是创建型模式的一种，用来解决创建没有制定具体类的产品系列。 Abstract Factory定义了一个创建所有不同产品的接口，但是把创建真正产品的实现放在具体工厂类中。美国工厂类型都代表一个某些产品的变种。 客户端代码不是直接调用构造方法（new操作）而是调用一个工厂对象的创建方法来创建对象。因为一个工厂代表了一个产品的变种，它的产品都是兼容的。 客户端只通过抽象接口和工厂还有产品协作。它允许相同的客户端代码和不同的产品协作。你只需要创建一新的具体工厂类，并把它传递给客户端代码就行。如果你分不清楚Factories，Factory Method和Abstract Factory，可以阅读工厂比较指南（待译）。 Java的模式的使用用例：许多框架和类库采用抽象工厂模式来提供扩展和定制它们的标准组件。 Java的核心包中应用如下： javax.xml.parsers.DocumentBuilderFactory#newInstance() javax.xml.transform.TransformerFactory#newInstance() javax.xml.xpath.XPathFactory#newInstance() 鉴定：该模式很容易通过返回工厂对象的方法来识别。然后，工厂用于创建特定的子组件。 参考翻译整理自：https://refactoring.guru/design-patterns/abstract-factory]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-创建模式之Factory Method]]></title>
      <url>%2F2017%2F11%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B9%8BFactoryMethod%2F</url>
      <content type="text"><![CDATA[目的Factory Method是创建模式的一种，他在父类中提供一个用来创建对象的接口，但是允许子类修改创建对象的类型。 问题假设你有一个后勤管理应用。应用的第一个版本只需要处理卡车这种运输方式，所以，你有一个Truck类。 不久，你的应用很受欢迎，你收到了许多需求，包括水运。 好消息，不是吗？但是你的代码怎么样呢？看起来，你的代码有许多地方要和Truck类耦合。添加Ship类需要改变整个代码库。此外，如果你决定添加另外一个类型的配送方式，你可能需要再次修改整个代码库。 解决Factory Method模式建议通过调用一个特别的“工厂”方法来代替直接创建对象（使用new操作）。构造方法应该移到那个方法中调用。工厂方法返回的对象被称为“产品”。 乍一看，这么做似乎没有意义。但是，现在你可以在字类中重写工厂方法，并且改变要创建对象的类。我们来看它是怎么工作的： 当然，这种方式有个限制：所有的产品必须遵循一个通用接口（Transport）。基类中的工厂方法需要返回这个通用接口。 字类返回不同的具体产品，它们都有一样的基类或者接口（比如：Truck和Ship都实现了Transport接口）。 工厂方法的客户端不需要关心它得到产品的类型。它们通过产品接口和所有产品协作。 结构 Product为creator和他的字类能够生产的对象定义接口。 Concrete Product是Product的不同实现。Concrete Creator将会创建并返回这饿类的实例。 Creator声明了一个返回Product类型的工厂方法。在第一个例子中，所有的Concrete Creator必须实现它们的工厂方法。 尽管这个名字在现实世界中，生产产品并不是Concrete Creator的主要责任。通常，他有一些处理产品的核心逻辑。 打个比方：大的软件开发公司有对开发者进行培训的部门。但是公司的主要功能还是写代码。 Concrete Creator实现或者重写基本的工厂方法，创建并返回一个Concrete Product。 注意：工厂方法并不总是创建一个新实例。它也可以从缓存中返回一个已经存在的对象。 伪代码这个例子用来展示工厂方法可以被用来创建跨平台的UI元素。工厂放被声明在对话框UI的基类中。它返回抽象的按钮。对话框的积累重写工厂方法并返回特定的按钮。 结果是使用基本对话框的代码组合了一个UI窗口。对话框通过通用接口和那妞协作。所以，不管工厂方法返回什么类型的按钮，对话框保留基本的功能。 因此，Factory Method使得类的主要代码独立于所使用的具体产品类。Factory Method让字类担负起选择生产产品所需要的具体类的责任。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// The Factory Method pattern is applicable only when there is a// products hierarchy.interface Button is method render() method onClick(f)class WindowsButton implements Button is method render(a, b) is Create and render a Windows looking button. method onClick(f) is Bind a native OS click event.class HTMLButton implements Button is method render(a, b) is Return an HTML representation of a button. method onClick(f) is Bind a web browser click event.// Base factory class. Note that the "factory" is merely a role for the class.// It should have some core business logic which needs different products to// be created.class Dialog is method renderWindow() is Render other window controls. Button okButton = createButton(); okButton.onClick(closeDialog); okButton.render(); // Therefore we extract all product creation code to a special // factory method. abstract method createButton()// Concrete factories extend that method to produce different kinds of products.class WindowsDialog extends Dialog is method createButton() is return new WindowsButton()class WebDialog extends Dialog is method createButton() is return new HTMLButton()class ClientApplication is field dialog: Dialog // Application picks a factory type depending on configuration // or environment. method configure() is if (we are in windows environment) then dialog = new WindowsDialog() if (we are in web environment) then dialog = new WebDialog() // The client code should work with factories and products through their // abstract interfaces. This way it will remain functional even if you add // new product types to the program. method main() is dialog.initialize() dialog.render() 适用性 当你的代码需要和不知道具体类型及一来对象协作时。 比如，从多数据源读写数据：文件系统，数据库或者网络。这些资源有着不同的类型，依赖和初始化代码。 工厂方法对其他代码隐藏了产品的实现细节。支持一个新的产品类型，你只需要创建一个新的字类并且重写工厂方法。 当你想要让用户扩展你的类库或者框架的内部组件时。 用户可以轻松的创建特定组件的字类。但是如何让框架识别这个字类并且替换标准的组件？用户必须重写每一个创建标准组件的方法，把它们改成创建自定义子类的对象。这样相当尴尬，不是吗？ 最好的方法不仅仅是给用户提供扩展某个类，而是将生成组件的代码减少到单个创建方法中。换句话说，提供出一个工厂方法。 让我们看看它如何工作。假设你在用一个开源的UI框架写app，你的app必须使用圆边按钮，但是框架只提供了一个方形的。 你做的第一件事就是实现一个RoundButton类。但是现在你需要告诉UIFramework类用一个新的按钮类代替默认的那个。 为了实现这个，你创建了基础框架的一个子类UIWithRoundButtons，并且重写了createButton方法。这个方法会返回一个Button对象，除了你创建的新子类RoundButton对象。现在，在你的app中，你必须使用UIWithRoundButtons类替代UIFramework来初始化框架。 当你想要保存系统资源并且重用存在的对象，而不是重新建立一个时。 比如，当你需要处理像数据库连接这类大的或者资源紧张对象。 想象下要重用存在的对象需要做什么： 首先，你需要创建一个池子来保存存在的对象。 当有人请求一个对象时，你需要在池子中找到一个闲置的对象。 然后把它返回给客户端代码。 仅仅在池子中没有闲置对象时，你才需要创建一个新的（并且把它放到池子中）。 这些代码必须放在某个地方。最便利的地方是构造方法。这样子就可以在请求创建对象时去做那些检查。但是，从定义上讲构造方法必须返回新对象，所以它们不能返回存在的实例。 另外，那些使用你对象的客户端代码也不能包含它。否则，客户端就知道太多你的类中的实现细节。因此，你需要一个独立的方法封装这个逻辑。那就是工厂方法。 如何实现 为所有产品抽离出通用的接口。这个接口应该声明对每个产品都有意义的方法。 在创建类中添加一个空的工厂方法。他的签名应当返回产品的接口类型。 查看创建者的代码并且找到所有用到产品构造方法的引用。将它们逐一替换为对工厂方法的调用，并将产品创建代码提取到工厂方法。 你可能需要为工厂方法添加临时变量来控制要创建的产品。此时，工厂方法的代码看起来很挫。 它有一个巨大的switch操作来获取要实例化产品的类。不过不用担心，我们马上修复他。 现在，在子类中重写工厂方法，并且把父类中对应的case语句挪到子类中。 基础创建类中的控制参数也可以用在子类中。 比如，你可能有一个Mail作为基类的层级结构，里面有Air和Ground，还有产品类：Plane，Truck和Train。Air正好和Plane匹配，但是Ground可以同时和Truck还有Train匹配。你可以创建一个新的子类来处理这两种情况，但是还有一种处理方式。客户端代码向Ground的工厂方法传递一个参数来控制它想要的产品。 如果基本工厂方法在移动后变成空的了，你可以把它标志成抽象方法。 优点 遵循开闭原则。 避免产品和使用它们代码的耦合。 把创建代码都移动到一个地方，简化了代码。 简化添加新产品的编程。 缺点 需要额外的子类。 和其他模式的关系 通常，设计从使用Factory Method开始（比较简单，并且可以通过子类实现定制），逐渐演变到Abstract Factory，Prototype，或者Builder（更加复杂，但更灵活），因为设计者发现它们需要更灵活的程序。 Abstract Factory类通常使用工厂方法实现，但也可以使用Prototype实现。 Factory Method可以和Iterator单独使用，让集合子类返回正确的迭代器。 Prototype不需要子类，但是需要一个“初始”操作。Factory Method需要子类，但是不需要初始化这个步骤。 Factory Method是一个专业化的Template Method。另一方面，Factory Method常常作为一个大Template Method的一个步骤。 小结工厂方法是一个用来解决创建产品对象时没有指定具体类的问题的设计模式。 工厂方法定义了一个方法，用来替代直接调用构造方法（new操作）。子类可以重写这个方法来改变要创建对象的类。 If you can’t figure out the difference between Factories, Factory Method &amp; Abstract Factory patterns, then read our Factory Comparison guide.如果你分不清楚Factories，Factory Method和Abstract Factory，可以阅读工厂比较指南（待译）。 在Java中的使用 用例 java.util.Calendar#getInstance() java.util.ResourceBundle#getBundle() java.text.NumberFormat#getInstance() java.nio.charset.Charset#forName() java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (Returns different singleton objects, depending on a protocol) java.util.EnumSet#of() javax.xml.bind.JAXBContext#createMarshaller() and other similar methods. 鉴定 工厂方法可以通过创建方法来识别，这些方法从具体类创建对象，但将它们作为抽象类型或接口的对象返回。 参考翻译整理自： https://refactoring.guru/design-patterns/factory-method]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-结构模式之小结]]></title>
      <url>%2F2017%2F11%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[目的结构设计模式使的我们简单快速的建立类的层级及不同类之间的关系，明确不同层级间的责任和边界，让各个模块、系统间相互独立并很好的协作。 概览Adapter模式适配器的目的是使不兼容接口间的可正常进行协作，它允许我们新增接口。主要用来解决下面两个问题： 接口间输入输出不匹配的问题，适配器在无法相互直接使用的接口间加入中间转换层，对数据格式进行转换，使接口间可以顺利协作。 当你需要复用几个已经存在的类，但是它们缺少一些常用的功能。并且你无法在父类中添加这些功能，因为他是闭源或者被其他代码使用的。可以把这些缺少的功能放到新建的适配器中。 比如像OutputStreamWriter，它在构造方法中接收一个OutputStream作为内部变量。OutputStream并没有提供对String或者char类型的支持，于是OutputStreamWriter就出现了，OutputStreamWriter的基类定义了该接口要实现的功能，然后适配传入的字符串，但是最终还是把输出工作交给了OutputStream。 Adapter反对完全重新定义一个接口，原文没有对完全重新定义接口作出解释，但是它改变了原有接口，不过也不必太过于纠结于此。只要我们根据设计模式提供的思维方式把问题很好的解决就好。 Facade模式门面让你为一个复杂的系统，类库或者框架提供一个简单的接口。可用在以下场景： 需要一个简单但是功能有限的复杂子系统接口时 把一个子系统构建成层级结构 上面两个场景在实际场景中很多，比如我们要使用第三方的类库，但是它并没有提供我们想要的接口，于是我们自己创建一个类来对它进行包装，并在这个类中管理三方库中一些对象的生命周期。 Decorator模式装饰器让你在封装包涵对象原有行为的基础上增加新的行为。可用在以下场景： 动态赋予某个对象行为并且不需要修改这个对象的代码 不可能或者不合适通过继承来扩展对象的行为 装饰器是对已有接口的增强，它没有改变原有的接口，对使用者完全透明。比如我们会用Collections的synchronizedMap(Map m)来让一个HashMap变成线程安全的，但经过增强的HashMap我们使用起来和之前并无不同。Decorator也被称为Wrapper，它们支持递归组合，我们可以根据需要叠加或者移除。它和Composite模式十分相似，但是从模式定义上讲，Composite并不会对接口做增强，只是对下级执行相同的操作并合并结果。 Proxy模式代理模式为另外一个对象提供一个替身或者占位符来控制对它的访问。作用如下： 懒初始化（虚拟代理）。当你有一个需要从文件系统，网络或者数据库加载数据的重量级对象时。 访问控制（保护代理）。当一个程序有不同类型的用户并且你想阻止未授权用户对保护对象的访问。 本地执行一个远程服务（远程代理）。当一个真实服务对象在远程服务器上时。 缓存对象（智能引用）。当你需要混存客户端的请求并且管理它们的生命周期时（当结果比较重时）时。 请求日志（日志代理）。当你需要保留一个服务对象的请求历史。 代理还分为静态和动态两种，动态代理常用在框架层面。上面列出的几个适用场景在Dubbo中有很好的体现，Dubbo代理了远程的服务，并对其做了缓存和访问控制等相关指标数据。了解Proxy模式去看下Dubbo源码是个不错的选择。 还是要从主要目的或者说意图上区分模式，Proxy并不像Decorator那样对接口做增强，也不像Adapter定义新的接口，但并不是Proxy做不了这些事情，它可以很轻松的对接口做增强，但那不是他的主要目的。PS：Proxy往往需要管理被代理对象的生命周期。 Composite模式Composite模式让我们可以像树一样组合对象，并且允许客户端像操作单个对象一样和这些结构协作。使用该模式前一定要正确梳理清楚现有实体间抽象关系。 当有以下场景时，考量使用该模式： 需要实现一个像树一样有着简单元素和容器的结构。 客户端要统一处理简单和复杂的元素时。 之前接触一个店铺装修系统，用户使用定义好的基本组件组合出不同的网页效果。像系统中的输入框、图片、按钮等是基本的组件（像树的叶子），用户可以使用基本组件组成更复杂的组件放到自定义组件中（像一个树枝），自定义组件和基本组件遵循相同的接口，有着相同的属性和操作。这样，渲染引擎在渲染在将一个画面渲染的时候只需要关注当前画面用了那些组件，不必关心组件式什么类型的，只需要通过接口设置/获取自己需要的属性值即可。 组合模式和装饰模式很像，都依赖递归组合，但不同的是，装饰器用来增强接口而组合模式只是对接口结果做了合并。不必纠结于如此一点差别。就像黑猫VS白猫，捉到老鼠就是好猫。 Bridge模式桥接模式分离一个巨大的类或者将一组关系相近的类分离成为两个独立的层次结构，抽象和实现，让各自可以独立开发。 这个模式提示我们，接口和实现必须分开。不过，现在企业级项目好像没有不这样做的。使用场景如下： 有一个包含一些功能变种的大类（工作在几个不同的数据库服务上） 需要在正交（独立）的维度扩展一个类（例子详见Bridge模式） 需要在运行时改变实现（一个接口多种实现，比如：临时切换系统的支付通道） Flyweight模式享元来自于拳击界，表示轻量级选手（选手小于111磅）。这个舶来词形象表明这个模式的意图。通过在多个对象见共享对象状态的通用部分而不是让各个对象独自持有的方式来节约内存。我们在系统中常会定义一些常量供不通的对象使用，这也体现了享元模式的思想。在Java的核心类库中，像Integer、Boolean、Long和BigDecimal等都缓存了常用的（最大/小／0等）数值。 小结翻译的文章对模式的解释比较浅显简单，可以让我们对模式有一个初步的认知，想要更深入理解和体会设计模式一方面离不开平时做项目时对业务和代码关于模式思考，尝试在编码时采用一些合适的模式，将理论运用到实践中，直观上体验模式带来的好处和问题；另一方面还是要深入读下《设计模式》这本书，来加深对模式的理解。个人认为模式的具体实现结构不必拘泥文中说的某种实现形式，它更重要的是要解决什么问题，以及我们可能会碰到什么问题，和优雅解决或者避免这些问题的方法。具体怎样去应用一个模式在单一介绍模式的文章中都有给出。 本次小结的这几种设计模式属设计模式中的结构部分，它告诉我们怎样比较合理的抽象数据结构间的层次和关系，也讲明了采用给出解决方法的会带来的一些问题。当然，一些场景的处理可能会有几种模式都可以适用，这时候就需要根据自己的主要意图、复杂性等方面来考量了，毕竟，复杂的代码让人讨厌。 TODO 目前对结构模式还是入门理解，会在看完《设计模式》中对结构模式的讲解后再来更新自己的这篇博文（2017年11月3日）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译-设计模式-结构模式之Flyweight]]></title>
      <url>%2F2017%2F10%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BFlyweight%2F</url>
      <content type="text"><![CDATA[目的Flyweight是结构模式的一种，通过在多个对象见共享对象状态的通用部分而不是让各个对象独自持有的方式来让你在可用的RAM中装入更多的对象。 问题在长时间工作后想要找些乐趣，你决定写一个简单的视频游戏。玩家能够在地图上移动并且可以相互射击。你决定实现一个真实的粒子系统并让它称为这个游戏的特性。子弹，导弹和爆炸产生的碎片应该到处飞舞并且能够给玩家分配经验。 过了一会，你最后一次提交代码并且把游戏发给了你的朋友，希望他能够立马玩起来。尽管游戏在你电脑上完美运行，但是你的朋友却不能玩起来。这个游戏总是在他的电脑上运行一会儿就崩溃。 在你看了日之后，发现是因为RAM不足导致了游戏崩溃。这个看起来和你的粒子系统有关。 每一个例子由一个包含和丰富数据的对象表示。在某一刻，当团战达到高潮，可用的RAM无法装入新创建的粒子，此时程序就崩溃了。 解决仔细检查Particle类，你会发现color和sprite数据是对象中最耗内存的字段。更糟糕的是，这些字段存储的是所有粒子都相同的数据。比如，所有的子弹都是相同的颜色和质地。 粒子的其他数据，像坐标，移动向量和速度是所有粒子唯一的。另外，这些字段的数据是实时变化的。对color和sprite这类保留常量而言，它们看起来就像粒子的可变上下文。 这些context-specific对象的变量数据通常被叫做“外在状态”，因为他们早对象外部变化。对象余下的状态，就是这些不可变的数据，被叫做“内在状态”。 Flyweight模式建议你不要再对象内部存储外部状态，而是通过调用方法时当作参数传递进来。通过这种方式你就可以把不可变状态留在对象内，这样你就可以在不同的上下文环境中重用它。更重要的，你将会需要很少这种对象，因为仅仅出现在固有状态不同时，而这种状态并不多。 就我们的游戏而言，只需要三个粒子对象就能满足（子弹，导弹和碎片）。现在你应该猜到了，这种分离对象的方式就叫做“flyweight”（享元，这个术语来自拳击，表示选手小于111磅）。 外部状态存储但是我们在那里做外部状态的移动？用一些类来持有他，对吗？大多情况下，把这些数据移动到容器中是很便利的，该容器用于在应用模式之前聚合对象。 在我们的例子中，它是主要游戏对象。你可以创建额外的数组字段来存储坐标，向量和速度。另外，你也需要其他的数组来存储表示一个粒子的指定享元对象的引用。 等一下！难道我们不需要在一开始就需要有相同数量的上下问对象？从技术上讲，需要。但事实是，这些对象要比之前小太多了。最耗内存的字段现在仅存活在几个享元对象中。上千个上下文对象可以连接并且重用单个享元对象，而不是复制状态到内部各自存储。 不可变性因为相同的享元对象可以被用在不同的上下文中，你必须确保它们的状态不能被改变。享元应该智能通过构造参数来接收内部状态。它们不应该暴露set方法或者称为公开字段。 享元工厂你可以创建一个工厂方法来管理已经存在享元对象的池子。这个方法接收客户端期望的内部状态，并能够在已经存在的享元对象中匹配这个状态，如果找到就返回它。如果没有找到，它将创建一个新享元并且把它加入池子。 有几个地方可以放置该方法。通常的做法是放在享元容器中。另外，一个新工厂类应该被创建。你甚至可以把工厂方法做成静态的，并将其放在主要的Flyweight类中。 结构 不要忘记，Flyweight模式是一种优化，只有在使用大量相似对象的程序中才有意义。模式把对象的状态分成两个部分：享元和上下文。 Flyweight保存能够在多个对象之间共享的原始对象状态的一部分。相同的享元对象可以被用在许多不同的上下文中。被保存在享元中的状态叫做“内部状态”。原始对象状态的另一部分通过参数传递给flyweight的称为“外在状态”。 Context包含外部状态，就是对所有原对象都唯一的那些。当一个上下文和一个享元对象结合起来，它就表示来一个原对象的所有状态。 大多情况下，原对象的行为保留在Flyweight类中。在这种情况下，不管是谁调用一个享元方法，必须把外部状态通过方法参数传递进来。另一方面，这个行为也可以放在Context类中，把连接的享元仅当作数据对象。 Client计算或者存储享元的外部状态。从一个客户端角度看，一个享元就是一个模版，可以在运行时通过调用带有上下文数据参数的方法进行配置。 Flyweight Factory管理已经存在享元的池子。客户端不直接创建享元。它们调用享元工厂的方法并且告诉这个创建方法它们期望得到享元的内部状态。工厂先去享元池中查找，如果这种享元已经存在就直返回，否则，就创建一个新的。 伪代码在这个例子中，享元模式帮助在画布上渲染一百万棵树。模式从一个主Tree类中抽离出重复的内部状态并把它放到一个享元类TreeType中。 现在不是将相同数据存储在多个对象中，而是把它们保留在几个享元对象中并且被响应的Tree对象连接（译者注：引用）。客户端代码通过享元工厂和不同的书协作，这个工厂封装了在新树对象中重用现有树类型的逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// The Flyweight class contains only a portion of state that describes a tree.// These field store values that hardly unique for each particular tree. You// won't find here tree coordinates, however textures and colors shared between// multiple are here. And since this data is usually BIG, you'd waste a lot of// memory by keeping it in each tree object. That's why we extract texture,// colors and other data to a separate flyweight class that can be referenced// from all those similar trees.class TreeType is field name field color field texture constructor Tree(name, color, texture) &#123; ... &#125; method draw(canvas, x, y) is Create a bitmap from type, color and texture. Draw bitmap on canvas at X and Y.// Flyweight factory decides whether to re-use existing flyweight or create a// new object.class TreeFactory is static field treeTypes: collection of tree types static method getTreeType(name, color, texture) is type = treeTypes.find(name, color, texture) if (type == null) type = new TreeType(name, color, texture) treeTypes.add(type) return type// Context object contains extrinsic part of tree state. Application can create// billions of these since they are pretty thin: just two integer coordinates// and one reference.class Tree is field x,y field type: TreeType constructor Tree(x, y, type) &#123; ... &#125; method draw(canvas) is type.draw(canvas, this.x, this.y)// Tree and Forest classes are Flyweight's clients. You might merge them// together if you don't plan to develop a Tree class any further.class Forest is field trees: collection of Trees method plantTree(x, y, name, color, texture) is type = TreeFactory.getTreeType(name, color, texture) tree = new Tree(x, y, type); trees.add(tree) method draw(canvas) is foreach tree in trees tree.draw(canvas) 适用性 当你在给定的RAM中难以装下必须要支持数量级的对象时。 应用Flyweight模式的好处在很大程度上取决于使用方式和位置。它常用在： 一个需要大量对象的应用； 这些对象占用系统全部RAM； 对象包含重复对象，并且它们可以被抽离并且共享。 如何实现 将一个类的字段划分享元，从以下两方面入手： 内部状态：字段包含不变的数据，许多对象的该字段值重复； 外部状态：字段包含上下文数据，所有对象的这个字段值都不一样。 把那些代表内部状态的字段保留在这个类中，并确保它们的不便性。它们应仅仅能通构造方法接收数据。 将外在状态的字段转化为引用它们的方法的参数。 创建一个享元工厂类。它应该在创建新享元之间检查该享元是否已经存在。客户端必须从享元工厂中请求享元。客户端需要在获取享元时需要像工厂方法描述它们期望的享元。 客户端必须存储或计算外部状态（上下文）的值以便能够调用flyweight对象的方法。 优点 节省RAM，因此允许一个程序支持更多对象。 缺点 在查找或者计算上下文时浪费CPU。 创建类更多的额外类增加代码复杂度。 和其他模式的关系 Flyweight常常和Composite结合使用来实现叶子结点共享和节约RAM。 Flyweight展示如何让创造更多小对象，而Facade告诉我们如何让用一个单独对象来代表一个完整子系统。 当每件事情都减少成一个享元对象时，Flyweight就和Singleton很像了。但是请记住，它们两者之间有两个根本区别： 单例对象是可变的。享元对象是不可变的。 Singleton的实力职能有一个，而Flyweight类可以有多个不同内部状态的实例。 Java中模式的应用用例：Flyweight目的单一：最小化内存占用。如果您的程序不会遇到RAM不足，那么你可以暂时忽略此模式。 Java核心库中Flyweight的例子： java.lang.Integer#valueOf(int) (also Boolean, Byte, Character, Short, Long and BigDecimal) 鉴定：Flyweight可以通过创建方法来识别，该方法返回缓存的对象，而不是创建新的对象。 参考翻译整理自：https://refactoring.guru/design-patterns/flyweight]]></content>
    </entry>

    
  
  
</search>
