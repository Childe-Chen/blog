<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="少爷凡隐">
<meta property="og:type" content="website">
<meta property="og:title" content="凡隐的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="凡隐的博客">
<meta property="og:description" content="少爷凡隐">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="凡隐的博客">
<meta name="twitter:description" content="少爷凡隐">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 凡隐的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">凡隐的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">平凡的世界</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/13/转-Servlet3-异步请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/13/转-Servlet3-异步请求/" itemprop="url">
                  转-Servlet3-异步请求
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-13T15:48:51+08:00">
                2017-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/转载/" itemprop="url" rel="index">
                    <span itemprop="name">转载</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/13/转-Servlet3-异步请求/" class="leancloud_visitors" data-flag-title="转-Servlet3-异步请求">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第22章-异步请求"><a href="#第22章-异步请求" class="headerlink" title="第22章 异步请求"></a>第22章 异步请求</h1><p>Servlet3.0规范新增了对异步请求的支持，Spring MVC也在此基础上对异步请求提供了方便。异步请求是在处理比较耗时的业务时先将request返回，然后另起线程处理耗时的业务，处理完后再返回给用户。</p>
<p>异步请求可以给我们带来很多方便，最直接的用法就是处理耗时的业务，比如，需要查询数据库、需要调用别的服务器来处理等情况下可以先将请求返回给客户端，然后启用新线程处理耗时业务，等处理完成后再将结果返回给用户。稍微扩展一下还可以实现订阅者模式的消息订阅功能，比如，当有异常情况发生时可以主动将相关信息发给运维人员，还有现在很多邮箱系统中收到新邮件的自动提示功能也是这种技术。甚至更进一步的使用方式是在浏览器上做即时通信的程序！</p>
<p>HTTP协议是单向的，只能客户端自己拉不能服务器主动推，Servlet对异步请求的支持并没有修改HTTP协议，而是对Http的巧妙利用。异步请求的核心原理主要分为两大类，一类是轮询，另一类是长连接。轮询就是定时自动发起请求检查有没有需要返回的数据，这种方式对资源的浪费是比较大的；长连接的原理是在客户端发起请求，服务端处理并返回后并不结束连接，这样就可以在后面再次运回给客户端数据。Servlet对异步请求的支持其实采用的是长连接的方式，也就是说，异步请求中在原始的请求返回的时候并没有关闭连接，关闭的只是处理请求的那个线程（一般是回收的线程池里了），只有在异步请求全部处理完之后才会关闭连接。</p>
<h2 id="22-1-Servlet3．O对异步请求的支持"><a href="#22-1-Servlet3．O对异步请求的支持" class="headerlink" title="22.1  Servlet3．O对异步请求的支持"></a>22.1  Servlet3．O对异步请求的支持</h2><p>在Servlet3.0规范巾使用异步处理请求非常简单，只需要在请求处理过程中调用request的startAsync方法即可，其返回值是AsyncContext类型。</p>
<p>AsyncContext在异步请求中充当着非常重要的角色，可以称为异步请求上下文也可以称为异步请求容器，无论叫什么其实就是个名字，它的作用是保存与异步请求相关的所有信息，类似于Servlet中的ServletContext。异步请求主要是使用AsyncContext进行操作，它是在请求处理的过程中调用Request的startAsync方法返回的，需要注意的是多次调用startAsync方法返回的是同一个AsyncContext。AsyncContext接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncContext</span> </span>&#123;</div><div class="line"></div><div class="line">  </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_REQUEST_URI = <span class="string">"javax.servlet.async.request_uri"</span>;</div><div class="line">   </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_CONTEXT_PATH = <span class="string">"javax.servlet.async.context_path"</span>;</div><div class="line">   </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_PATH_INFO = <span class="string">"javax.servlet.async.path_info"</span>;</div><div class="line">   </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_SERVLET_PATH = <span class="string">"javax.servlet.async.servlet_path"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_QUERY_STRING = <span class="string">"javax.servlet.async.query_string"</span>;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ServletRequest <span class="title">getRequest</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ServletResponse <span class="title">getResponse</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasOriginalRequestAndResponse</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(String path)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Runnable run)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(AsyncListener listener)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(AsyncListener listener,</span></span></div><div class="line">                            ServletRequest servletRequest,</div><div class="line">                            ServletResponse servletResponse);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T extends AsyncListener&gt; <span class="function">T <span class="title">createListener</span><span class="params">(Class&lt;T&gt; clazz)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，getResponse方法用得非常多，它可以获取到response，然后就可以对response进行各种操作了；dispatch方法用于将请求发送到一个新地址，有三个重载实现方法，其中没有参数dispatch方法的会发送到request原来的地址（如果有forward则使用forward后的最后一个地址）．一个path参数的dispatch方法直接将path作为地址，两个参数的dispatch方法可以发送给别的应用指定的地址；complete方法用于通知容器请求已经处理完了；start方法用于启动实际处理线程．不过也可以自己创建线程在其中使用AsyncContext保存的信息(如response)进行处理；addListener用于添加监听器；setTimeout方法用于修改超时时间，因为异步请求一般耗时比较长，而正常的请求设置的有效时长一般比较短，所以在异步请求中很多时候都需要修改超时的时间。</p>
<h3 id="22-1-1-Servlet-3-0处理异步请求实例"><a href="#22-1-1-Servlet-3-0处理异步请求实例" class="headerlink" title="22.1.1 Servlet 3.0处理异步请求实例"></a>22.1.1 Servlet 3.0处理异步请求实例</h3><p>使用Servlet 3.0处理异步请求需要三步：①配置Servlet时将async-supported设置为true；②在Servlet处理方法中调用Request的startAsync方法启动异步处理；③使用第2步中返同的<br>AsyncContext处理异步请求。</p>
<p>要想使用Servlet 3.0异步请求的功能需要在配置Servlet时将async-supported设置为true，比如，配置一个叫WorkServlet的可以处理异步请求的Servlet。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;WorkServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;com.excelib.servlet.WorkServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;async-supported&gt;true&lt;/async-supported&gt;</div><div class="line">&lt;/servlet&gt;</div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;WorkServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/work&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>然后新建一个叫WorkServlet的Servlet，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.excelib.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.*;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">        <span class="keyword">this</span>.doPost(req, resp);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span></span></div><div class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">        <span class="comment">// 设置contentType、关闭缓存</span></div><div class="line">        res.setContentType(<span class="string">"text/plain;charset=UTF-8"</span>);</div><div class="line">        res.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"private"</span>);</div><div class="line">        res.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>);</div><div class="line">        <span class="comment">// 原始请求可以做一些简单业务的处理</span></div><div class="line">        <span class="keyword">final</span> PrintWriter writer = res.getWriter();</div><div class="line">        writer.println(<span class="string">"老板检查当前需要做的工作"</span>);</div><div class="line">        writer.flush();</div><div class="line">        <span class="comment">// jobs表示需要做的工作，使用循环模拟初始化</span></div><div class="line">        List&lt;String&gt; jobs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            jobs.add(<span class="string">"job"</span>+i);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 使用request的startAsync方法开启异步处理</span></div><div class="line">        <span class="keyword">final</span> AsyncContext ac = req.startAsync();</div><div class="line">        <span class="comment">// 具体处理请求，内部处理启用了新线程，不会阻塞当前线程</span></div><div class="line">        doWork(ac, jobs);</div><div class="line">        writer.println(<span class="string">"老板布置完工作就走了"</span>);</div><div class="line">        writer.flush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(AsyncContext ac, List&lt;String&gt; jobs)</span></span>&#123;</div><div class="line">        <span class="comment">// 设置超时时间1小时</span></div><div class="line">        ac.setTimeout(<span class="number">1</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000L</span>);</div><div class="line">        <span class="comment">// 使用新线程具体处理请求 </span></div><div class="line">        ac.start(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                  <span class="comment">// 从AsyncContext获取到Response进而获取到Writer</span></div><div class="line">                    PrintWriter w = ac.getResponse().getWriter();</div><div class="line">                    <span class="keyword">for</span>(String job:jobs)&#123;</div><div class="line">                        w.println(<span class="string">"\""</span>+job+<span class="string">"\"请求处理中。。。"</span>);</div><div class="line">                        Thread.sleep(<span class="number">1</span> * <span class="number">1000L</span>); </div><div class="line">                        w.flush();</div><div class="line">                    &#125;</div><div class="line">                  <span class="comment">// 发出请求处理完成通知</span></div><div class="line">                    ac.complete();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的异步处理过程是在doWork方法中，它使用req．startAsync()返回的AsyncContext来处理的请求，处理完成后调用complete方法发出完成通知告诉容器请求已经处理完。doPost中除了startAsync和doWork外都是正常的操作，而且都有注释，就不解析了。当调用诸求时，返回页面结果如图22-1所示。</p>
<p>一个通过异步请求完成工作的示例程序就写完了。</p>
<h3 id="22-1-2异步请求监听器AsyncListener"><a href="#22-1-2异步请求监听器AsyncListener" class="headerlink" title="22.1.2异步请求监听器AsyncListener"></a>22.1.2异步请求监听器AsyncListener</h3><p>上面的程序已经可以完成工作了，不过还不够完善。老板这个职业是需要思考宏观问题的，它需要宏观的数据，所以在干完活后最好给领导汇报一下什么时候干完的、干的怎么样、有没有出什么问题等综合性的数据，不过这些事情按照分工并不应该由实际干活的人来做，如果非让它们做就可能会影响效率，而且它们汇报的数据也有可能不真实，所以老板应该找专人来做这件事，这就有了二线人员。在Servlet异步请求中干这个活的二线人员就是AsyncListener监听器，AsyncListener定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;     </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>onComplete方法在请求处理完成后调用，onTimeout方法在超时后调用，onError方法在出错时调用，onStartAsync方法在Request调用startAsync方法启动异步处理时调用。</p>
<p>这里需要注意的是只有在调用request.startAsync前将监听器添加到AsyncContext，监听器的onStartAsync方法才会起作用，而调用startAsync前AsyncContext还不存在，所以第一次调用startAsync是不会被监听器中的onStartAsync方法捕获的，只有在超时后又重新开始的情况下onStartAsync方法才会起作用。这一般也没有什么太大的问题，就像上面的例子中开始的时候是老板安排的任务，他自己当然知道，所以不汇报也没关系，不过如果到了时间节点任务没完成又重新开始了那还是要汇报的。</p>
<p>我们给前面的WorkServlet添加两个AsyncListener监听器BossListener和LeaderListener．一个用来给老板汇报，另一个用来给项目负责人汇报，它们都是定义在WorkServlet中的私有类，而且代码也都一样，其中BossListener的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BossListener</span> <span class="keyword">implements</span> <span class="title">AsyncListener</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理完成"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理出错，详情如下：\t"</span></div><div class="line">            +event.getThrowable().getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理开始"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理超时"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后将监听器注册到WorkServlet中，注册方法是在获取到AsyncContext后将监听器添加进去，相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用request的startAsync方法开启异步处理</span></div><div class="line"><span class="keyword">final</span> AsyncContext ac = req.startAsync();</div><div class="line"><span class="comment">// 添加两个监听器</span></div><div class="line">ac.addListener(<span class="keyword">new</span> BossListener());</div><div class="line">ac.addListener(<span class="keyword">new</span> LeaderListener(), req, res);</div><div class="line"><span class="comment">// 具体处理请求，内部处理启用了新线程，不会阻塞当前线程</span></div><div class="line">doWork(ac, jobs);</div><div class="line">writer.println(<span class="string">"老板布置完工作就走了"</span>);</div><div class="line">writer.flush();</div></pre></td></tr></table></figure></p>
<p>这样就将两个监听器注册完了。这里之所以添加了两个监听器，是要告诉大家一个AsyncContext可以添加多个监听器，而且有两个重载的添加方法。在监听器中可以使用AsyncEvent事件获取Request、Response以及在有异常的时候获取Throwable，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">event.getSuppliedRequest();</div><div class="line">event.getSuppliedReponse();</div><div class="line">event.getThrowable();</div></pre></td></tr></table></figure></p>
<p>##22.2  Spring MVC中的异步请求</p>
<p>Spring MVC为了方便使用异步请求专门提供了AsyncWebRequest类型的request，并且提供了处理异步请求的管理器WebAsyncManager和工具WebAsyncUtils。    </p>
<p>Spring MVC将异步请求细分为了Callable、WebAsyncTask、DeferredResult和ListenableFuture四种类型。前两种是一类，它们的核心是Callable，这一类很容易理解，因为大家对Callable应该都比较熟悉；DeferredResult类可能不是很容易理解，因为它是Spring MVC自己定义的类型，我们平时可能没使用过，而且相关资料也不多，所以刚接触的时候会觉得不知道从哪里人手，不过弄明白后其实是非常简单的；ListenableFuture足Spring MVC4.0新增的，它在Java的Future基础上增加了设置回调方法的功能，主要用于需要在处理器中调用别的资源（如别的url）的情况，Spring MVC专门提供了AsyncRestTemplate方法调用别的资源，并返回ListenableFuture类型。</p>
<p>本章先分析Spring MVC中异步请求使用到的组件，然后分析Spring MVC是怎么使用这些组件处理异步请求的，最后再分别对每一类返回值进行介绍。</p>
<h3 id="22-2-1-Spring-MVC中异步请求相关组件"><a href="#22-2-1-Spring-MVC中异步请求相关组件" class="headerlink" title="22.2.1 Spring MVC中异步请求相关组件"></a>22.2.1 Spring MVC中异步请求相关组件</h3><p>这里主要分析AsyncWebRequest、WebAsyncManager和WebAsyncUtils组件。WebAsyncManager里面还包含了一些别的组件，在分析的过程中也一起分析。<br><strong>AsyncWebRequest</strong><br>首先来看AsyncWebRequest，它是专门用来处理异步请求的request，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncWebRequest</span> <span class="keyword">extends</span> <span class="title">NativeWebRequest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(Long timeout)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addTimeoutHandler</span><span class="params">(Runnable runnable)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCompletionHandler</span><span class="params">(Runnable runnable)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">startAsync</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAsyncStarted</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAsyncComplete</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，addTimeoutHandler方法和addCompletionHandler方法分别用于添加请求超时和请求处理完成的处理器，其作用相当于AsyncListener监听器中的onTimeout和onComplete方法；isAsyncStarted方法用于判断是否启动了异步处理；isAsyncComplete方法用于判断异步处理是否已经处理完了。别的方法都与AsyncContext中的同名方法作用一样，就不一一解释了。它的实现类有两个，一个是NoSupportAsyncWebRequest，另一个是StandardServletAsyncWebRequest，前者不支持异步请求，所以在Spring MVC中实际用作异步请求的request是StandardServletAsync WebRequest.</p>
<p>StandardServletAsyncWebRequest除了实现了AsyncWebRequest接口，还实现了AsyncListener接口，另外还继承了ServletWebRequest，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServletAsyncWebRequest</span> <span class="keyword">extends</span> <span class="title">ServletWebRequest</span> <span class="keyword">implements</span> <span class="title">AsyncWebRequest</span>, <span class="title">AsyncListener</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Long timeout;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> AsyncContext asyncContext;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> AtomicBoolean asyncCompleted = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Runnable&gt; timeoutHandlers = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Runnable&gt; completionHandlers = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Create a new instance for the given request/response pair.</div><div class="line">	 * <span class="doctag">@param</span> request current HTTP request</div><div class="line">	 * <span class="doctag">@param</span> response current HTTP response</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StandardServletAsyncWebRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(request, response);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line">	 * &lt;p&gt;In Servlet 3 async processing, the timeout period begins after the</div><div class="line">	 * container processing thread has exited.</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(Long timeout)</span> </span>&#123;</div><div class="line">		Assert.state(!isAsyncStarted(), <span class="string">"Cannot change the timeout with concurrent handling in progress"</span>);</div><div class="line">		<span class="keyword">this</span>.timeout = timeout;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeoutHandler</span><span class="params">(Runnable timeoutHandler)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.timeoutHandlers.add(timeoutHandler);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCompletionHandler</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.completionHandlers.add(runnable);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> ((<span class="keyword">this</span>.asyncContext != <span class="keyword">null</span>) &amp;&amp; getRequest().isAsyncStarted());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Whether async request processing has completed.</div><div class="line">	 * &lt;p&gt;It is important to avoid use of request and response objects after async</div><div class="line">	 * processing has completed. Servlet containers often re-use them.</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.asyncCompleted.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAsync</span><span class="params">()</span> </span>&#123;</div><div class="line">		Assert.state(getRequest().isAsyncSupported(),</div><div class="line">				<span class="string">"Async support must be enabled on a servlet and for all filters involved "</span> +</div><div class="line">				<span class="string">"in async request processing. This is done in Java code using the Servlet API "</span> +</div><div class="line">				<span class="string">"or by adding \"&lt;async-supported&gt;true&lt;/async-supported&gt;\" to servlet and "</span> +</div><div class="line">				<span class="string">"filter declarations in web.xml."</span>);</div><div class="line">		Assert.state(!isAsyncComplete(), <span class="string">"Async processing has already completed"</span>);</div><div class="line">		<span class="keyword">if</span> (isAsyncStarted()) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.asyncContext = getRequest().startAsync(getRequest(), getResponse());</div><div class="line">		<span class="keyword">this</span>.asyncContext.addListener(<span class="keyword">this</span>);</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.timeout != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">this</span>.asyncContext.setTimeout(<span class="keyword">this</span>.timeout);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">()</span> </span>&#123;</div><div class="line">		Assert.notNull(<span class="keyword">this</span>.asyncContext, <span class="string">"Cannot dispatch without an AsyncContext"</span>);</div><div class="line">		<span class="keyword">this</span>.asyncContext.dispatch();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">	<span class="comment">// Implementation of AsyncListener methods</span></div><div class="line">	<span class="comment">// ---------------------------------------------------------------------</span></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="keyword">for</span> (Runnable handler : <span class="keyword">this</span>.timeoutHandlers) &#123;</div><div class="line">			handler.run();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="keyword">for</span> (Runnable handler : <span class="keyword">this</span>.completionHandlers) &#123;</div><div class="line">			handler.run();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.asyncContext = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">this</span>.asyncCompleted.set(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的代码比较长，不过很容易理解，它里面封装了个AsyncContext类型的属性asyncContext，在startAsync方法中会将Request#startAsync返回的AsyncContext设置给它，然后在别的地方主要使用它来完成各种功能。</p>
<p>另外，南于StandardServletAsyncWebRequest实现了AsyncListener接口，所以它自己就是一个监听器，而且在startAsync方法中在创建出AsyncContext后会将自己作为监听器添加进去。监听器实现方法中onStartAsync方法和onError方法是空实现，onTimeout方法和onComplete方法分别调用了封装的两个List类型的属性timeoutHandlers和completionHandlers所保存的Runnable方法，这样在使用时只需要简单地将需要监听超时和处理完成的监听方法添加到这两个属性中就可以了。</p>
<p><strong>WebAsyncManager</strong></p>
<p>WebAsyncManager是Spring MVC处理异步请求过程中最核心的类，它管理着整个异步处理的过程。</p>
<p>WebAsyncManager中最重要的两个方法是startCallableProcessing和startDeferredResultProcessing，这两个方法是启动异步处理的人口方法，它们一共做了三件事：①启动异步处理；②给Request设置相应属性（主要包括timeout、timeoutHandler和completionHandler）；③在相应位置调用相应的拦截器。这里的拦截器是Spring MVC自己定义的。</p>
<p>startCallableProcessing方法用于处理Callable和WebAsyncTask类型的异步请求，使用的拦截器类型是CallableProcessingInterceptor，拦截器封装在CallablelnterceptorChain粪型的拦截器链中统一调用。</p>
<p>startDeferredResultProcessing方法用于处理DeferredResult和ListenableFuture类型的异步请求，使用的拦截器是DeferredResultProcessinglnterceptor拦截器，拦截器封装在DeferredResultlnterceptorChain类型的拦截器链中统一调用。</p>
<p>这两个拦截器的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallableProcessingInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Object RESULT_NONE = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Object RESPONSE_HANDLED = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function"><span class="keyword">void</span>  <span class="title">beforeConcurrentHandling</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">postProcess</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task, Object concurrentResult)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function">Object <span class="title">handleTimeout</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>拦截器的作用就是在不同的时间点通过执行相应的方法来做一些额外的事情，所以要学习一种拦截器主要就是要理解它里边的各个方法执行的时间点。这两拦截器都定义了5个方法，方法名也都一样，而且从名字就很容易理解它们执行的时间点，就不分别解释了。需要注意的是，beforeConcurrentHandling方法是在并发处理前执行的，也就是会在主线程中执行，其他方法都在具体处理请求的子线程中执行。</p>
<p>CallableInterceptorChain和DeferredResultlnterceptorC hain分别用于封装两个Interceptor，它们都是将多个相应的拦截器封装到一个List类型的属性，然后在相应的方法中调用所封装的Interceptor相应方法进行处理。大家是不是很熟悉？它跟前面多次便用的XXXComposite组件类似，也是责任链模式。不过和XXXComposite组件不同的是，这里的方法名与Interceptor中稍有区别，它们的对应关系如下：</p>
<ol>
<li>applyBe foreConcurrentHandling：对应Interceptor中的beforeConcurrentHandling方法。</li>
<li>applyPreProcess：对应Interceptor中的preProcess方法。</li>
<li>applyPostProcess：对应Interceptor中的postProcess方法。</li>
<li>triggerAfterTimeout:对应Interceptor中的afierTimeout方法。</li>
<li>triggerAfterCompletion：对应Interceptor中的afterCompletion方法。</li>
</ol>
<p>理解了这些方法就知道Interceptor和InterceptorChain的作用了，它们都是在WebAsyncManager中相应位置调用的。</p>
<p>在正式分析WebAsyncManager前再看一下WebAsyncTask类，只有理解了这个类才能看明白WebAsyncManager中酌stariCallableProcessing方法。WebAsyncTask的作用主要是封装Callable方法，并且提供了一些异步调用相关的属性，理解了其中包含的属性就明白这个类了，其中属性定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; callable;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Long timeout;</div><div class="line"></div><div class="line"><span class="keyword">private</span> AsyncTaskExecutor executor;</div><div class="line"></div><div class="line"><span class="keyword">private</span> String executorName;</div><div class="line"></div><div class="line"><span class="keyword">private</span> BeanFactory beanFactory;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Callable&lt;V&gt; timeoutCallback;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Runnable completionCallback;</div></pre></td></tr></table></figure></p>
<p>callable用来实际处理请求；timeout用来设置超时时间；executor用来调用callable；executorName用来用容器中注册的名字配置executor；beanFactory用于根据名字获取executor; timeoutCallback相completionCallback分别用于执行超时和请求处理完成的回调。</p>
<p>这里的executor可以直接设置到WebAsyncTask中，也可以使用注册在容器中的名字来设置executorName属性，如果是使用名字来设置的WebAsyncTask的getExecutor方法会从beanFactory中根据名字executorName获取AsyncTaskExecutor，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AsyncTaskExecutor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.executor != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.executor;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.executorName != <span class="keyword">null</span>) &#123;</div><div class="line">		Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">"BeanFactory is required to look up an executor bean by name"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBean(<span class="keyword">this</span>.executorName, AsyncTaskExecutor.class);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>多知道点</strong></p>
<center>如何在Java中使用并发处理</center>

<hr>
<p>并发处理是通过多线程完成的，在Java中定义一个多线程的任务可以通过实现Runnable或者Callable接口完成，先来看一下Runnable接定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</div><div class="line">     * to create a thread, starting the thread causes the object's</div><div class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</div><div class="line">     * thread.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</div><div class="line">     * take any action whatsoever.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span>     java.lang.Thread#run()</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Runnable里只有一个run方法，我们只需要将需要执行的代码放到里面即可，行需要新建一个线程来调用，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Runnable task = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">        System.out.<span class="title">println</span><span class="params">(<span class="string">"do task"</span>)</span>;</div><div class="line">    &#125;</div><div class="line">    Thread thread = <span class="keyword">new</span> Thread(task);</div><div class="line">    thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里新建了task的Runnable类型任务，然后使用它创建了Thread并调用start方法执行了任务。需要说明的是，Thread本身也继承了Runnable接口，所以直接使用Thread来创建Runnable类型的任务然后执行，比如，上面的代码可以修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"do task"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure></p>
<p>这样一句代码就可以完成了。</p>
<p>在JavaI.5中新增了Callable接口，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Callable里面是call方法，而且可以有返回值还可以处理异常。Callable的执行需要有一个Executor容器来调用，就像Runnable任务需要Thread来调用一样，而且Executor也可以调用Runnable类型的任务。ExecutoriB用后会返回一个Future类型的返回值，我们可以调用Future的get方法来获取Callable中call方法的返回值，不过这个方法是阻塞的，只有call方法执行完后才会返回，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ExecutorsService = Executors.newCachedThreadPool();</div><div class="line">Callable callableTask = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        System.out.println(<span class="string">"do task"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Future&lt;String&gt; future = executor.submit(callableTask);</div><div class="line">System.out.println(<span class="string">"after submit task"</span>);</div><div class="line">String result = future.get();</div><div class="line">System.out.println(<span class="string">"after future.get()"</span>);</div><div class="line">System.out.println(<span class="string">"result="</span>+result);</div><div class="line">executor.shudown();</div></pre></td></tr></table></figure></p>
<p>这里定义了一个Callable类型的callableTask任务，在其call方法中会等待1秒然后输出<code>dotask</code>并返回<code>ok</code>。Executor调用submit方法提交任务后主程序输出<code>aftersubmittask</code>，这个应该在异步任务返回之前输出，因为方法需要等待1秒，输出<code>aftersubmittask</code>后调用future.get()，这时主线程会阻塞,直到call方法返回，然后输出”afterfuture.get()”，最后输出call返回的结果”ok”，程序运行后控制台打印如下：</p>
<blockquote>
<p>after submit task<br>do task<br>after future.get()<br>result=ok</p>
</blockquote>
<p>下面来看WebAsyncManager，首先介绍它里面的几个重要属性：</p>
<ol>
<li>timeoutCallablelnterceptor：CallableProcessinglnterceptor类型,专门用于Callable和WebAnsyncTask类型超时的拦截器</li>
<li>timeoutDeferredResultlnterceptor：DeferredResultProcessinglnterceptor类型，专门用于DeferredResult和ListenableFuture类型超时的拦截器。</li>
<li>callablelnterceptors: Map类型，用于所有Callable和WebAsyncTask类型的拦截器。</li>
<li>deferredResultlnterceptors：Map类型，用于所有DeferredResult和ListenableFuture类型的拦截器。</li>
<li>asyncWebRequest：为了支持异步处理而封装的request。</li>
<li>taskExecutor：用于执行Callable和WebAsyncTask类型处理，如果WebAsyncTask中没有定义executor则使用WebAsyncManager中的taskExecutor。</li>
</ol>
<p>下面分析WebAsyncManager里最核心的两个方法startCallableProcessing和startDeferredResultProcessing，这两个方法的逻辑基本一样，选择其中的startCallableProcessing来分析，这个方法用于启动Callable和WebAsyncTask类型的处理，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Use the given &#123;<span class="doctag">@link</span> WebAsyncTask&#125; to configure the task executor as well as</div><div class="line">	 * the timeout value of the &#123;<span class="doctag">@code</span> AsyncWebRequest&#125; before delegating to</div><div class="line">	 * &#123;<span class="doctag">@link</span> #startCallableProcessing(Callable, Object...)&#125;.</div><div class="line">	 * <span class="doctag">@param</span> webAsyncTask a WebAsyncTask containing the target &#123;<span class="doctag">@code</span> Callable&#125;</div><div class="line">	 * <span class="doctag">@param</span> processingContext additional context to save that can be accessed</div><div class="line">	 * via &#123;<span class="doctag">@link</span> #getConcurrentResultContext()&#125;</div><div class="line">	 * <span class="doctag">@throws</span> Exception if concurrent processing failed to start</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCallableProcessing</span><span class="params">(<span class="keyword">final</span> WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Assert.notNull(webAsyncTask, <span class="string">"WebAsyncTask must not be null"</span>);</div><div class="line">		Assert.state(<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>, <span class="string">"AsyncWebRequest must not be null"</span>);</div><div class="line"></div><div class="line">		Long timeout = webAsyncTask.getTimeout();</div><div class="line">		<span class="keyword">if</span> (timeout != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">this</span>.asyncWebRequest.setTimeout(timeout);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		AsyncTaskExecutor executor = webAsyncTask.getExecutor();</div><div class="line">		<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">this</span>.taskExecutor = executor;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		List&lt;CallableProcessingInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;CallableProcessingInterceptor&gt;();</div><div class="line">		interceptors.add(webAsyncTask.getInterceptor());</div><div class="line">		interceptors.addAll(<span class="keyword">this</span>.callableInterceptors.values());</div><div class="line">		interceptors.add(timeoutCallableInterceptor);</div><div class="line"></div><div class="line">		<span class="keyword">final</span> Callable&lt;?&gt; callable = webAsyncTask.getCallable();</div><div class="line">		<span class="keyword">final</span> CallableInterceptorChain interceptorChain = <span class="keyword">new</span> CallableInterceptorChain(interceptors);</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.asyncWebRequest.addTimeoutHandler(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				logger.debug(<span class="string">"Processing timeout"</span>);</div><div class="line">				Object result = interceptorChain.triggerAfterTimeout(asyncWebRequest, callable);</div><div class="line">				<span class="keyword">if</span> (result != CallableProcessingInterceptor.RESULT_NONE) &#123;</div><div class="line">					setConcurrentResultAndDispatch(result);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.asyncWebRequest.addCompletionHandler(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				interceptorChain.triggerAfterCompletion(asyncWebRequest, callable);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		interceptorChain.applyBeforeConcurrentHandling(<span class="keyword">this</span>.asyncWebRequest, callable);</div><div class="line">		startAsyncProcessing(processingContext);</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.taskExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Object result = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					interceptorChain.applyPreProcess(asyncWebRequest, callable);</div><div class="line">					result = callable.call();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">					result = ex;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">finally</span> &#123;</div><div class="line">					result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result);</div><div class="line">				&#125;</div><div class="line">				setConcurrentResultAndDispatch(result);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>通过注释可以看到startCallableProcessing方法主要做了5件事：①将webAsyncTask中相关属性取出并设置到对应的地方；②初始化拦截器链；③给asyncWebRequest设置timeoutHandler和completionHandler；④执行处理器链中相应方法；⑤启动异步处理并使用taskExecutor提交任务。</p>
<p>对其中的启动处理和执行处理详细解释一下，启动处理是调用了startAsyncProcessing方法，其中做了三件事：①调用clearConcurrentResult方法清空之前并发处理的结果；②谰用asyncWebRequest的startAsync方法启动异步处理；③将processingContext设置给concurrentResultContext属性。startAsyncProcessing方法的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAsyncProcessing</span><span class="params">(Object[] processingContext)</span> </span>&#123;</div><div class="line">	clearConcurrentResult();</div><div class="line">	<span class="keyword">this</span>.concurrentResultContext = processingContext;</div><div class="line">	<span class="keyword">this</span>.asyncWebRequest.startAsync();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		HttpServletRequest request = <span class="keyword">this</span>.asyncWebRequest.getNativeRequest(HttpServletRequest.class);</div><div class="line">		String requestUri = urlPathHelper.getRequestUri(request);</div><div class="line">		logger.debug(<span class="string">"Concurrent handling starting for "</span> + request.getMethod() + <span class="string">" ["</span> + requestUri + <span class="string">"]"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Clear &#123;<span class="doctag">@linkplain</span> #getConcurrentResult() concurrentResult&#125; and</div><div class="line"> * &#123;<span class="doctag">@linkplain</span> #getConcurrentResultContext() concurrentResultContext&#125;.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearConcurrentResult</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.concurrentResult = RESULT_NONE;</div><div class="line">	<span class="keyword">this</span>.concurrentResultContext = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>processingContext参数传进来的是处理器中使用的ModelAndViewContainer，concurrentResultContext用来在WebAsyncManager中保存ModelAndViewContainer，在请求处理完成后会设置到RequestMappingHandlerAdapter中，具体过程后面再分析。</p>
<p>下面再来说一下执行处理，执行处理使用的是taskExecutor，不过需要注意的是，这里并没直接使用taskExecutor.submit(callable)来提交，而是提交了新建的Runnable，并将Callable的call方法直接放在run方法里调用。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.taskExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    	Object result = <span class="keyword">null</span>;</div><div class="line">    	<span class="keyword">try</span> &#123;</div><div class="line">    		interceptorChain.applyPreProcess(asyncWebRequest, callable);</div><div class="line">    		result = callable.call();</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">    		result = ex;</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">finally</span> &#123;</div><div class="line">    		result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result);</div><div class="line">    	&#125;</div><div class="line">    	setConcurrentResultAndDispatch(result);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>这么做主要有两个作用：①可以在处理过程中的相应位置调用拦截器链中相应的方法；②在call方法执行完之前不会像Future#get()那样阻塞线程。</p>
<p>不过Runnable是没有返回值的，所以Callable处理的结果需要自己从run方法内部传递出来，WebAsyncManager中专门提供了一个setConcurrentResultAndDispatch方洪来处理返回的结果，这里边会将处理的结果传递出来，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setConcurrentResultAndDispatch</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">	<span class="keyword">synchronized</span> (WebAsyncManager.<span class="keyword">this</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (hasConcurrentResult()) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.concurrentResult = result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.asyncWebRequest.isAsyncComplete()) &#123;</div><div class="line">		logger.error(<span class="string">"Could not complete async processing due to timeout or network error"</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		logger.debug(<span class="string">"Concurrent result value ["</span> + <span class="keyword">this</span>.concurrentResult +</div><div class="line">				<span class="string">"] - dispatching request to resume processing"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.asyncWebRequest.dispatch();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>concurrentResult是WebAsyncManager中用来保存异步处理结果的属性，hasConcurrentResult方法用来判断concurrentResult是否已经存在返回值。整个方法过程是：如果concurrentResult已经有返回值则直接返回，否则将传人的参数设置到concurrentResult，然后调用asyncWebRequest.isAsyncComplete()检查Request是否已设置为异步处理完成状态（网络中断会造成Request设置为异步处理完成状态），如果是则保存错误日志并返回，否则调用asyncWebRequest.dispatch0发送请求。SpringMVC申异步请求处理完成后会再次发起一个相同的请求，然后在HandlerAdapter中使用一个特殊的HandlerMethod来处理它，具体过程后面再讲解，不过通过Request的dispatch方法发起的请求使用的还是原来的Request，也就是说原来保存在Request中的属性不会丢失。</p>
<p>startDeferredResultProcessing方法和startCallableProcessing方法执行过程类似，只是并没有使用taskExecutor来提交执行，这是因为DeferredResult并不需要执行处理，在后面讲了DeferredResult的用法后大家就明白了。</p>
<p>WebAsyncManager就分析到这里，下面来看WebAsyncUtils。</p>
<p><strong>WebAsyncUtils</strong></p>
<p>WebAsyncUtils里面提供了四个静态方法，其中一个是private权限，只供内部调用的，也就是一共提供了三个供外部使用的静态方法。它们定义如下：</p>
<ol>
<li><code>public static WebAsyncManager getAsyrtcManager (ServletRequest servletRequest)</code></li>
<li><code>public static WebAsyncManager getAsyncManager (WebRequest webRequest)</code></li>
<li>`public  static  AsyncWebRequest  createAsyncWebRequest (HttpServletRequest request, HttpServletResponse response)</li>
</ol>
<p>两重载的getAsyncManager方法通过Request获取WebAsyncManager，它们一个使用ServletRequest类型的Request，一个使用WebRequest类型的Request，获取过程都是先判断Request属性里是否有保存的WebAsyncManager对象，如果有则取出后直接返回，如果没有则新建一个设置到Request的相应属性中并返回，下次再获取时直接从Request属性中取出。</p>
<p>createAsyncWebRequest方法用于创建AsyncWebRequest，它使用ClassUtils.hasMethod判断传人的Request是否包含startAsync方法从而判断是否支持异步处理，如果不支持则新建NoSupportAsyncWebRequest类型的Request并返回，如果支持则调用createStandardServletAsyncWebRequest方法创建StandardServletAsync WebRequest类型的Request并返回。</p>
<h3 id="22-2-2-Spring-MVC对异步请求的支持"><a href="#22-2-2-Spring-MVC对异步请求的支持" class="headerlink" title="22.2.2 Spring MVC对异步请求的支持"></a>22.2.2 Spring MVC对异步请求的支持</h3><p>Spring MVC对异步请求的处理主要在四个地方进行支持，详述如下：<br>1)FrameworkServlet中给当前请求的WebAsyncManager添加了CallableProcessinglnterceptor类型的拦截器RequestBindinglnterceptor，这是定义在FrameworkServlet内部的一个私有的拦截器，其作用还是跟FrameworkServlet处理正常请求一样，在请求处理前将当前请求的LocaleContext和ServletRequestAttributes设置到了LocaleContextHolder和RequestContextHolder中，并在请求处理完成后恢复，添加过程在processRequest方法中，相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBindingInterceptor</span> <span class="keyword">extends</span> <span class="title">CallableProcessingInterceptorAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">(NativeWebRequest webRequest, Callable&lt;T&gt; task)</span> </span>&#123;</div><div class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</div><div class="line">		<span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</div><div class="line">			HttpServletResponse response = webRequest.getNativeRequest(HttpServletResponse.class);</div><div class="line">			initContextHolders(request, buildLocaleContext(request), buildRequestAttributes(request, response, <span class="keyword">null</span>));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">postProcess</span><span class="params">(NativeWebRequest webRequest, Callable&lt;T&gt; task, Object concurrentResult)</span> </span>&#123;</div><div class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</div><div class="line">		<span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</div><div class="line">			resetContextHolders(request, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2) RequestMappingHandlerAdapter酌invokeHandleMethod方法提供了对异步请求的核心<br>支持，其中做了四件跟异步处理相关的事情：    </p>
<ol>
<li>创建AsyncWebRequest并设置超时时间，具体时间可以通过asyncRequestTimeout属性配置到RequestMappingHandlerAdapter申。</li>
<li>对当前请求的WebAsyncManager设置了四个属性：taskExecutor,asyncWebRequest,callablelnterceptors和deferredResultlnterceptors，除了asyncWebRequest的另外三个都可以在RequestMappingHandlerAdapter中配置，taskExecutor如果没配置将默认使用SimpleAsyncTaskExecutor。</li>
<li>如果当前请求是异步请求而且已经处理出了结果，则将异步处理结果与之前保存到WebAsyncManager里的ModeIAnd\fiewContainer取出来,并将WebAsyncManager里的结果清空，然后调用ServletlnvocableHandlerMethod的wrapConcurrentResult方法创建ConcurrentResultHandlerMethod类型（ServletlnvocableHandlerMethod的内部类）的ServletlnvocableHandlerMethod来替换自己，创建出来的ConcurrentResultHandlerMethod并不执行请求，它的主要功能是判断异步处理的结果是不是异常类型，如果是则抛出，如果不是则使用ReturnValueHandler对其进行解析并返回。</li>
<li>如果requestMappingMethod的invokeAndHandle方法执行完后检查到当前请求已经启动了异步处理，则会直接返回null。</li>
</ol>
<p>RequestMappingHandlerAdapter中相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</div><div class="line">asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</div><div class="line"></div><div class="line"><span class="keyword">final</span> WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</div><div class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</div><div class="line">asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</div><div class="line">asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</div><div class="line">	Object result = asyncManager.getConcurrentResult();</div><div class="line">	mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</div><div class="line">	asyncManager.clearConcurrentResult();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</div><div class="line">	&#125;</div><div class="line">	requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的步骤3是调用了ServletInvocableHandlerMethod的wrapConcurrentResult方法创建了新的ServletlnvocableHandlerMethod来处理异步处理的结果，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ServletInvocableHandlerMethod <span class="title">wrapConcurrentResult</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConcurrentResultHandlerMethod(result, <span class="keyword">new</span> ConcurrentResultMethodParameter(result));</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>ConcurrentResultHandlerMethod是在ServletlnvocableHandlerMethod中定义的继承白ServletInvocableHandlerMethod的内部类，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CALLABLE_METHOD = ClassUtils.getMethod(Callable.class, <span class="string">"call"</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentResultHandlerMethod</span> <span class="keyword">extends</span> <span class="title">ServletInvocableHandlerMethod</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MethodParameter returnType;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcurrentResultHandlerMethod</span><span class="params">(<span class="keyword">final</span> Object result, ConcurrentResultMethodParameter returnType)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				<span class="keyword">if</span> (result <span class="keyword">instanceof</span> Exception) &#123;</div><div class="line">					<span class="keyword">throw</span> (Exception) result;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Throwable) &#123;</div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Async processing failed"</span>, (Throwable) result);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> result;</div><div class="line">			&#125;</div><div class="line">		&#125;, CALLABLE_METHOD);</div><div class="line">		setHandlerMethodReturnValueHandlers(ServletInvocableHandlerMethod.<span class="keyword">this</span>.returnValueHandlers);</div><div class="line">		<span class="keyword">this</span>.returnType = returnType;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Bridge to actual controller type-level annotations.</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">public</span> Class&lt;?&gt; getBeanType() &#123;</div><div class="line">		<span class="keyword">return</span> ServletInvocableHandlerMethod.<span class="keyword">this</span>.getBeanType();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Bridge to actual return value or generic type within the declared</div><div class="line">	 * async return type, e.g. Foo instead of &#123;<span class="doctag">@code</span> DeferredResult&lt;Foo&gt;&#125;.</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> MethodParameter <span class="title">getReturnValueType</span><span class="params">(Object returnValue)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.returnType;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Bridge to controller method-level annotations.</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getMethodAnnotation</span><span class="params">(Class&lt;A&gt; annotationType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> ServletInvocableHandlerMethod.<span class="keyword">this</span>.getMethodAnnotation(annotationType);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ConcurrentResultHandlerMethod调用父类的构造方法(super)将HandlerMethod中的Handler和Method都替换掉了，Handler用了新建的匿名Callable，Method使用了ServletInvocableHandlerMethod酌静态属性CALLABLE—METHOD，它代码Callable的call方法。新建的Callable的执行逻辑也非常简单，就是判断异步处理的返回值是不是异常类型，如果是则抛出异常，不是则直接返回，然后使用和原来请求一样的返回值处理器处理返回值（因为在构造方法中将原来ServletjnvocableHandlerMethod的返回值处理器设置给了自己）。</p>
<p>3)返回值处理器：一共有四个处理异步请求的返回值处理器，它们分别是AsyncTaskMethodReturnValueHandler、CallableMethodReturnValueHandler、De ferredResultMethodReturn ValueHandler和ListenableFutureReturnValueHandler，每一个对应一种类型的返回值，它们的作用主要是使用WebAsyncManager启动异步处理，后面依次对每一类返回值进行分析。</p>
<p>4)在DispatcherServlet的doDispatch方法中，当HandlerAdapter使用Handler处理完请求耐，会检查是否已经启动了异步处理，如果启动了则不再往下处理，直接返回，相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Actually invoke the handler.</span></div><div class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line"></div><div class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检查方法是调用的WebAsyncManager的isConcurrentHandlingStarted方法，其实内部就是调用的request的isAsyncStarted方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Whether the selected handler for the current request chose to handle the</div><div class="line"> * request asynchronously. A return value of "true" indicates concurrent</div><div class="line"> * handling is under way and the response will remain open. A return value</div><div class="line"> * of "false" means concurrent handling was either not started or possibly</div><div class="line"> * that it has completed and the request was dispatched for further</div><div class="line"> * processing of the concurrent result.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConcurrentHandlingStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> ((<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>) &amp;&amp; <span class="keyword">this</span>.asyncWebRequest.isAsyncStarted());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring MVC中跟异步请求处理相关的四个位置孰分析完了。主要处理流程是这样的：首先在处理器中返回需要启动异步处理的类型时（四种类型）相应返同值处理器会调用WebAsyncManager的相关方法启动异步处理，然后在DispatcherServlet中将原来请求直接返回，当异步处理完成后会重新发出一个相同的请求，这时在RequestMappingHandlerAdapter中会使用特殊的ServletlnvocableHandlerMethod来处理请求，处理方法是：如果异步处理返回的结果是异常类型则抛出异常，否则直接返回异步处理结果，然后使用返回值处理器处理，接着返回DispatcherServlet中按正常流程往下处理。</p>
<p>异步处理完成后会重新发起一个请求，这时会重新查找HandlerMethod并初始化PathVariable、MatrixVariable等参数，重新初始化Model中的数据并再次执行Handler-Interceptor中相应的方法。这么做主要是可以复用原来的那套组件进行处理而不需要重新定义。不过新请求的HandlerMethod是用的专门的类型，而Model是使用的原来保存在WebAsyncManager的concurrentResultContext届性中的ModelAndViewContainer所保存的Model，所以这里的查找HandlerMethod和初始化Model的过程是没用的，在这里可以进行一些优化，比如，将创建ConcurrentResultHandlerMethod的过程放在HandlerMapping中（这样也更符合组件的功能），然后在调用ModeIFactory的initModel方法前判断是不是异步处理dispatcher过来的请求，如果是<br>则不再初始化了，或者干脆创建新的HandlerAdapter来处理。</p>
<p>除了上述可以优化的地方，这里还有两个漏洞，第一个是相应的拦截器里的方法会被调用两次，这是不合适的，而且有的时候还会出问题，比如，如果用了拦截器来检查Token．那么第一次检查通过后就会将相应内容删除，第二次再检查的时候就检查失败了，这就有问题了。第二个是通过FlashMap传递Redirect参数的情况，在前面分析FlashMapManager获取FlashMap的时候说过，每次获取后就会将相应的FlashMap删除，但异步请求会获取两次，如果异步处理器是Redirect刭的结果处理器，并且使用FlashMap传递了参数，这种情况下如果在第二次获取FlashMap的时候（异步请求处理完了）正好用户又发了一个相同的请求，而且RedirectView已经将FlashMap设置到了Session，在获取之前可能被前面的请求获取删除，导致自己获取不到，这么说不容易理解，下面将两个请求的处理过程列出来大家就容易理解了：</p>
<table>
<thead>
<tr>
<th>请求1</th>
<th>请求2</th>
</tr>
</thead>
<tbody>
<tr>
<td>saveOutputFlashMap</td>
<td>设置FM1</td>
</tr>
<tr>
<td>retrieveAndUpdate</td>
<td>获取到FM1</td>
</tr>
<tr>
<td>saveOutputFlashMap</td>
<td>设置FM2</td>
</tr>
<tr>
<td>retrieveAndUpdate</td>
<td>获取到FM2</td>
</tr>
<tr>
<td>retrieveAndUpdate</td>
<td>获取到null</td>
</tr>
<tr>
<td>retrieveAndUpdate</td>
<td>获取到null</td>
</tr>
</tbody>
</table>
<p>这样请求2设置的FlashMap就会被请求1的第二次retrieveAndUpdate获取到并从Session中删除，请求2就获取不到了，这样两个请求的值就都出了问题了。</p>
<p>这里的第二个漏洞只是从原理上来说存在，一般不会造成什么影响，因为这种情况发生的概率非常小，但第一个漏洞是比较严重的，如果真正使用了类似判断Token等的拦截器需要在具体方法内部自己处理一下。</p>
<p>异步处理流程就说到这里，下面分析每一类返回值的具体处理过程。</p>
<h3 id="22-2-3-WebAsyncTask和Calla-ble类型异步请求的处理过程及用法"><a href="#22-2-3-WebAsyncTask和Calla-ble类型异步请求的处理过程及用法" class="headerlink" title="22.2.3 WebAsyncTask和Calla ble类型异步请求的处理过程及用法"></a>22.2.3 WebAsyncTask和Calla ble类型异步请求的处理过程及用法</h3><p>当处理器方法返回WebAsyncTask或Callable类型时将自动启用异步处理。下面来看一下处理WebAsyncTask类型返回值的处理器AsyncTaskMethodReturnValueH andler．它的handleReturnValue方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></div><div class="line">		ModelAndViewContainer mavContainer, NativeWebRequest webRequest) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</div><div class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	WebAsyncTask&lt;?&gt; webAsyncTask = (WebAsyncTask&lt;?&gt;) returnValue;</div><div class="line">	webAsyncTask.setBeanFactory(<span class="keyword">this</span>.beanFactory);</div><div class="line">	WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(webAsyncTask, mavContainer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果返回值为null，就会给mavContainer设置为请求已处理，然后返回。如果返回值不为null，调用WebAsyncManager的startCallableProcessing方法处理请求。WebAsyncManager是使用WebAsyncUtils获取的。下面来看一个例子，首先给配置Spring MVC的Servlet添加异步处理支持，也就是添加async-supported属性，代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>let'sGo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>WEB-INF/let'sGo-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接下来写一个AsyncController，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.excelib.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.*;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/webasynctask"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">webAsyncTask</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"WebAsyncTask处理器主线程进入"</span>);</div><div class="line">        WebAsyncTask&lt;String&gt; task = <span class="keyword">new</span> WebAsyncTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000L</span>);</div><div class="line">                System.out.println(<span class="string">"WebAsyncTask处理执行中。。。"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="string">"久等了"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(<span class="string">"WebAsyncTask处理器主线程退出"</span>);</div><div class="line">        <span class="keyword">return</span> task;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里新建了WebAsyncTask，并使用匿名类建了Callable进行异步处理，实际使用中可以在其中写数据库请求等耗时的业务，这里直接等了5秒来模拟。处理器注释了@ResponseBody，其返回值会直接返回给浏览器。当调用<code>http://localhost:8080/ webasynctask</code>时，会在等待大约5秒后返回给浏览器<code>久等了</code>三个字。</p>
<p>现在再返回去看WebAsyncManager的startCallableProcessing方法就容易理解了，其实就是先添加拦截器，并在相应的地方执行拦截器里的方法，最后使用taskExecutor调用返回WebAsyncTask申的Callable处理。</p>
<p>当然这里只是给WebAsyncTask设置了Callable，除此之外还可以设置executor、timeout、timeoutCallback和completionCallback等属性。</p>
<p>Callable的处理其实是在WebAsyncManager内部封装成WebAsyncTask后再处理的。当处理器中返回Callable类型的返回值时，Spring MVC会使用CallableMethodReturnValueHandler来处理返回值，它的handleReturnValue方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Callable.class.isAssignableFrom(returnType.getParameterType());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></div><div class="line">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</div><div class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Callable&lt;?&gt; callable = (Callable&lt;?&gt;) returnValue;</div><div class="line">		WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里直接调用了WebAsyncManager的startCallableProcessing方法进行处理，不过这是一个重载的第一个参数是Callable类型的startCallableProcessing方法，其代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCallableProcessing</span><span class="params">(Callable&lt;?&gt; callable, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	Assert.notNull(callable, <span class="string">"Callable must not be null"</span>);</div><div class="line">	startCallableProcessing(<span class="keyword">new</span> WebAsyncTask(callable), processingContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它还是将Callable封装成了WebAsyncTask然后处理的。如果WebAsyncTask中只有Callable而没有别的属性的时候可以直接返回Callable，比如前面的处理器可以修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.excelib.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.*;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/callable"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">callable</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Callable处理器主线程进入"</span>);</div><div class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000L</span>);</div><div class="line">                System.out.println(<span class="string">"Callable处理执行中。。。"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="string">"久等了"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        System.out.println(<span class="string">"Callable处理器主线程退出"</span>);</div><div class="line">        <span class="keyword">return</span> callable;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它和前面使用WebAsyncTask执行的效果是一样的。</p>
<h3 id="22-2-4-DeferredResult类型异步请求的处理过程及用法"><a href="#22-2-4-DeferredResult类型异步请求的处理过程及用法" class="headerlink" title="22.2.4 DeferredResult类型异步请求的处理过程及用法"></a>22.2.4 DeferredResult类型异步请求的处理过程及用法</h3><p>DeferredResult是spring提供的一种用于保存延迟处理结果的类，当一个处理器返回DeferredResult类型的返回值时将启动异步处理。</p>
<p>不过DeferredResult和WebAsyncTask的使用方法完全不同，DeferredResult并不是用于处理请求的，而且也不包含请求的处理过程，它是用来封装处理结果的，有点像Java中的Future，但不完全一样。</p>
<p>使用DeferredResult的难点就在理解其含义，对其含义理解了之后就会觉得非常简单，而且使用起来也很方便。在返回WebAsyncTask时是因为处理的时间过长所以使用了异步处理，但其实还是自己来处理的（因为WebAsyncTask需要提供Callable），而返回DeferredResult表示要将处理交个别人了，什么时候处理完、怎么处理的自己并不需要知道，这就好像在单位经常用到的“妥否，请批示”的请示报告，自己并不知道什么时候能批下来，而且也不需要知道具体批示过程，只需要知道最后的结果就可以了。DeferredResult就是来保存结果的，当处理完之后调用它的setResult方法将结果设置给它就可以了。</p>
<p>DeferredResult还提供了一些别的属性，如resultHandler可以在设置了结果之后对结果进行处理、timeout设置超时时间、timeoutCallback设置超时处理方法、completionCallback设置处理完成后酌处理方法、timeoutResult设置超时后返回的结果等。</p>
<p>下面看一下Spring MVC中处理DeferredResult返回值的DeferredResultMethodReturnValueHandler处理器，它的handleReturnValue方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredResultMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> DeferredResult.class.isAssignableFrom(returnType.getParameterType());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></div><div class="line">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</div><div class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		DeferredResult&lt;?&gt; deferredResult = (DeferredResult&lt;?&gt;) returnValue;</div><div class="line">		WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里直接凋用了WebAsyncManager的startDeferredResultProcessing方法进行处理。</p>
<p>下面来看一个返回值为DeferredResult的处理器的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.excelib.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.*;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/deferred"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">deferredResultExam</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> DeferredResult&lt;String&gt; result = <span class="keyword">new</span> DeferredResult&lt;String&gt;(<span class="number">7</span>*<span class="number">1000L</span>, <span class="string">"超时了"</span>);</div><div class="line">        approve(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">approve</span><span class="params">(DeferredResult&lt;String&gt; result)</span></span>&#123;</div><div class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000L</span>);</div><div class="line">                    result.setResult(<span class="string">"同意 "</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(<span class="keyword">new</span> Date()));</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">new</span> Thread(r).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在处理器方法中直接新建了个DeferredResult类型的result代表处理结果，构造方法的两个参数分别表示超时时间和超时后返回的结果，建出来后将其交给approve方法进行处理（审批），当approve方法给result使用setResult方法设置了值后异步处理就完成了。</p>
<p>approve方法启动了一个新线程，然后在里面等待5秒后给result设置值。因为这里的处理器有@ResponseBody注释，所以返回值会直接显示到浏览器，当调用<code>http://localhost:8080/deferred</code>时，浏览器会在过大约5秒后显示<code>同意2015-04-02</code>。</p>
<p>现在大家再返回去看WebAsyncManager酌startDeferredResultProcessing方法就容易理解了，它并没有而且也不需要执行，只需要等待别的线程给设置返回值就可以了。方法中给result设置了处理返回值的处理器，当有返回值返回时会自动调用，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deferredResult.setResultHandler(<span class="keyword">new</span> DeferredResultHandler() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">		result = interceptorChain.applyPostProcess(asyncWebRequest, deferredResult, result);</div><div class="line">		setConcurrentResultAndDispatch(result);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里的处理器中首先调用了拦截器链中的applyPostProcess方法，然后调用setConcurrentResultAndDispatch万法处理了返回值，setConcurrentResultAndDispatch方法前面已经说过了。</p>
<p>现在大家应该对DeferredResult返回值的异步处理就理解了，DeferredResult是一个用于保存返回值的类，只需要在业务处理完成后调用其setResult方法设置结果就可以了，至于怎么处理的、在哪里处理的它并不关心，这也就给我们带来了很大的自由。</p>
<h3 id="22-2-5-ListenableFuture类型异步请求的处理过程及用法"><a href="#22-2-5-ListenableFuture类型异步请求的处理过程及用法" class="headerlink" title="22.2.5 ListenableFuture类型异步请求的处理过程及用法"></a>22.2.5 ListenableFuture类型异步请求的处理过程及用法</h3><p>ListenableFuture继承自Future，Future在前面已经介绍过了，它用来保存Callable的处理结果，它提供了get方法来获取返回值，不过Future并不会在处理完成后主动提示。ListenableFuture在Future基础上增加了可以添加处理成功和处理失败回调方法的方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListenableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(ListenableFutureCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(SuccessCallback&lt;? <span class="keyword">super</span> T&gt; successCallback, FailureCallback failureCallback)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ListenableFutureCallback继承自SuccessCallback和FailureCallback接口，后两个接口分别有一个onSuccess方法和onFailure方法，用于处理异步处理成功的返回值和异步处理失败的返回值，就和DeferredResult中的resultHandler差不多，它们定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListenableFutureCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SuccessCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">FailureCallback</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuccessCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Called when the &#123;<span class="doctag">@link</span> ListenableFuture&#125; successfully completes.</div><div class="line">	 * <span class="doctag">@param</span> result the result</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T result)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FailureCallback</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Called when the &#123;<span class="doctag">@link</span> ListenableFuture&#125; fails to complete.</div><div class="line">	 * <span class="doctag">@param</span> ex the exception that triggered the failure</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ListenableFuture足spring4.0新增的接口，它主要使用在需要调用别的服务的时候，spring还同时提供了AsyncRestTemplate，用它可以方便地发起各种Http请求，不同类型的请求（如Get、Post等）都有不同的方法，而且还可以使用url的模板参数uriVariables（类似于处理器参数中的pathVariables】，它的返回值就是ListenableFuture类型，比如，可以这样使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; futureEntity = template.getForEntity(</div><div class="line"><span class="string">"http://localhost:8080/students/&#123;studentld&#125;/books/&#123;bookldl"</span> , String.class, <span class="string">"176"</span>, <span class="string">"7"</span>);</div></pre></td></tr></table></figure></p>
<p>这样就可以返回<a href="http://localhost:808" target="_blank" rel="external">http://localhost:808</a> 0/students/1 7 6/books/7的Get请求结果，而且是非阻塞的异步调用。</p>
<p>下面看一下处理ListenableFuture返回值的处理器ListenableFutureReturnValueHandler，它的handleReturnValue方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></div><div class="line">		ModelAndViewContainer mavContainer, NativeWebRequest webRequest) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</div><div class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> DeferredResult&lt;Object&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;Object&gt;();</div><div class="line">	WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer);</div><div class="line"></div><div class="line">	ListenableFuture&lt;?&gt; future = (ListenableFuture&lt;?&gt;) returnValue;</div><div class="line">	future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;Object&gt;() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</div><div class="line">			deferredResult.setResult(result);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">			deferredResult.setErrorResult(ex);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到在ListenableFuture的返回值处理器里实际使用了DeferredResult．首先新建了DeferredResult类型的deferredResult，接着调用了WebAsyncManager的startDeferredResultProcessing方法进行处理，然后给ListenableFuture类型的返回值添加了回调方法，在回调方法中对deferredResult设置了返回值。可以说ListenableFuture类型的返回值只是DeferredResult类型返回值处理器的一种特殊使用方式。大家好好体会这里的处理过程就可以对<code>DeferredResult跟具体处理过程无关</code>这一点理解得更加深入。</p>
<p>下面来看一个ListenableFuture类型返回值处理器的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.excelib.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.*;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/listenable"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</div><div class="line">    <span class="keyword">public</span> ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; listenableFuture() &#123;</div><div class="line">        ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; future = <span class="keyword">new</span> AsyncRestTemplate().getForEntity(</div><div class="line">                <span class="string">"http://localhost:8080/index"</span>, String.class);</div><div class="line">        <span class="keyword">return</span> future;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里处理器的返回值ListenableFuture的泛型是ResponseEntity类型，所以不需要使用@ResponseBody注释也会将返回值直接显示到浏览器。当调用<code>http://localhost:8080/listenable</code>时，浏览器会显示<code>excelibGoGoGo!</code>，也就是<code>http://localhost:8080/index</code>的返回结果.。</p>
<p><strong>多知道点</strong></p>
<center>ListenableFuture和Future的比较</center>

<p>ListenableFuture在Future的基础上增加了可以添加处理成功和处理失败回调方法的方法，这就从Future的“拉”模式变成了ListenableFuture的“推”模式。</p>
<p>Future只能调用get方法来主动拉数据，而且get方法还是阻塞的，而ListenableFuture可以等待处理完成后自己将结果推过来，而且不会阻塞线程，这么看好像ListenableFuture比Future更好用。其实在很多地方Future中阻塞的get方法才是真正需要的，因为很多时候都需要等到线程处理的结果才可以向下进行，比如，要找四个数中最大的那个，可以将四个数分成两组然后启动两个线程分别选出每组中比较大的数，然后再启动一个线程取出两个结果中比较大的，那就是四个数中最大的数，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObtainBigger</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        <span class="comment">// 需要查找最大数的数组</span></div><div class="line">        Double data[] = <span class="keyword">new</span> Double[]&#123;<span class="number">210.32</span>, <span class="number">517.96</span>, <span class="number">986.77</span>, <span class="number">325.13</span>&#125;;</div><div class="line">        <span class="comment">// 获取前两个里较大的</span></div><div class="line">        BiggerCallable c1 = <span class="keyword">new</span> BiggerCallable(data[<span class="number">0</span>],data[<span class="number">1</span>]);</div><div class="line">        Future&lt;Double&gt; bigger1 = executor.submit(c1);</div><div class="line">        <span class="comment">// 获取后两个里较大的</span></div><div class="line">        BiggerCallable c2 = <span class="keyword">new</span> BiggerCallable(data[<span class="number">2</span>],data[<span class="number">3</span>]);</div><div class="line">        Future&lt;Double&gt; bigger2 = executor.submit(c2);</div><div class="line">        <span class="comment">// 获取两个结果中较大的，这时会阻塞，只有前面两个结果都返回时才会往下进行</span></div><div class="line">        BiggerCallable c = <span class="keyword">new</span> BiggerCallable(bigger1.get(), bigger2.get());</div><div class="line">        Future&lt;Double&gt; bigger = executor.submit(c);</div><div class="line">        <span class="comment">// 输出结果</span></div><div class="line">        System.out.println(bigger.get());</div><div class="line">        executor.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BiggerCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</div><div class="line">        Double d1, d2;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BiggerCallable</span><span class="params">(Double d1, Double d2)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.d1 = d1;</div><div class="line">            <span class="keyword">this</span>.d2 = d2;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> d1&gt;d2?d1:d2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里使用了内部类BiggerCallable来比较，第三个BiggerCallable创建时前两个cl）c2必须已经执行完才可以，否则就会出问题，所以在这种情况下阻塞就是必要的，而且这种需要线程返回结果后才能往下进行的情况很多。而ListenableFuture的典型用法就是Web异步请求这种并不需要对线程返回的结果进一步处理，而且线程在返回之前主线程可以继续往下走的情况，这时如果程序阻塞就起不到应有的作用了。</p>
<h2 id="22-3小结"><a href="#22-3小结" class="headerlink" title="22.3小结"></a>22.3小结</h2><p>本章系统地介绍了Servlet和SpringMVC中异步处理的原理和使用方法，首先介绍了Servlet3.0中对异步请求的支持及其使用方法，然后又分析了SpringMVC中异步处理的执行过程并编写了示例程序。</p>
<p>Servlet中使用异步请求非常方便，只需要调用request的startAsync方法，然后对其返回值AsyncContext进行处理，如果需要还可以为其添加AsyncListener监听器，它可以监听异步请求的启动、超时、处理完成和处理异常四个节点。</p>
<p>Spring MVC为异步请求提供了专门的工具，并对处理器默认提供了四种用于异步处理的返回值：</p>
<pre><code>1. Callable、
2. WebAsyncTask、
3. DeferredResult
4. ListenableFuture。
</code></pre><p>对异步请求的支持主要在RequestMappingHandlerAdapter中，启动异步处理在各返回值对应的返回值处理器中。</p>
<p>原文链接：<a href="https://github.com/sixtrees/kantouspringmvc/blob/master/%E7%AC%AC22%E7%AB%A0%20%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.md" target="_blank" rel="external">https://github.com/sixtrees/kantouspringmvc/blob/master/%E7%AC%AC22%E7%AB%A0%20%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.md</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/22/译-JVM-Concurrent-Mark-Sweep-CMS-Collector-1-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/22/译-JVM-Concurrent-Mark-Sweep-CMS-Collector-1-8/" itemprop="url">
                  (译)JVM Concurrent Mark Sweep (CMS) Collector 1.8
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T15:48:01+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/22/译-JVM-Concurrent-Mark-Sweep-CMS-Collector-1-8/" class="leancloud_visitors" data-flag-title="(译)JVM Concurrent Mark Sweep (CMS) Collector 1.8">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>最近线上JDK升级到啦1.8，应用在发布时，总会发生Full GC报警，看了下GC日志，发现应用重启时会接连发生4次Full GC，但是这4次GC后很久一段时间（第二天再次查看GC日志和jstat的统计）没有再发生Full GC，查了下官方资料，顺便翻译出来，方便以后阅读。翻译的不好，请见谅，也欢迎提出建议，在下将不胜感激。</p>
<p>原文链接：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html</a></p>
<p>The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer shorter garbage collection pauses and that can afford to share processor resources with the garbage collector while the application is running. Typically applications that have a relatively large set of long-lived data (a large tenured generation) and run on machines with two or more processors tend to benefit from the use of this collector. However, this collector should be considered for any application with a low pause time requirement. The CMS collector is enabled with the command-line option -XX:+UseConcMarkSweepGC.</p>
<p>CMS收集器特点：1.更短的垃圾回收暂停(stop the world) 2.垃圾收集器能够在应用运行时与其共享处理器资源。通常，一个运行在多处理器机器上并且其中有长期存活的大集合(较大的老生代)的应用可以考虑使用CMS收集器。当然，对于具有低暂停时间要求的应用，都可以考虑使用该收集器。使用-XX:+UseConcMarkSweepGC来启用CMS收集器。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/05/22/译-JVM-Concurrent-Mark-Sweep-CMS-Collector-1-8/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/JDK源码-hash杂记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/JDK源码-hash杂记/" itemprop="url">
                  JDK源码 Hash杂记
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-11T19:29:30+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂记/" itemprop="url" rel="index">
                    <span itemprop="name">杂记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/11/JDK源码-hash杂记/" class="leancloud_visitors" data-flag-title="JDK源码 Hash杂记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>最早了解Hash的用法，是一次分表的经历，公司用户表数据有几千万，查询的效率已经比较低了，需要做拆分处理，之前系统中已经有分表的数据，处理方式比较简单，没有使用中间件，按照商家的ID（32位字符串）做Hash然后取模，算出其落在表的编号，然后加上前缀得到最终表名。</p>
<p>最近在了解zk分布式锁时，为了避免一种实现方式的羊群效应，其改进思路类似一致性哈希算法。于是，便看了下Hash相关的知识，并用Java做了简单实现。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/05/11/JDK源码-hash杂记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/JDK源码-java的四种Reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/JDK源码-java的四种Reference/" itemprop="url">
                  JDK源码 Java Reference
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T15:08:54+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/24/JDK源码-java的四种Reference/" class="leancloud_visitors" data-flag-title="JDK源码 Java Reference">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>之前探讨过一次JAVA的FinalReference，这次我们来看下java.lang.ref包下对应的其他三种引用。</p>
<h4 id="走近引用"><a href="#走近引用" class="headerlink" title="走近引用"></a>走近引用</h4><p>Reference和ReferenceQueue在使用中一定是结伴出现的，当一个Reference确定要被GC回收，GC便会把Reference加入到与之关联的ReferenceQueue中。注意：在Reference的构造方法中，我们可以传入一个注册队列ReferenceQueue，这个队列我们稍后会具体看，需要主要的是，这个队列需要单独的线程去做消费，否则会存在OOM的隐患。</p>
<p>这些引用可用来实现不同的缓存类型（内存敏感和内存不敏感），大名鼎鼎的Guava cache就是基于引用的这些特性来实现高速本地缓存。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/24/JDK源码-java的四种Reference/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/01/JDK源码-FinalReference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/JDK源码-FinalReference/" itemprop="url">
                  JDK源码 FinalReference
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T12:19:04+08:00">
                2017-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/01/JDK源码-FinalReference/" class="leancloud_visitors" data-flag-title="JDK源码 FinalReference">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="JAVA-FinalReference"><a href="#JAVA-FinalReference" class="headerlink" title="JAVA FinalReference"></a>JAVA FinalReference</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>使用MAT分析dump出的内存时，常会看到java.lang.ref.Finalizer占用内存也不小，比较纳闷我们在编程中并没有用到这个东西，为什么他会出现并且占用分量不算小的一部分内存呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalizer</span> <span class="keyword">extends</span> <span class="title">FinalReference</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</div><div class="line">	<span class="comment">//... ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结合它的数据结构基本可以看出来，Finalizer中持有一个一个引用队列。猜测是这个队列吃掉了那些内存。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/01/JDK源码-FinalReference/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/24/MAT-Memory-Analyzer-Tool-基本使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/24/MAT-Memory-Analyzer-Tool-基本使用/" itemprop="url">
                  MAT(Memory Analyzer Tool)基本使用
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T21:15:26+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/24/MAT-Memory-Analyzer-Tool-基本使用/" class="leancloud_visitors" data-flag-title="MAT(Memory Analyzer Tool)基本使用">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="MAT-Memory-Analyzer-Tool-基本使用"><a href="#MAT-Memory-Analyzer-Tool-基本使用" class="headerlink" title="MAT Memory Analyzer Tool 基本使用"></a>MAT Memory Analyzer Tool 基本使用</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>分析和理解我们应用中内存的分布是一件极具挑战的事情。一个逻辑错误就有可能导致OutOfMemory。dump内存的方式很单：<code>jmap -dump:format=b,file=path pid</code><br>注意操作时要有正确的用户权限。本篇旨在介绍分析中涉及到的一些概念和操作方法，实际案例分析放在下篇介绍。</p>
<p><strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
<h4 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h4>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/24/MAT-Memory-Analyzer-Tool-基本使用/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/07/Dubbo源码-SPI实现之ExtensionLoader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/Dubbo源码-SPI实现之ExtensionLoader/" itemprop="url">
                  Dubbo源码 SPI实现之ExtensionLoader
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T18:00:57+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/07/Dubbo源码-SPI实现之ExtensionLoader/" class="leancloud_visitors" data-flag-title="Dubbo源码 SPI实现之ExtensionLoader">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h4><p>SPI 全称为 (Service Provider Interface) ，JDK也默认提供了SPI的一种实现，不过对比Dubbo的实现，JDK的实现就非常简单。</p>
<p>简单说下JDK默认的SPI用法。</p>
<ol>
<li>定义Service接口</li>
<li>增加Service实现类</li>
<li>META-INF/services目录下建立以接口包全名命名的文件，文件中写入实现类的包名+类名</li>
<li>用Java提供的ServiceLoader来加载实现
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/07/Dubbo源码-SPI实现之ExtensionLoader/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/27/服务器Load飙高排查方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/27/服务器Load飙高排查方法/" itemprop="url">
                  服务器Load高简单排查
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-27T19:28:20+08:00">
                2017-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/27/服务器Load飙高排查方法/" class="leancloud_visitors" data-flag-title="服务器Load高简单排查">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="服务器Load飙高排查方法"><a href="#服务器Load飙高排查方法" class="headerlink" title="服务器Load飙高排查方法"></a>服务器Load飙高排查方法</h4><p>线上碰到CPU利用率高或者Load高的时候，排查的顺序。</p>
<ol>
<li>拿到进程PID：ps -ef | grep java 或者 jps</li>
<li>dump应用栈信息：jstack PID &gt; PID.stack</li>
<li>top查看导致高CPU的进程: top 后键入 x 默认按照CPU使用率排序进程，键入c可看到commond</li>
<li>查看导致高CPU利用率的线程信息：top -Hp PID</li>
<li>查看CPU利用率高线程的栈信息，stack文件中线程号为16进制，需要top出来的线程号进行转换：printf ‘%x\n’ ThreadPID
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/27/服务器Load飙高排查方法/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/14/JDK源码-AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/14/JDK源码-AQS/" itemprop="url">
                  JDK源码 AQS
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-14T11:17:03+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/02/14/JDK源码-AQS/" class="leancloud_visitors" data-flag-title="JDK源码 AQS">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="AbstractQueueSynchronizer笔记"><a href="#AbstractQueueSynchronizer笔记" class="headerlink" title="AbstractQueueSynchronizer笔记"></a>AbstractQueueSynchronizer笔记</h3><p>在开始介绍之前我先来简单理解一下为什么会产生AQS。在我们应用内不可避免的会发生对一些资源的抢占，那么如何处理线程之间对资源的争夺呢？在Java SE 5 之前JDK可以使用synchronized来串行化对资源的操作，synchronized可以隐式的获取和释放锁，但是带来的不便就是不够灵活，可扩展性没有显式获取和释放锁的自主控制性强，另外synchronized是完全互斥的，没法达到诸如共享锁、读写锁的效果。对资源的竞争可以抽象为对变量状态的竞争，这正是AQS实现的基本原理，当然，AQS的实现是复杂的。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/14/JDK源码-AQS/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/18/test4j导致Load飙高排查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/18/test4j导致Load飙高排查/" itemprop="url">
                  test4j导致Load飙高排查
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-18T13:38:20+08:00">
                2016-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/11/18/test4j导致Load飙高排查/" class="leancloud_visitors" data-flag-title="test4j导致Load飙高排查">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="记一次test4j导致CPU飙高的事故"><a href="#记一次test4j导致CPU飙高的事故" class="headerlink" title="记一次test4j导致CPU飙高的事故"></a>记一次test4j导致CPU飙高的事故</h3><p>在使用Jenkins构建工程时出现服务器Load不断飙升的现象，导致构建无法正常进行，查看构建日之后发现一些应用处出现OOM的状况。<br>于是，我就开始查找原因的漫漫长征路。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/11/18/test4j导致Load飙高排查/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://avatar.csdn.net/A/A/A/1_myjcxd.jpg"
               alt="childe.chen" />
          <p class="site-author-name" itemprop="name">childe.chen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/myjcxd" target="_blank" title="csdn博客">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  csdn博客
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">childe.chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info powered-by">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1261718599'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1261718599' type='text/javascript'%3E%3C/script%3E"));</script>

        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("E5piYXRh8kh2s871eaOiaWDy-gzGzoHsz", "sQ49rdQJm3HKGSWP726nAo2j");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


  

</body>
</html>
